# Auto-generated argument completers for parameters of SDK ConstantClass-derived type used in cmdlets.
# Do not modify this file; it may be overwritten during version upgrades.

$psMajorVersion = $PSVersionTable.PSVersion.Major
if ($psMajorVersion -eq 2) 
{ 
	Write-Verbose "Dynamic argument completion not supported in PowerShell version 2; skipping load."
	return 
}

# PowerShell's native Register-ArgumentCompleter cmdlet is available on v5.0 or higher. For lower
# version, we can use the version in the TabExpansion++ module if installed.
$registrationCmdletAvailable = ($psMajorVersion -ge 5) -Or !((Get-Command Register-ArgumentCompleter -ea Ignore) -eq $null)

# internal function to perform the registration using either cmdlet or manipulation
# of the options table
function _awsArgumentCompleterRegistration()
{
    param
    (
        [scriptblock]$scriptBlock,
        [hashtable]$param2CmdletsMap
    )

    if ($registrationCmdletAvailable)
    {
        foreach ($paramName in $param2CmdletsMap.Keys)
        {
             $args = @{
                "ScriptBlock" = $scriptBlock
                "Parameter" = $paramName
            }

            $cmdletNames = $param2CmdletsMap[$paramName]
            if ($cmdletNames -And $cmdletNames.Length -gt 0)
            {
                $args["Command"] = $cmdletNames
            }

            Register-ArgumentCompleter @args
        }
    }
    else
    {
        if (-not $global:options) { $global:options = @{ CustomArgumentCompleters = @{ }; NativeArgumentCompleters = @{ } } }

        foreach ($paramName in $param2CmdletsMap.Keys)
        {
            $cmdletNames = $param2CmdletsMap[$paramName]

            if ($cmdletNames -And $cmdletNames.Length -gt 0)
            {
                foreach ($cn in $cmdletNames)
                {
                    $fqn =  [string]::Concat($cn, ":", $paramName)
                    $global:options['CustomArgumentCompleters'][$fqn] = $scriptBlock
                }
            }
            else
            {
                $global:options['CustomArgumentCompleters'][$paramName] = $scriptBlock
            }
        }

        $function:tabexpansion2 = $function:tabexpansion2 -replace 'End\r\n{', 'End { if ($null -ne $options) { $options += $global:options} else {$options = $global:options}'
    }
}

# To allow for same-name parameters of different ConstantClass-derived types 
# each completer function checks on command name concatenated with parameter name.
# Additionally, the standard code pattern for completers is to pipe through 
# sort-object after filtering against $wordToComplete but we omit this as our members 
# are already sorted.

# Argument completions for service AWS IAM Access Analyzer


$IAMAA_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.AccessAnalyzer.FindingStatusUpdate
        "Update-IAMAAFinding/Status"
        {
            $v = "ACTIVE","ARCHIVED"
            break
        }

        # Amazon.AccessAnalyzer.OrderBy
        "Get-IAMAAFindingList/Sort_OrderBy"
        {
            $v = "ASC","DESC"
            break
        }

        # Amazon.AccessAnalyzer.ResourceType
        "Get-IAMAAAnalyzedResourceList/ResourceType"
        {
            $v = "AWS::IAM::Role","AWS::KMS::Key","AWS::Lambda::Function","AWS::Lambda::LayerVersion","AWS::S3::Bucket","AWS::SQS::Queue"
            break
        }

        # Amazon.AccessAnalyzer.Type
        {
            ($_ -eq "Get-IAMAAAnalyzerList/Type") -Or
            ($_ -eq "New-IAMAAAnalyzer/Type")
        }
        {
            $v = "ACCOUNT"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IAMAA_map = @{
    "ResourceType"=@("Get-IAMAAAnalyzedResourceList")
    "Sort_OrderBy"=@("Get-IAMAAFindingList")
    "Status"=@("Update-IAMAAFinding")
    "Type"=@("Get-IAMAAAnalyzerList","New-IAMAAAnalyzer")
}

_awsArgumentCompleterRegistration $IAMAA_Completers $IAMAA_map

$IAMAA_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.IAMAA.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IAMAA_SelectMap = @{
    "Select"=@("New-IAMAAAnalyzer",
               "New-IAMAAArchiveRule",
               "Remove-IAMAAAnalyzer",
               "Remove-IAMAAArchiveRule",
               "Get-IAMAAAnalyzedResource",
               "Get-IAMAAAnalyzer",
               "Get-IAMAAArchiveRule",
               "Get-IAMAAFinding",
               "Get-IAMAAAnalyzedResourceList",
               "Get-IAMAAAnalyzerList",
               "Get-IAMAAArchiveRuleList",
               "Get-IAMAAFindingList",
               "Get-IAMAAResourceTag",
               "Start-IAMAAResourceScan",
               "Add-IAMAAResourceTag",
               "Remove-IAMAAResourceTag",
               "Update-IAMAAArchiveRule",
               "Update-IAMAAFinding")
}

_awsArgumentCompleterRegistration $IAMAA_SelectCompleters $IAMAA_SelectMap
# Argument completions for service AWS Certificate Manager


$ACM_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CertificateManager.CertificateTransparencyLoggingPreference
        {
            ($_ -eq "New-ACMCertificate/Options_CertificateTransparencyLoggingPreference") -Or
            ($_ -eq "Update-ACMCertificateOption/Options_CertificateTransparencyLoggingPreference")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.CertificateManager.ValidationMethod
        "New-ACMCertificate/ValidationMethod"
        {
            $v = "DNS","EMAIL"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ACM_map = @{
    "Options_CertificateTransparencyLoggingPreference"=@("New-ACMCertificate","Update-ACMCertificateOption")
    "ValidationMethod"=@("New-ACMCertificate")
}

_awsArgumentCompleterRegistration $ACM_Completers $ACM_map

$ACM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ACM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ACM_SelectMap = @{
    "Select"=@("Add-ACMCertificateTag",
               "Remove-ACMCertificate",
               "Get-ACMCertificateDetail",
               "Export-ACMCertificate",
               "Get-ACMCertificate",
               "Import-ACMCertificate",
               "Get-ACMCertificateList",
               "Get-ACMCertificateTagList",
               "Remove-ACMCertificateTag",
               "Invoke-ACMCertificateRenewal",
               "New-ACMCertificate",
               "Send-ACMValidationEmail",
               "Update-ACMCertificateOption")
}

_awsArgumentCompleterRegistration $ACM_SelectCompleters $ACM_SelectMap
# Argument completions for service AWS Certificate Manager Private Certificate Authority


$PCA_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ACMPCA.AuditReportResponseFormat
        "New-PCACertificateAuthorityAuditReport/AuditReportResponseFormat"
        {
            $v = "CSV","JSON"
            break
        }

        # Amazon.ACMPCA.CertificateAuthorityStatus
        "Update-PCACertificateAuthority/Status"
        {
            $v = "ACTIVE","CREATING","DELETED","DISABLED","EXPIRED","FAILED","PENDING_CERTIFICATE"
            break
        }

        # Amazon.ACMPCA.CertificateAuthorityType
        "New-PCACertificateAuthority/CertificateAuthorityType"
        {
            $v = "ROOT","SUBORDINATE"
            break
        }

        # Amazon.ACMPCA.RevocationReason
        "Revoke-PCACertificate/RevocationReason"
        {
            $v = "AFFILIATION_CHANGED","A_A_COMPROMISE","CERTIFICATE_AUTHORITY_COMPROMISE","CESSATION_OF_OPERATION","KEY_COMPROMISE","PRIVILEGE_WITHDRAWN","SUPERSEDED","UNSPECIFIED"
            break
        }

        # Amazon.ACMPCA.SigningAlgorithm
        "New-PCACertificate/SigningAlgorithm"
        {
            $v = "SHA256WITHECDSA","SHA256WITHRSA","SHA384WITHECDSA","SHA384WITHRSA","SHA512WITHECDSA","SHA512WITHRSA"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$PCA_map = @{
    "AuditReportResponseFormat"=@("New-PCACertificateAuthorityAuditReport")
    "CertificateAuthorityType"=@("New-PCACertificateAuthority")
    "RevocationReason"=@("Revoke-PCACertificate")
    "SigningAlgorithm"=@("New-PCACertificate")
    "Status"=@("Update-PCACertificateAuthority")
}

_awsArgumentCompleterRegistration $PCA_Completers $PCA_map

$PCA_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.PCA.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$PCA_SelectMap = @{
    "Select"=@("New-PCACertificateAuthority",
               "New-PCACertificateAuthorityAuditReport",
               "New-PCAPermission",
               "Remove-PCACertificateAuthority",
               "Remove-PCAPermission",
               "Get-PCACertificateAuthority",
               "Get-PCACertificateAuthorityAuditReport",
               "Get-PCACertificate",
               "Get-PCACertificateAuthorityCertificate",
               "Get-PCACertificateAuthorityCsr",
               "Import-PCACertificateAuthorityCertificate",
               "New-PCACertificate",
               "Get-PCACertificateAuthorityList",
               "Get-PCAPermissionList",
               "Get-PCACertificateAuthorityTagList",
               "Restore-PCACertificateAuthority",
               "Revoke-PCACertificate",
               "Add-PCACertificateAuthorityTag",
               "Remove-PCACertificateAuthorityTag",
               "Update-PCACertificateAuthority")
}

_awsArgumentCompleterRegistration $PCA_SelectCompleters $PCA_SelectMap
# Argument completions for service Alexa For Business


$ALXB_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.AlexaForBusiness.BusinessReportFormat
        {
            ($_ -eq "New-ALXBBusinessReportSchedule/Format") -Or
            ($_ -eq "Update-ALXBBusinessReportSchedule/Format")
        }
        {
            $v = "CSV","CSV_ZIP"
            break
        }

        # Amazon.AlexaForBusiness.BusinessReportInterval
        "New-ALXBBusinessReportSchedule/ContentRange_Interval"
        {
            $v = "ONE_DAY","ONE_WEEK","THIRTY_DAYS"
            break
        }

        # Amazon.AlexaForBusiness.CommsProtocol
        {
            ($_ -eq "New-ALXBConferenceProvider/IPDialIn_CommsProtocol") -Or
            ($_ -eq "Update-ALXBConferenceProvider/IPDialIn_CommsProtocol")
        }
        {
            $v = "H323","SIP","SIPS"
            break
        }

        # Amazon.AlexaForBusiness.ConferenceProviderType
        {
            ($_ -eq "New-ALXBConferenceProvider/ConferenceProviderType") -Or
            ($_ -eq "Update-ALXBConferenceProvider/ConferenceProviderType")
        }
        {
            $v = "BLUEJEANS","CHIME","CUSTOM","FUZE","GOOGLE_HANGOUTS","POLYCOM","RINGCENTRAL","SKYPE_FOR_BUSINESS","WEBEX","ZOOM"
            break
        }

        # Amazon.AlexaForBusiness.DeviceEventType
        "Get-ALXBDeviceEventList/EventType"
        {
            $v = "CONNECTION_STATUS","DEVICE_STATUS"
            break
        }

        # Amazon.AlexaForBusiness.DeviceUsageType
        "Remove-ALXBDeviceUsageData/DeviceUsageType"
        {
            $v = "VOICE"
            break
        }

        # Amazon.AlexaForBusiness.DistanceUnit
        {
            ($_ -eq "New-ALXBProfile/DistanceUnit") -Or
            ($_ -eq "Update-ALXBProfile/DistanceUnit")
        }
        {
            $v = "IMPERIAL","METRIC"
            break
        }

        # Amazon.AlexaForBusiness.EnablementTypeFilter
        "Get-ALXBSkillList/EnablementType"
        {
            $v = "ENABLED","PENDING"
            break
        }

        # Amazon.AlexaForBusiness.EndOfMeetingReminderType
        {
            ($_ -eq "New-ALXBProfile/MeetingRoomConfiguration_EndOfMeetingReminder_ReminderType") -Or
            ($_ -eq "Update-ALXBProfile/MeetingRoomConfiguration_EndOfMeetingReminder_ReminderType")
        }
        {
            $v = "ANNOUNCEMENT_TIME_CHECK","ANNOUNCEMENT_VARIABLE_TIME_LEFT","CHIME","KNOCK"
            break
        }

        # Amazon.AlexaForBusiness.NetworkEapMethod
        "New-ALXBNetworkProfile/EapMethod"
        {
            $v = "EAP_TLS"
            break
        }

        # Amazon.AlexaForBusiness.NetworkSecurityType
        "New-ALXBNetworkProfile/SecurityType"
        {
            $v = "OPEN","WEP","WPA2_ENTERPRISE","WPA2_PSK","WPA_PSK"
            break
        }

        # Amazon.AlexaForBusiness.RequirePin
        {
            ($_ -eq "New-ALXBConferenceProvider/MeetingSetting_RequirePin") -Or
            ($_ -eq "Update-ALXBConferenceProvider/MeetingSetting_RequirePin")
        }
        {
            $v = "NO","OPTIONAL","YES"
            break
        }

        # Amazon.AlexaForBusiness.SkillTypeFilter
        "Get-ALXBSkillList/SkillType"
        {
            $v = "ALL","PRIVATE","PUBLIC"
            break
        }

        # Amazon.AlexaForBusiness.TemperatureUnit
        {
            ($_ -eq "New-ALXBProfile/TemperatureUnit") -Or
            ($_ -eq "Update-ALXBProfile/TemperatureUnit")
        }
        {
            $v = "CELSIUS","FAHRENHEIT"
            break
        }

        # Amazon.AlexaForBusiness.WakeWord
        {
            ($_ -eq "New-ALXBProfile/WakeWord") -Or
            ($_ -eq "Update-ALXBProfile/WakeWord")
        }
        {
            $v = "ALEXA","AMAZON","COMPUTER","ECHO"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ALXB_map = @{
    "ConferenceProviderType"=@("New-ALXBConferenceProvider","Update-ALXBConferenceProvider")
    "ContentRange_Interval"=@("New-ALXBBusinessReportSchedule")
    "DeviceUsageType"=@("Remove-ALXBDeviceUsageData")
    "DistanceUnit"=@("New-ALXBProfile","Update-ALXBProfile")
    "EapMethod"=@("New-ALXBNetworkProfile")
    "EnablementType"=@("Get-ALXBSkillList")
    "EventType"=@("Get-ALXBDeviceEventList")
    "Format"=@("New-ALXBBusinessReportSchedule","Update-ALXBBusinessReportSchedule")
    "IPDialIn_CommsProtocol"=@("New-ALXBConferenceProvider","Update-ALXBConferenceProvider")
    "MeetingRoomConfiguration_EndOfMeetingReminder_ReminderType"=@("New-ALXBProfile","Update-ALXBProfile")
    "MeetingSetting_RequirePin"=@("New-ALXBConferenceProvider","Update-ALXBConferenceProvider")
    "SecurityType"=@("New-ALXBNetworkProfile")
    "SkillType"=@("Get-ALXBSkillList")
    "TemperatureUnit"=@("New-ALXBProfile","Update-ALXBProfile")
    "WakeWord"=@("New-ALXBProfile","Update-ALXBProfile")
}

_awsArgumentCompleterRegistration $ALXB_Completers $ALXB_map

$ALXB_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ALXB.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ALXB_SelectMap = @{
    "Select"=@("Approve-ALXBSkill",
               "Add-ALXBContactToAddressBook",
               "Add-ALXBDeviceToNetworkProfile",
               "Add-ALXBDeviceToRoom",
               "Add-ALXBSkillGroupToRoom",
               "Add-ALXBSkillToSkillGroup",
               "Add-ALXBSkillToUser",
               "New-ALXBAddressBook",
               "New-ALXBBusinessReportSchedule",
               "New-ALXBConferenceProvider",
               "New-ALXBContact",
               "New-ALXBGatewayGroup",
               "New-ALXBNetworkProfile",
               "New-ALXBProfile",
               "New-ALXBRoom",
               "New-ALXBSkillGroup",
               "New-ALXBUser",
               "Remove-ALXBAddressBook",
               "Remove-ALXBBusinessReportSchedule",
               "Remove-ALXBConferenceProvider",
               "Remove-ALXBContact",
               "Remove-ALXBDevice",
               "Remove-ALXBDeviceUsageData",
               "Remove-ALXBGatewayGroup",
               "Remove-ALXBNetworkProfile",
               "Remove-ALXBProfile",
               "Remove-ALXBRoom",
               "Remove-ALXBRoomSkillParameter",
               "Remove-ALXBSkillAuthorization",
               "Remove-ALXBSkillGroup",
               "Remove-ALXBUser",
               "Remove-ALXBContactFromAddressBook",
               "Remove-ALXBDeviceFromRoom",
               "Remove-ALXBSkillFromSkillGroup",
               "Remove-ALXBSkillFromUser",
               "Remove-ALXBSkillGroupFromRoom",
               "Remove-ALXBSmartHomeAppliance",
               "Get-ALXBAddressBook",
               "Get-ALXBConferencePreference",
               "Get-ALXBConferenceProvider",
               "Get-ALXBContact",
               "Get-ALXBDevice",
               "Get-ALXBGateway",
               "Get-ALXBGatewayGroup",
               "Get-ALXBInvitationConfiguration",
               "Get-ALXBNetworkProfile",
               "Get-ALXBProfile",
               "Get-ALXBRoom",
               "Get-ALXBRoomSkillParameter",
               "Get-ALXBSkillGroup",
               "Get-ALXBBusinessReportScheduleList",
               "Get-ALXBConferenceProviderList",
               "Get-ALXBDeviceEventList",
               "Get-ALXBGatewayGroupList",
               "Get-ALXBGatewayList",
               "Get-ALXBSkillList",
               "Get-ALXBSkillsStoreCategoryList",
               "Get-ALXBSkillsStoreSkillListByCategory",
               "Get-ALXBSmartHomeApplianceList",
               "Get-ALXBTagList",
               "Write-ALXBConferencePreference",
               "Write-ALXBInvitationConfiguration",
               "Set-ALXBRoomSkillParameter",
               "Write-ALXBSkillAuthorization",
               "Register-ALXBAVSDevice",
               "Deny-ALXBSkill",
               "Resolve-ALXBRoom",
               "Revoke-ALXBInvitation",
               "Search-ALXBAddressBook",
               "Search-ALXBContact",
               "Find-ALXBDevice",
               "Search-ALXBNetworkProfile",
               "Find-ALXBProfile",
               "Find-ALXBRoom",
               "Find-ALXBSkillGroup",
               "Find-ALXBUser",
               "Send-ALXBAnnouncement",
               "Send-ALXBInvitation",
               "Start-ALXBDeviceSync",
               "Start-ALXBSmartHomeApplianceDiscovery",
               "Add-ALXBResourceTag",
               "Remove-ALXBResourceTag",
               "Update-ALXBAddressBook",
               "Update-ALXBBusinessReportSchedule",
               "Update-ALXBConferenceProvider",
               "Update-ALXBContact",
               "Update-ALXBDevice",
               "Update-ALXBGateway",
               "Update-ALXBGatewayGroup",
               "Update-ALXBNetworkProfile",
               "Update-ALXBProfile",
               "Update-ALXBRoom",
               "Update-ALXBSkillGroup")
}

_awsArgumentCompleterRegistration $ALXB_SelectCompleters $ALXB_SelectMap
# Argument completions for service AWS Amplify


$AMP_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Amplify.JobType
        "Start-AMPJob/JobType"
        {
            $v = "MANUAL","RELEASE","RETRY","WEB_HOOK"
            break
        }

        # Amazon.Amplify.Platform
        {
            ($_ -eq "New-AMPApp/Platform") -Or
            ($_ -eq "Update-AMPApp/Platform")
        }
        {
            $v = "WEB"
            break
        }

        # Amazon.Amplify.Stage
        {
            ($_ -eq "New-AMPApp/AutoBranchCreationConfig_Stage") -Or
            ($_ -eq "Update-AMPApp/AutoBranchCreationConfig_Stage") -Or
            ($_ -eq "New-AMPBranch/Stage") -Or
            ($_ -eq "Update-AMPBranch/Stage")
        }
        {
            $v = "BETA","DEVELOPMENT","EXPERIMENTAL","PRODUCTION","PULL_REQUEST"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AMP_map = @{
    "AutoBranchCreationConfig_Stage"=@("New-AMPApp","Update-AMPApp")
    "JobType"=@("Start-AMPJob")
    "Platform"=@("New-AMPApp","Update-AMPApp")
    "Stage"=@("New-AMPBranch","Update-AMPBranch")
}

_awsArgumentCompleterRegistration $AMP_Completers $AMP_map

$AMP_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.AMP.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AMP_SelectMap = @{
    "Select"=@("New-AMPApp",
               "New-AMPBackendEnvironment",
               "New-AMPBranch",
               "New-AMPDeployment",
               "New-AMPDomainAssociation",
               "New-AMPWebhook",
               "Remove-AMPApp",
               "Remove-AMPBackendEnvironment",
               "Remove-AMPBranch",
               "Remove-AMPDomainAssociation",
               "Remove-AMPJob",
               "Remove-AMPWebhook",
               "New-AMPAccessLog",
               "Get-AMPApp",
               "Get-AMPArtifactUrl",
               "Get-AMPBackendEnvironment",
               "Get-AMPBranch",
               "Get-AMPDomainAssociation",
               "Get-AMPJob",
               "Get-AMPWebhook",
               "Get-AMPAppList",
               "Get-AMPArtifactList",
               "Get-AMPBackendEnvironmentList",
               "Get-AMPBranchList",
               "Get-AMPDomainAssociationList",
               "Get-AMPJobList",
               "Get-AMPResourceTag",
               "Get-AMPWebhookList",
               "Start-AMPDeployment",
               "Start-AMPJob",
               "Stop-AMPJob",
               "Add-AMPResourceTag",
               "Remove-AMPResourceTag",
               "Update-AMPApp",
               "Update-AMPBranch",
               "Update-AMPDomainAssociation",
               "Update-AMPWebhook")
}

_awsArgumentCompleterRegistration $AMP_SelectCompleters $AMP_SelectMap
# Argument completions for service Amazon API Gateway


$AG_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.APIGateway.ApiKeysFormat
        "Import-AGApiKey/Format"
        {
            $v = "csv"
            break
        }

        # Amazon.APIGateway.ApiKeySourceType
        "New-AGRestApi/ApiKeySource"
        {
            $v = "AUTHORIZER","HEADER"
            break
        }

        # Amazon.APIGateway.AuthorizerType
        "New-AGAuthorizer/Type"
        {
            $v = "COGNITO_USER_POOLS","REQUEST","TOKEN"
            break
        }

        # Amazon.APIGateway.CacheClusterSize
        {
            ($_ -eq "New-AGDeployment/CacheClusterSize") -Or
            ($_ -eq "New-AGStage/CacheClusterSize")
        }
        {
            $v = "0.5","1.6","118","13.5","237","28.4","58.2","6.1"
            break
        }

        # Amazon.APIGateway.ConnectionType
        "Write-AGIntegration/ConnectionType"
        {
            $v = "INTERNET","VPC_LINK"
            break
        }

        # Amazon.APIGateway.ContentHandlingStrategy
        {
            ($_ -eq "Write-AGIntegration/ContentHandling") -Or
            ($_ -eq "Write-AGIntegrationResponse/ContentHandling")
        }
        {
            $v = "CONVERT_TO_BINARY","CONVERT_TO_TEXT"
            break
        }

        # Amazon.APIGateway.DocumentationPartType
        {
            ($_ -eq "New-AGDocumentationPart/Location_Type") -Or
            ($_ -eq "Get-AGDocumentationPartList/Type")
        }
        {
            $v = "API","AUTHORIZER","METHOD","MODEL","PATH_PARAMETER","QUERY_PARAMETER","REQUEST_BODY","REQUEST_HEADER","RESOURCE","RESPONSE","RESPONSE_BODY","RESPONSE_HEADER"
            break
        }

        # Amazon.APIGateway.GatewayResponseType
        {
            ($_ -eq "Get-AGGatewayResponse/ResponseType") -Or
            ($_ -eq "Remove-AGGatewayResponse/ResponseType") -Or
            ($_ -eq "Update-AGGatewayResponse/ResponseType") -Or
            ($_ -eq "Write-AGGatewayResponse/ResponseType")
        }
        {
            $v = "ACCESS_DENIED","API_CONFIGURATION_ERROR","AUTHORIZER_CONFIGURATION_ERROR","AUTHORIZER_FAILURE","BAD_REQUEST_BODY","BAD_REQUEST_PARAMETERS","DEFAULT_4XX","DEFAULT_5XX","EXPIRED_TOKEN","INTEGRATION_FAILURE","INTEGRATION_TIMEOUT","INVALID_API_KEY","INVALID_SIGNATURE","MISSING_AUTHENTICATION_TOKEN","QUOTA_EXCEEDED","REQUEST_TOO_LARGE","RESOURCE_NOT_FOUND","THROTTLED","UNAUTHORIZED","UNSUPPORTED_MEDIA_TYPE"
            break
        }

        # Amazon.APIGateway.IntegrationType
        "Write-AGIntegration/Type"
        {
            $v = "AWS","AWS_PROXY","HTTP","HTTP_PROXY","MOCK"
            break
        }

        # Amazon.APIGateway.LocationStatusType
        "Get-AGDocumentationPartList/LocationStatus"
        {
            $v = "DOCUMENTED","UNDOCUMENTED"
            break
        }

        # Amazon.APIGateway.PutMode
        {
            ($_ -eq "Import-AGDocumentationPartList/Mode") -Or
            ($_ -eq "Write-AGRestApi/Mode")
        }
        {
            $v = "merge","overwrite"
            break
        }

        # Amazon.APIGateway.QuotaPeriodType
        "New-AGUsagePlan/Quota_Period"
        {
            $v = "DAY","MONTH","WEEK"
            break
        }

        # Amazon.APIGateway.SecurityPolicy
        "New-AGDomainName/SecurityPolicy"
        {
            $v = "TLS_1_0","TLS_1_2"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AG_map = @{
    "ApiKeySource"=@("New-AGRestApi")
    "CacheClusterSize"=@("New-AGDeployment","New-AGStage")
    "ConnectionType"=@("Write-AGIntegration")
    "ContentHandling"=@("Write-AGIntegration","Write-AGIntegrationResponse")
    "Format"=@("Import-AGApiKey")
    "Location_Type"=@("New-AGDocumentationPart")
    "LocationStatus"=@("Get-AGDocumentationPartList")
    "Mode"=@("Import-AGDocumentationPartList","Write-AGRestApi")
    "Quota_Period"=@("New-AGUsagePlan")
    "ResponseType"=@("Get-AGGatewayResponse","Remove-AGGatewayResponse","Update-AGGatewayResponse","Write-AGGatewayResponse")
    "SecurityPolicy"=@("New-AGDomainName")
    "Type"=@("Get-AGDocumentationPartList","New-AGAuthorizer","Write-AGIntegration")
}

_awsArgumentCompleterRegistration $AG_Completers $AG_map

$AG_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.AG.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AG_SelectMap = @{
    "Select"=@("New-AGApiKey",
               "New-AGAuthorizer",
               "New-AGBasePathMapping",
               "New-AGDeployment",
               "New-AGDocumentationPart",
               "New-AGDocumentationVersion",
               "New-AGDomainName",
               "New-AGModel",
               "New-AGRequestValidator",
               "New-AGResource",
               "New-AGRestApi",
               "New-AGStage",
               "New-AGUsagePlan",
               "New-AGUsagePlanKey",
               "New-AGVpcLink",
               "Remove-AGApiKey",
               "Remove-AGAuthorizer",
               "Remove-AGBasePathMapping",
               "Remove-AGClientCertificate",
               "Remove-AGDeployment",
               "Remove-AGDocumentationPart",
               "Remove-AGDocumentationVersion",
               "Remove-AGDomainName",
               "Remove-AGGatewayResponse",
               "Remove-AGIntegration",
               "Remove-AGIntegrationResponse",
               "Remove-AGMethod",
               "Remove-AGMethodResponse",
               "Remove-AGModel",
               "Remove-AGRequestValidator",
               "Remove-AGResource",
               "Remove-AGRestApi",
               "Remove-AGStage",
               "Remove-AGUsagePlan",
               "Remove-AGUsagePlanKey",
               "Remove-AGVpcLink",
               "Clear-AGStageAuthorizersCache",
               "Clear-AGStageCache",
               "New-AGClientCertificate",
               "Get-AGAccount",
               "Get-AGApiKey",
               "Get-AGApiKeyList",
               "Get-AGAuthorizer",
               "Get-AGAuthorizerList",
               "Get-AGBasePathMapping",
               "Get-AGBasePathMappingList",
               "Get-AGClientCertificate",
               "Get-AGClientCertificateList",
               "Get-AGDeployment",
               "Get-AGDeploymentList",
               "Get-AGDocumentationPart",
               "Get-AGDocumentationPartList",
               "Get-AGDocumentationVersion",
               "Get-AGDocumentationVersionList",
               "Get-AGDomainName",
               "Get-AGDomainNameList",
               "Get-AGExport",
               "Get-AGGatewayResponse",
               "Get-AGGatewayResponseList",
               "Get-AGIntegration",
               "Get-AGIntegrationResponse",
               "Get-AGMethod",
               "Get-AGMethodResponse",
               "Get-AGModel",
               "Get-AGModelList",
               "Get-AGModelTemplate",
               "Get-AGRequestValidator",
               "Get-AGValidatorList",
               "Get-AGResource",
               "Get-AGResourceList",
               "Get-AGRestApi",
               "Get-AGRestApiList",
               "Get-AGSdk",
               "Get-AGSdkType",
               "Get-AGSdkTypeList",
               "Get-AGStage",
               "Get-AGStageList",
               "Get-AGResourceTag",
               "Get-AGUsage",
               "Get-AGUsagePlan",
               "Get-AGUsagePlanKey",
               "Get-AGUsagePlanKeyList",
               "Get-AGUsagePlanList",
               "Get-AGVpcLink",
               "Get-AGVpcLinkList",
               "Import-AGApiKey",
               "Import-AGDocumentationPartList",
               "Import-AGRestApi",
               "Write-AGGatewayResponse",
               "Write-AGIntegration",
               "Write-AGIntegrationResponse",
               "Write-AGMethod",
               "Write-AGMethodResponse",
               "Write-AGRestApi",
               "Add-AGResourceTag",
               "Test-AGInvokeAuthorizer",
               "Test-AGInvokeMethod",
               "Remove-AGResourceTag",
               "Update-AGAccount",
               "Update-AGApiKey",
               "Update-AGAuthorizer",
               "Update-AGBasePathMapping",
               "Update-AGClientCertificate",
               "Update-AGDeployment",
               "Update-AGDocumentationPart",
               "Update-AGDocumentationVersion",
               "Update-AGDomainName",
               "Update-AGGatewayResponse",
               "Update-AGIntegration",
               "Update-AGIntegrationResponse",
               "Update-AGMethod",
               "Update-AGMethodResponse",
               "Update-AGModel",
               "Update-AGRequestValidator",
               "Update-AGResource",
               "Update-AGRestApi",
               "Update-AGStage",
               "Update-AGUsage",
               "Update-AGUsagePlan",
               "Update-AGVpcLink")
}

_awsArgumentCompleterRegistration $AG_SelectCompleters $AG_SelectMap
# Argument completions for service Amazon API Gateway Management API


$AGM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.AGM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AGM_SelectMap = @{
    "Select"=@("Remove-AGMConnection",
               "Get-AGMConnection",
               "Send-AGMDataToConnection")
}

_awsArgumentCompleterRegistration $AGM_SelectCompleters $AGM_SelectMap
# Argument completions for service Amazon API Gateway V2


$AG2_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ApiGatewayV2.AuthorizationType
        {
            ($_ -eq "New-AG2Route/AuthorizationType") -Or
            ($_ -eq "Update-AG2Route/AuthorizationType")
        }
        {
            $v = "AWS_IAM","CUSTOM","JWT","NONE"
            break
        }

        # Amazon.ApiGatewayV2.AuthorizerType
        {
            ($_ -eq "New-AG2Authorizer/AuthorizerType") -Or
            ($_ -eq "Update-AG2Authorizer/AuthorizerType")
        }
        {
            $v = "JWT","REQUEST"
            break
        }

        # Amazon.ApiGatewayV2.ConnectionType
        {
            ($_ -eq "New-AG2Integration/ConnectionType") -Or
            ($_ -eq "Update-AG2Integration/ConnectionType")
        }
        {
            $v = "INTERNET","VPC_LINK"
            break
        }

        # Amazon.ApiGatewayV2.ContentHandlingStrategy
        {
            ($_ -eq "New-AG2Integration/ContentHandlingStrategy") -Or
            ($_ -eq "New-AG2IntegrationResponse/ContentHandlingStrategy") -Or
            ($_ -eq "Update-AG2Integration/ContentHandlingStrategy") -Or
            ($_ -eq "Update-AG2IntegrationResponse/ContentHandlingStrategy")
        }
        {
            $v = "CONVERT_TO_BINARY","CONVERT_TO_TEXT"
            break
        }

        # Amazon.ApiGatewayV2.IntegrationType
        {
            ($_ -eq "New-AG2Integration/IntegrationType") -Or
            ($_ -eq "Update-AG2Integration/IntegrationType")
        }
        {
            $v = "AWS","AWS_PROXY","HTTP","HTTP_PROXY","MOCK"
            break
        }

        # Amazon.ApiGatewayV2.LoggingLevel
        {
            ($_ -eq "New-AG2Stage/DefaultRouteSettings_LoggingLevel") -Or
            ($_ -eq "Update-AG2Stage/DefaultRouteSettings_LoggingLevel")
        }
        {
            $v = "ERROR","false","INFO"
            break
        }

        # Amazon.ApiGatewayV2.PassthroughBehavior
        {
            ($_ -eq "New-AG2Integration/PassthroughBehavior") -Or
            ($_ -eq "Update-AG2Integration/PassthroughBehavior")
        }
        {
            $v = "NEVER","WHEN_NO_MATCH","WHEN_NO_TEMPLATES"
            break
        }

        # Amazon.ApiGatewayV2.ProtocolType
        "New-AG2Api/ProtocolType"
        {
            $v = "HTTP","WEBSOCKET"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AG2_map = @{
    "AuthorizationType"=@("New-AG2Route","Update-AG2Route")
    "AuthorizerType"=@("New-AG2Authorizer","Update-AG2Authorizer")
    "ConnectionType"=@("New-AG2Integration","Update-AG2Integration")
    "ContentHandlingStrategy"=@("New-AG2Integration","New-AG2IntegrationResponse","Update-AG2Integration","Update-AG2IntegrationResponse")
    "DefaultRouteSettings_LoggingLevel"=@("New-AG2Stage","Update-AG2Stage")
    "IntegrationType"=@("New-AG2Integration","Update-AG2Integration")
    "PassthroughBehavior"=@("New-AG2Integration","Update-AG2Integration")
    "ProtocolType"=@("New-AG2Api")
}

_awsArgumentCompleterRegistration $AG2_Completers $AG2_map

$AG2_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.AG2.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AG2_SelectMap = @{
    "Select"=@("New-AG2Api",
               "New-AG2ApiMapping",
               "New-AG2Authorizer",
               "New-AG2Deployment",
               "New-AG2DomainName",
               "New-AG2Integration",
               "New-AG2IntegrationResponse",
               "New-AG2Model",
               "New-AG2Route",
               "New-AG2RouteResponse",
               "New-AG2Stage",
               "Remove-AG2Api",
               "Remove-AG2ApiMapping",
               "Remove-AG2Authorizer",
               "Remove-AG2CorsConfiguration",
               "Remove-AG2Deployment",
               "Remove-AG2DomainName",
               "Remove-AG2Integration",
               "Remove-AG2IntegrationResponse",
               "Remove-AG2Model",
               "Remove-AG2Route",
               "Remove-AG2RouteResponse",
               "Remove-AG2RouteSetting",
               "Remove-AG2Stage",
               "Get-AG2Api",
               "Get-AG2ApiMapping",
               "Get-AG2ApiMappingList",
               "Get-AG2ApiList",
               "Get-AG2Authorizer",
               "Get-AG2AuthorizerList",
               "Get-AG2Deployment",
               "Get-AG2DeploymentList",
               "Get-AG2DomainName",
               "Get-AG2DomainNameList",
               "Get-AG2Integration",
               "Get-AG2IntegrationResponse",
               "Get-AG2IntegrationResponseList",
               "Get-AG2IntegrationList",
               "Get-AG2Model",
               "Get-AG2ModelList",
               "Get-AG2ModelTemplate",
               "Get-AG2Route",
               "Get-AG2RouteResponse",
               "Get-AG2RouteResponseList",
               "Get-AG2RouteList",
               "Get-AG2Stage",
               "Get-AG2StageList",
               "Get-AG2Tag",
               "Import-AG2Api",
               "Update-AG2ApiImport",
               "Add-AG2ResourceTag",
               "Remove-AG2ResourceTag",
               "Update-AG2Api",
               "Update-AG2ApiMapping",
               "Update-AG2Authorizer",
               "Update-AG2Deployment",
               "Update-AG2DomainName",
               "Update-AG2Integration",
               "Update-AG2IntegrationResponse",
               "Update-AG2Model",
               "Update-AG2Route",
               "Update-AG2RouteResponse",
               "Update-AG2Stage")
}

_awsArgumentCompleterRegistration $AG2_SelectCompleters $AG2_SelectMap
# Argument completions for service AWS AppConfig


$APPC_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.AppConfig.GrowthType
        {
            ($_ -eq "New-APPCDeploymentStrategy/GrowthType") -Or
            ($_ -eq "Update-APPCDeploymentStrategy/GrowthType")
        }
        {
            $v = "LINEAR"
            break
        }

        # Amazon.AppConfig.ReplicateTo
        "New-APPCDeploymentStrategy/ReplicateTo"
        {
            $v = "NONE","SSM_DOCUMENT"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$APPC_map = @{
    "GrowthType"=@("New-APPCDeploymentStrategy","Update-APPCDeploymentStrategy")
    "ReplicateTo"=@("New-APPCDeploymentStrategy")
}

_awsArgumentCompleterRegistration $APPC_Completers $APPC_map

$APPC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.APPC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$APPC_SelectMap = @{
    "Select"=@("New-APPCApplication",
               "New-APPCConfigurationProfile",
               "New-APPCDeploymentStrategy",
               "New-APPCEnvironment",
               "Remove-APPCApplication",
               "Remove-APPCConfigurationProfile",
               "Remove-APPCDeploymentStrategy",
               "Remove-APPCEnvironment",
               "Get-APPCApplication",
               "Get-APPCConfiguration",
               "Get-APPCConfigurationProfile",
               "Get-APPCDeployment",
               "Get-APPCDeploymentStrategy",
               "Get-APPCEnvironment",
               "Get-APPCApplicationList",
               "Get-APPCConfigurationProfileList",
               "Get-APPCDeploymentList",
               "Get-APPCDeploymentStrategyList",
               "Get-APPCEnvironmentList",
               "Get-APPCResourceTag",
               "Start-APPCDeployment",
               "Stop-APPCDeployment",
               "Add-APPCResourceTag",
               "Remove-APPCResourceTag",
               "Update-APPCApplication",
               "Update-APPCConfigurationProfile",
               "Update-APPCDeploymentStrategy",
               "Update-APPCEnvironment",
               "Test-APPCConfigurationValidity")
}

_awsArgumentCompleterRegistration $APPC_SelectCompleters $APPC_SelectMap
# Argument completions for service Application Auto Scaling


$AAS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ApplicationAutoScaling.AdjustmentType
        "Set-AASScalingPolicy/StepScalingPolicyConfiguration_AdjustmentType"
        {
            $v = "ChangeInCapacity","ExactCapacity","PercentChangeInCapacity"
            break
        }

        # Amazon.ApplicationAutoScaling.MetricAggregationType
        "Set-AASScalingPolicy/StepScalingPolicyConfiguration_MetricAggregationType"
        {
            $v = "Average","Maximum","Minimum"
            break
        }

        # Amazon.ApplicationAutoScaling.MetricStatistic
        "Set-AASScalingPolicy/TargetTrackingScalingPolicyConfiguration_CustomizedMetricSpecification_Statistic"
        {
            $v = "Average","Maximum","Minimum","SampleCount","Sum"
            break
        }

        # Amazon.ApplicationAutoScaling.MetricType
        "Set-AASScalingPolicy/TargetTrackingScalingPolicyConfiguration_PredefinedMetricSpecification_PredefinedMetricType"
        {
            $v = "ALBRequestCountPerTarget","AppStreamAverageCapacityUtilization","ComprehendInferenceUtilization","DynamoDBReadCapacityUtilization","DynamoDBWriteCapacityUtilization","EC2SpotFleetRequestAverageCPUUtilization","EC2SpotFleetRequestAverageNetworkIn","EC2SpotFleetRequestAverageNetworkOut","ECSServiceAverageCPUUtilization","ECSServiceAverageMemoryUtilization","LambdaProvisionedConcurrencyUtilization","RDSReaderAverageCPUUtilization","RDSReaderAverageDatabaseConnections","SageMakerVariantInvocationsPerInstance"
            break
        }

        # Amazon.ApplicationAutoScaling.PolicyType
        "Set-AASScalingPolicy/PolicyType"
        {
            $v = "StepScaling","TargetTrackingScaling"
            break
        }

        # Amazon.ApplicationAutoScaling.ScalableDimension
        {
            ($_ -eq "Add-AASScalableTarget/ScalableDimension") -Or
            ($_ -eq "Get-AASScalableTarget/ScalableDimension") -Or
            ($_ -eq "Get-AASScalingActivity/ScalableDimension") -Or
            ($_ -eq "Get-AASScalingPolicy/ScalableDimension") -Or
            ($_ -eq "Get-AASScheduledAction/ScalableDimension") -Or
            ($_ -eq "Remove-AASScalableTarget/ScalableDimension") -Or
            ($_ -eq "Remove-AASScalingPolicy/ScalableDimension") -Or
            ($_ -eq "Remove-AASScheduledAction/ScalableDimension") -Or
            ($_ -eq "Set-AASScalingPolicy/ScalableDimension") -Or
            ($_ -eq "Set-AASScheduledAction/ScalableDimension")
        }
        {
            $v = "appstream:fleet:DesiredCapacity","comprehend:document-classifier-endpoint:DesiredInferenceUnits","custom-resource:ResourceType:Property","dynamodb:index:ReadCapacityUnits","dynamodb:index:WriteCapacityUnits","dynamodb:table:ReadCapacityUnits","dynamodb:table:WriteCapacityUnits","ec2:spot-fleet-request:TargetCapacity","ecs:service:DesiredCount","elasticmapreduce:instancegroup:InstanceCount","lambda:function:ProvisionedConcurrency","rds:cluster:ReadReplicaCount","sagemaker:variant:DesiredInstanceCount"
            break
        }

        # Amazon.ApplicationAutoScaling.ServiceNamespace
        {
            ($_ -eq "Add-AASScalableTarget/ServiceNamespace") -Or
            ($_ -eq "Get-AASScalableTarget/ServiceNamespace") -Or
            ($_ -eq "Get-AASScalingActivity/ServiceNamespace") -Or
            ($_ -eq "Get-AASScalingPolicy/ServiceNamespace") -Or
            ($_ -eq "Get-AASScheduledAction/ServiceNamespace") -Or
            ($_ -eq "Remove-AASScalableTarget/ServiceNamespace") -Or
            ($_ -eq "Remove-AASScalingPolicy/ServiceNamespace") -Or
            ($_ -eq "Remove-AASScheduledAction/ServiceNamespace") -Or
            ($_ -eq "Set-AASScalingPolicy/ServiceNamespace") -Or
            ($_ -eq "Set-AASScheduledAction/ServiceNamespace")
        }
        {
            $v = "appstream","comprehend","custom-resource","dynamodb","ec2","ecs","elasticmapreduce","lambda","rds","sagemaker"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AAS_map = @{
    "PolicyType"=@("Set-AASScalingPolicy")
    "ScalableDimension"=@("Add-AASScalableTarget","Get-AASScalableTarget","Get-AASScalingActivity","Get-AASScalingPolicy","Get-AASScheduledAction","Remove-AASScalableTarget","Remove-AASScalingPolicy","Remove-AASScheduledAction","Set-AASScalingPolicy","Set-AASScheduledAction")
    "ServiceNamespace"=@("Add-AASScalableTarget","Get-AASScalableTarget","Get-AASScalingActivity","Get-AASScalingPolicy","Get-AASScheduledAction","Remove-AASScalableTarget","Remove-AASScalingPolicy","Remove-AASScheduledAction","Set-AASScalingPolicy","Set-AASScheduledAction")
    "StepScalingPolicyConfiguration_AdjustmentType"=@("Set-AASScalingPolicy")
    "StepScalingPolicyConfiguration_MetricAggregationType"=@("Set-AASScalingPolicy")
    "TargetTrackingScalingPolicyConfiguration_CustomizedMetricSpecification_Statistic"=@("Set-AASScalingPolicy")
    "TargetTrackingScalingPolicyConfiguration_PredefinedMetricSpecification_PredefinedMetricType"=@("Set-AASScalingPolicy")
}

_awsArgumentCompleterRegistration $AAS_Completers $AAS_map

$AAS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.AAS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AAS_SelectMap = @{
    "Select"=@("Remove-AASScalingPolicy",
               "Remove-AASScheduledAction",
               "Remove-AASScalableTarget",
               "Get-AASScalableTarget",
               "Get-AASScalingActivity",
               "Get-AASScalingPolicy",
               "Get-AASScheduledAction",
               "Set-AASScalingPolicy",
               "Set-AASScheduledAction",
               "Add-AASScalableTarget")
}

_awsArgumentCompleterRegistration $AAS_SelectCompleters $AAS_SelectMap
# Argument completions for service Amazon CloudWatch Application Insights


$CWAI_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ApplicationInsights.Tier
        {
            ($_ -eq "Get-CWAIComponentConfigurationRecommendation/Tier") -Or
            ($_ -eq "Update-CWAIComponentConfiguration/Tier")
        }
        {
            $v = "DEFAULT","DOT_NET_CORE","DOT_NET_WEB","DOT_NET_WORKER","SQL_SERVER"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CWAI_map = @{
    "Tier"=@("Get-CWAIComponentConfigurationRecommendation","Update-CWAIComponentConfiguration")
}

_awsArgumentCompleterRegistration $CWAI_Completers $CWAI_map

$CWAI_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CWAI.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CWAI_SelectMap = @{
    "Select"=@("New-CWAIApplication",
               "New-CWAIComponent",
               "New-CWAILogPattern",
               "Remove-CWAIApplication",
               "Remove-CWAIComponent",
               "Remove-CWAILogPattern",
               "Get-CWAIApplication",
               "Get-CWAIComponent",
               "Get-CWAIComponentConfiguration",
               "Get-CWAIComponentConfigurationRecommendation",
               "Get-CWAILogPattern",
               "Get-CWAIObservation",
               "Get-CWAIProblem",
               "Get-CWAIProblemObservation",
               "Get-CWAIApplicationList",
               "Get-CWAIComponentList",
               "Get-CWAILogPatternList",
               "Get-CWAILogPatternSetList",
               "Get-CWAIProblemList",
               "Get-CWAIResourceTag",
               "Add-CWAIResourceTag",
               "Remove-CWAIResourceTag",
               "Update-CWAIApplication",
               "Update-CWAIComponent",
               "Update-CWAIComponentConfiguration",
               "Update-CWAILogPattern")
}

_awsArgumentCompleterRegistration $CWAI_SelectCompleters $CWAI_SelectMap
# Argument completions for service AWS App Mesh


$AMSH_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.AppMesh.DurationUnit
        {
            ($_ -eq "New-AMSHRoute/Spec_GrpcRoute_RetryPolicy_PerRetryTimeout_Unit") -Or
            ($_ -eq "Update-AMSHRoute/Spec_GrpcRoute_RetryPolicy_PerRetryTimeout_Unit") -Or
            ($_ -eq "New-AMSHRoute/Spec_Http2Route_RetryPolicy_PerRetryTimeout_Unit") -Or
            ($_ -eq "Update-AMSHRoute/Spec_Http2Route_RetryPolicy_PerRetryTimeout_Unit") -Or
            ($_ -eq "New-AMSHRoute/Spec_HttpRoute_RetryPolicy_PerRetryTimeout_Unit") -Or
            ($_ -eq "Update-AMSHRoute/Spec_HttpRoute_RetryPolicy_PerRetryTimeout_Unit")
        }
        {
            $v = "ms","s"
            break
        }

        # Amazon.AppMesh.EgressFilterType
        {
            ($_ -eq "New-AMSHMesh/Spec_EgressFilter_Type") -Or
            ($_ -eq "Update-AMSHMesh/Spec_EgressFilter_Type")
        }
        {
            $v = "ALLOW_ALL","DROP_ALL"
            break
        }

        # Amazon.AppMesh.HttpMethod
        {
            ($_ -eq "New-AMSHRoute/Spec_Http2Route_Match_Method") -Or
            ($_ -eq "Update-AMSHRoute/Spec_Http2Route_Match_Method") -Or
            ($_ -eq "New-AMSHRoute/Spec_HttpRoute_Match_Method") -Or
            ($_ -eq "Update-AMSHRoute/Spec_HttpRoute_Match_Method")
        }
        {
            $v = "CONNECT","DELETE","GET","HEAD","OPTIONS","PATCH","POST","PUT","TRACE"
            break
        }

        # Amazon.AppMesh.HttpScheme
        {
            ($_ -eq "New-AMSHRoute/Spec_Http2Route_Match_Scheme") -Or
            ($_ -eq "Update-AMSHRoute/Spec_Http2Route_Match_Scheme") -Or
            ($_ -eq "New-AMSHRoute/Spec_HttpRoute_Match_Scheme") -Or
            ($_ -eq "Update-AMSHRoute/Spec_HttpRoute_Match_Scheme")
        }
        {
            $v = "http","https"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AMSH_map = @{
    "Spec_EgressFilter_Type"=@("New-AMSHMesh","Update-AMSHMesh")
    "Spec_GrpcRoute_RetryPolicy_PerRetryTimeout_Unit"=@("New-AMSHRoute","Update-AMSHRoute")
    "Spec_Http2Route_Match_Method"=@("New-AMSHRoute","Update-AMSHRoute")
    "Spec_Http2Route_Match_Scheme"=@("New-AMSHRoute","Update-AMSHRoute")
    "Spec_Http2Route_RetryPolicy_PerRetryTimeout_Unit"=@("New-AMSHRoute","Update-AMSHRoute")
    "Spec_HttpRoute_Match_Method"=@("New-AMSHRoute","Update-AMSHRoute")
    "Spec_HttpRoute_Match_Scheme"=@("New-AMSHRoute","Update-AMSHRoute")
    "Spec_HttpRoute_RetryPolicy_PerRetryTimeout_Unit"=@("New-AMSHRoute","Update-AMSHRoute")
}

_awsArgumentCompleterRegistration $AMSH_Completers $AMSH_map

$AMSH_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.AMSH.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AMSH_SelectMap = @{
    "Select"=@("New-AMSHMesh",
               "New-AMSHRoute",
               "New-AMSHVirtualNode",
               "New-AMSHVirtualRouter",
               "New-AMSHVirtualService",
               "Remove-AMSHMesh",
               "Remove-AMSHRoute",
               "Remove-AMSHVirtualNode",
               "Remove-AMSHVirtualRouter",
               "Remove-AMSHVirtualService",
               "Get-AMSHMesh",
               "Get-AMSHRoute",
               "Get-AMSHVirtualNode",
               "Get-AMSHVirtualRouter",
               "Get-AMSHVirtualService",
               "Get-AMSHMeshList",
               "Get-AMSHRouteList",
               "Get-AMSHResourceTag",
               "Get-AMSHVirtualNodeList",
               "Get-AMSHVirtualRouterList",
               "Get-AMSHVirtualServiceList",
               "Add-AMSHResourceTag",
               "Remove-AMSHResourceTag",
               "Update-AMSHMesh",
               "Update-AMSHRoute",
               "Update-AMSHVirtualNode",
               "Update-AMSHVirtualRouter",
               "Update-AMSHVirtualService")
}

_awsArgumentCompleterRegistration $AMSH_SelectCompleters $AMSH_SelectMap
# Argument completions for service Amazon AppStream


$APS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.AppStream.AuthenticationType
        {
            ($_ -eq "Disable-APSUser/AuthenticationType") -Or
            ($_ -eq "Enable-APSUser/AuthenticationType") -Or
            ($_ -eq "Get-APSSessionList/AuthenticationType") -Or
            ($_ -eq "Get-APSUser/AuthenticationType") -Or
            ($_ -eq "Get-APSUserStackAssociation/AuthenticationType") -Or
            ($_ -eq "New-APSUser/AuthenticationType") -Or
            ($_ -eq "Remove-APSUser/AuthenticationType")
        }
        {
            $v = "API","SAML","USERPOOL"
            break
        }

        # Amazon.AppStream.FleetType
        "New-APSFleet/FleetType"
        {
            $v = "ALWAYS_ON","ON_DEMAND"
            break
        }

        # Amazon.AppStream.MessageAction
        "New-APSUser/MessageAction"
        {
            $v = "RESEND","SUPPRESS"
            break
        }

        # Amazon.AppStream.VisibilityType
        "Get-APSImageList/Type"
        {
            $v = "PRIVATE","PUBLIC","SHARED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$APS_map = @{
    "AuthenticationType"=@("Disable-APSUser","Enable-APSUser","Get-APSSessionList","Get-APSUser","Get-APSUserStackAssociation","New-APSUser","Remove-APSUser")
    "FleetType"=@("New-APSFleet")
    "MessageAction"=@("New-APSUser")
    "Type"=@("Get-APSImageList")
}

_awsArgumentCompleterRegistration $APS_Completers $APS_map

$APS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.APS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$APS_SelectMap = @{
    "Select"=@("Register-APSFleet",
               "Register-APSUserStackBatch",
               "Unregister-APSUserStackBatch",
               "Copy-APSImage",
               "New-APSDirectoryConfig",
               "New-APSFleet",
               "New-APSImageBuilder",
               "New-APSImageBuilderStreamingURL",
               "New-APSStack",
               "New-APSStreamingURL",
               "New-APSUsageReportSubscription",
               "New-APSUser",
               "Remove-APSDirectoryConfig",
               "Remove-APSFleet",
               "Remove-APSImage",
               "Remove-APSImageBuilder",
               "Remove-APSImagePermission",
               "Remove-APSStack",
               "Remove-APSUsageReportSubscription",
               "Remove-APSUser",
               "Get-APSDirectoryConfigList",
               "Get-APSFleetList",
               "Get-APSImageBuilderList",
               "Get-APSImagePermission",
               "Get-APSImageList",
               "Get-APSSessionList",
               "Get-APSStackList",
               "Get-APSUsageReportSubscription",
               "Get-APSUser",
               "Get-APSUserStackAssociation",
               "Disable-APSUser",
               "Unregister-APSFleet",
               "Enable-APSUser",
               "Revoke-APSSession",
               "Get-APSAssociatedFleetList",
               "Get-APSAssociatedStackList",
               "Get-APSTagsForResourceList",
               "Start-APSFleet",
               "Start-APSImageBuilder",
               "Stop-APSFleet",
               "Stop-APSImageBuilder",
               "Add-APSResourceTag",
               "Remove-APSResourceTag",
               "Update-APSDirectoryConfig",
               "Update-APSFleet",
               "Update-APSImagePermission",
               "Update-APSStack")
}

_awsArgumentCompleterRegistration $APS_SelectCompleters $APS_SelectMap
# Argument completions for service AWS AppSync


$ASYN_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.AppSync.ApiCacheType
        {
            ($_ -eq "New-ASYNApiCache/Type") -Or
            ($_ -eq "Update-ASYNApiCache/Type")
        }
        {
            $v = "R4_2XLARGE","R4_4XLARGE","R4_8XLARGE","R4_LARGE","R4_XLARGE","T2_MEDIUM","T2_SMALL"
            break
        }

        # Amazon.AppSync.ApiCachingBehavior
        {
            ($_ -eq "New-ASYNApiCache/ApiCachingBehavior") -Or
            ($_ -eq "Update-ASYNApiCache/ApiCachingBehavior")
        }
        {
            $v = "FULL_REQUEST_CACHING","PER_RESOLVER_CACHING"
            break
        }

        # Amazon.AppSync.AuthenticationType
        {
            ($_ -eq "New-ASYNGraphqlApi/AuthenticationType") -Or
            ($_ -eq "Update-ASYNGraphqlApi/AuthenticationType")
        }
        {
            $v = "AMAZON_COGNITO_USER_POOLS","API_KEY","AWS_IAM","OPENID_CONNECT"
            break
        }

        # Amazon.AppSync.ConflictDetectionType
        {
            ($_ -eq "New-ASYNResolver/SyncConfig_ConflictDetection") -Or
            ($_ -eq "Update-ASYNResolver/SyncConfig_ConflictDetection")
        }
        {
            $v = "NONE","VERSION"
            break
        }

        # Amazon.AppSync.ConflictHandlerType
        {
            ($_ -eq "New-ASYNResolver/SyncConfig_ConflictHandler") -Or
            ($_ -eq "Update-ASYNResolver/SyncConfig_ConflictHandler")
        }
        {
            $v = "AUTOMERGE","LAMBDA","NONE","OPTIMISTIC_CONCURRENCY"
            break
        }

        # Amazon.AppSync.DataSourceType
        {
            ($_ -eq "New-ASYNDataSource/Type") -Or
            ($_ -eq "Update-ASYNDataSource/Type")
        }
        {
            $v = "AMAZON_DYNAMODB","AMAZON_ELASTICSEARCH","AWS_LAMBDA","HTTP","NONE","RELATIONAL_DATABASE"
            break
        }

        # Amazon.AppSync.FieldLogLevel
        {
            ($_ -eq "New-ASYNGraphqlApi/LogConfig_FieldLogLevel") -Or
            ($_ -eq "Update-ASYNGraphqlApi/LogConfig_FieldLogLevel")
        }
        {
            $v = "ALL","ERROR","NONE"
            break
        }

        # Amazon.AppSync.OutputType
        "Get-ASYNIntrospectionSchema/Format"
        {
            $v = "JSON","SDL"
            break
        }

        # Amazon.AppSync.RelationalDatabaseSourceType
        {
            ($_ -eq "New-ASYNDataSource/RelationalDatabaseConfig_RelationalDatabaseSourceType") -Or
            ($_ -eq "Update-ASYNDataSource/RelationalDatabaseConfig_RelationalDatabaseSourceType")
        }
        {
            $v = "RDS_HTTP_ENDPOINT"
            break
        }

        # Amazon.AppSync.ResolverKind
        {
            ($_ -eq "New-ASYNResolver/Kind") -Or
            ($_ -eq "Update-ASYNResolver/Kind")
        }
        {
            $v = "PIPELINE","UNIT"
            break
        }

        # Amazon.AppSync.TypeDefinitionFormat
        {
            ($_ -eq "Get-ASYNType/Format") -Or
            ($_ -eq "Get-ASYNTypeList/Format") -Or
            ($_ -eq "New-ASYNType/Format") -Or
            ($_ -eq "Update-ASYNType/Format")
        }
        {
            $v = "JSON","SDL"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ASYN_map = @{
    "ApiCachingBehavior"=@("New-ASYNApiCache","Update-ASYNApiCache")
    "AuthenticationType"=@("New-ASYNGraphqlApi","Update-ASYNGraphqlApi")
    "Format"=@("Get-ASYNIntrospectionSchema","Get-ASYNType","Get-ASYNTypeList","New-ASYNType","Update-ASYNType")
    "Kind"=@("New-ASYNResolver","Update-ASYNResolver")
    "LogConfig_FieldLogLevel"=@("New-ASYNGraphqlApi","Update-ASYNGraphqlApi")
    "RelationalDatabaseConfig_RelationalDatabaseSourceType"=@("New-ASYNDataSource","Update-ASYNDataSource")
    "SyncConfig_ConflictDetection"=@("New-ASYNResolver","Update-ASYNResolver")
    "SyncConfig_ConflictHandler"=@("New-ASYNResolver","Update-ASYNResolver")
    "Type"=@("New-ASYNApiCache","New-ASYNDataSource","Update-ASYNApiCache","Update-ASYNDataSource")
}

_awsArgumentCompleterRegistration $ASYN_Completers $ASYN_map

$ASYN_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ASYN.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ASYN_SelectMap = @{
    "Select"=@("New-ASYNApiCache",
               "New-ASYNApiKey",
               "New-ASYNDataSource",
               "New-ASYNFunction",
               "New-ASYNGraphqlApi",
               "New-ASYNResolver",
               "New-ASYNType",
               "Remove-ASYNApiCache",
               "Remove-ASYNApiKey",
               "Remove-ASYNDataSource",
               "Remove-ASYNFunction",
               "Remove-ASYNGraphqlApi",
               "Remove-ASYNResolver",
               "Remove-ASYNType",
               "Clear-ASYNApiCache",
               "Get-ASYNApiCache",
               "Get-ASYNDataSource",
               "Get-ASYNFunction",
               "Get-ASYNGraphqlApi",
               "Get-ASYNIntrospectionSchema",
               "Get-ASYNResolver",
               "Get-ASYNSchemaCreationStatus",
               "Get-ASYNType",
               "Get-ASYNApiKeyList",
               "Get-ASYNDataSourceList",
               "Get-ASYNFunctionList",
               "Get-ASYNGraphqlApiList",
               "Get-ASYNResolverList",
               "Get-ASYNResolverListByFunction",
               "Get-ASYNResourceTag",
               "Get-ASYNTypeList",
               "Start-ASYNSchemaCreation",
               "Add-ASYNResourceTag",
               "Remove-ASYNResourceTag",
               "Update-ASYNApiCache",
               "Update-ASYNApiKey",
               "Update-ASYNDataSource",
               "Update-ASYNFunction",
               "Update-ASYNGraphqlApi",
               "Update-ASYNResolver",
               "Update-ASYNType")
}

_awsArgumentCompleterRegistration $ASYN_SelectCompleters $ASYN_SelectMap
# Argument completions for service Amazon Athena


$ATH_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Athena.EncryptionOption
        {
            ($_ -eq "New-ATHWorkGroup/Configuration_ResultConfiguration_EncryptionConfiguration_EncryptionOption") -Or
            ($_ -eq "Update-ATHWorkGroup/ConfigurationUpdates_ResultConfigurationUpdates_EncryptionConfiguration_EncryptionOption") -Or
            ($_ -eq "Start-ATHQueryExecution/ResultConfiguration_EncryptionConfiguration_EncryptionOption")
        }
        {
            $v = "CSE_KMS","SSE_KMS","SSE_S3"
            break
        }

        # Amazon.Athena.WorkGroupState
        "Update-ATHWorkGroup/State"
        {
            $v = "DISABLED","ENABLED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ATH_map = @{
    "Configuration_ResultConfiguration_EncryptionConfiguration_EncryptionOption"=@("New-ATHWorkGroup")
    "ConfigurationUpdates_ResultConfigurationUpdates_EncryptionConfiguration_EncryptionOption"=@("Update-ATHWorkGroup")
    "ResultConfiguration_EncryptionConfiguration_EncryptionOption"=@("Start-ATHQueryExecution")
    "State"=@("Update-ATHWorkGroup")
}

_awsArgumentCompleterRegistration $ATH_Completers $ATH_map

$ATH_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ATH.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ATH_SelectMap = @{
    "Select"=@("Get-ATHNamedQueryBatch",
               "Get-ATHQueryExecutionBatch",
               "New-ATHNamedQuery",
               "New-ATHWorkGroup",
               "Remove-ATHNamedQuery",
               "Remove-ATHWorkGroup",
               "Get-ATHNamedQuery",
               "Get-ATHQueryExecution",
               "Get-ATHQueryResult",
               "Get-ATHWorkGroup",
               "Get-ATHNamedQueryList",
               "Get-ATHQueryExecutionList",
               "Get-ATHResourceTag",
               "Get-ATHWorkGroupList",
               "Start-ATHQueryExecution",
               "Stop-ATHQueryExecution",
               "Add-ATHResourceTag",
               "Remove-ATHResourceTag",
               "Update-ATHWorkGroup")
}

_awsArgumentCompleterRegistration $ATH_SelectCompleters $ATH_SelectMap
# Argument completions for service AWS Auto Scaling


$AS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.AutoScaling.MetricStatistic
        "Write-ASScalingPolicy/TargetTrackingConfiguration_CustomizedMetricSpecification_Statistic"
        {
            $v = "Average","Maximum","Minimum","SampleCount","Sum"
            break
        }

        # Amazon.AutoScaling.MetricType
        "Write-ASScalingPolicy/TargetTrackingConfiguration_PredefinedMetricSpecification_PredefinedMetricType"
        {
            $v = "ALBRequestCountPerTarget","ASGAverageCPUUtilization","ASGAverageNetworkIn","ASGAverageNetworkOut"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AS_map = @{
    "TargetTrackingConfiguration_CustomizedMetricSpecification_Statistic"=@("Write-ASScalingPolicy")
    "TargetTrackingConfiguration_PredefinedMetricSpecification_PredefinedMetricType"=@("Write-ASScalingPolicy")
}

_awsArgumentCompleterRegistration $AS_Completers $AS_map

$AS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.AS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$AS_SelectMap = @{
    "Select"=@("Mount-ASInstance",
               "Add-ASLoadBalancer",
               "Add-ASLoadBalancerTargetGroup",
               "Remove-ASScheduledActionBatch",
               "Set-ASScheduledUpdateGroupActionBatch",
               "Complete-ASLifecycleAction",
               "New-ASAutoScalingGroup",
               "New-ASLaunchConfiguration",
               "Set-ASTag",
               "Remove-ASAutoScalingGroup",
               "Remove-ASLaunchConfiguration",
               "Remove-ASLifecycleHook",
               "Remove-ASNotificationConfiguration",
               "Remove-ASPolicy",
               "Remove-ASScheduledAction",
               "Remove-ASTag",
               "Get-ASAccountLimit",
               "Get-ASAdjustmentType",
               "Get-ASAutoScalingGroup",
               "Get-ASAutoScalingInstance",
               "Get-ASAutoScalingNotificationType",
               "Get-ASLaunchConfiguration",
               "Get-ASLifecycleHook",
               "Get-ASLifecycleHookType",
               "Get-ASLoadBalancer",
               "Get-ASLoadBalancerTargetGroup",
               "Get-ASMetricCollectionType",
               "Get-ASNotificationConfiguration",
               "Get-ASPolicy",
               "Get-ASScalingActivity",
               "Get-ASScalingProcessType",
               "Get-ASScheduledAction",
               "Get-ASTag",
               "Get-ASTerminationPolicyType",
               "Dismount-ASInstance",
               "Dismount-ASLoadBalancer",
               "Dismount-ASLoadBalancerTargetGroup",
               "Disable-ASMetricsCollection",
               "Enable-ASMetricsCollection",
               "Enter-ASStandby",
               "Start-ASPolicy",
               "Exit-ASStandby",
               "Write-ASLifecycleHook",
               "Write-ASNotificationConfiguration",
               "Write-ASScalingPolicy",
               "Write-ASScheduledUpdateGroupAction",
               "Write-ASLifecycleActionHeartbeat",
               "Resume-ASProcess",
               "Set-ASDesiredCapacity",
               "Set-ASInstanceHealth",
               "Set-ASInstanceProtection",
               "Suspend-ASProcess",
               "Stop-ASInstanceInAutoScalingGroup",
               "Update-ASAutoScalingGroup")
}

_awsArgumentCompleterRegistration $AS_SelectCompleters $AS_SelectMap
# Argument completions for service AWS Auto Scaling Plans


$ASP_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.AutoScalingPlans.ForecastDataType
        "Get-ASPScalingPlanResourceForecastData/ForecastDataType"
        {
            $v = "CapacityForecast","LoadForecast","ScheduledActionMaxCapacity","ScheduledActionMinCapacity"
            break
        }

        # Amazon.AutoScalingPlans.ScalableDimension
        "Get-ASPScalingPlanResourceForecastData/ScalableDimension"
        {
            $v = "autoscaling:autoScalingGroup:DesiredCapacity","dynamodb:index:ReadCapacityUnits","dynamodb:index:WriteCapacityUnits","dynamodb:table:ReadCapacityUnits","dynamodb:table:WriteCapacityUnits","ec2:spot-fleet-request:TargetCapacity","ecs:service:DesiredCount","rds:cluster:ReadReplicaCount"
            break
        }

        # Amazon.AutoScalingPlans.ServiceNamespace
        "Get-ASPScalingPlanResourceForecastData/ServiceNamespace"
        {
            $v = "autoscaling","dynamodb","ec2","ecs","rds"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ASP_map = @{
    "ForecastDataType"=@("Get-ASPScalingPlanResourceForecastData")
    "ScalableDimension"=@("Get-ASPScalingPlanResourceForecastData")
    "ServiceNamespace"=@("Get-ASPScalingPlanResourceForecastData")
}

_awsArgumentCompleterRegistration $ASP_Completers $ASP_map

$ASP_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ASP.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ASP_SelectMap = @{
    "Select"=@("New-ASPScalingPlan",
               "Remove-ASPScalingPlan",
               "Get-ASPScalingPlanResource",
               "Get-ASPScalingPlan",
               "Get-ASPScalingPlanResourceForecastData",
               "Update-ASPScalingPlan")
}

_awsArgumentCompleterRegistration $ASP_SelectCompleters $ASP_SelectMap
# Argument completions for service AWS Migration Hub


$MH_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.MigrationHub.ApplicationStatus
        "Send-MHApplicationStateNotification/Status"
        {
            $v = "COMPLETED","IN_PROGRESS","NOT_STARTED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MH_map = @{
    "Status"=@("Send-MHApplicationStateNotification")
}

_awsArgumentCompleterRegistration $MH_Completers $MH_map

$MH_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.MH.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MH_SelectMap = @{
    "Select"=@("Add-MHCreatedArtifact",
               "Add-MHDiscoveredResource",
               "New-MHProgressUpdateStream",
               "Remove-MHProgressUpdateStream",
               "Get-MHApplicationState",
               "Get-MHMigrationTask",
               "Remove-MHCreatedArtifact",
               "Remove-MHDiscoveredResource",
               "Import-MHMigrationTask",
               "Get-MHCreatedArtifactList",
               "Get-MHDiscoveredResourceList",
               "Get-MHMigrationTaskList",
               "Get-MHProgressUpdateStream",
               "Send-MHApplicationStateNotification",
               "Send-MHMigrationTaskStateNotification",
               "Set-MHResourceAttribute")
}

_awsArgumentCompleterRegistration $MH_SelectCompleters $MH_SelectMap
# Argument completions for service AWS Backup


$BAK_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Backup.BackupJobState
        "Get-BAKBackupJobList/ByState"
        {
            $v = "ABORTED","ABORTING","COMPLETED","CREATED","EXPIRED","FAILED","PENDING","RUNNING"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$BAK_map = @{
    "ByState"=@("Get-BAKBackupJobList")
}

_awsArgumentCompleterRegistration $BAK_Completers $BAK_map

$BAK_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.BAK.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$BAK_SelectMap = @{
    "Select"=@("New-BAKBackupPlan",
               "New-BAKBackupSelection",
               "New-BAKBackupVault",
               "Remove-BAKBackupPlan",
               "Remove-BAKBackupSelection",
               "Remove-BAKBackupVault",
               "Remove-BAKBackupVaultAccessPolicy",
               "Remove-BAKBackupVaultNotification",
               "Remove-BAKRecoveryPoint",
               "Get-BAKBackupJob",
               "Get-BAKBackupVault",
               "Get-BAKProtectedResource",
               "Get-BAKRecoveryPoint",
               "Get-BAKRestoreJob",
               "Export-BAKBackupPlanTemplate",
               "Get-BAKBackupPlan",
               "Get-BAKBackupPlanFromJSON",
               "Get-BAKBackupPlanFromTemplate",
               "Get-BAKBackupSelection",
               "Get-BAKBackupVaultAccessPolicy",
               "Get-BAKBackupVaultNotification",
               "Get-BAKRecoveryPointRestoreMetadata",
               "Get-BAKSupportedResourceType",
               "Get-BAKBackupJobList",
               "Get-BAKBackupPlanList",
               "Get-BAKBackupPlanTemplateList",
               "Get-BAKBackupPlanVersionList",
               "Get-BAKBackupSelectionList",
               "Get-BAKBackupVaultList",
               "Get-BAKProtectedResourceList",
               "Get-BAKRecoveryPointsByBackupVaultList",
               "Get-BAKRecoveryPointsByResourceList",
               "Get-BAKRestoreJobList",
               "Get-BAKResourceTag",
               "Write-BAKBackupVaultAccessPolicy",
               "Write-BAKBackupVaultNotification",
               "Start-BAKBackupJob",
               "Start-BAKRestoreJob",
               "Stop-BAKBackupJob",
               "Add-BAKResourceTag",
               "Remove-BAKResourceTag",
               "Update-BAKBackupPlan",
               "Update-BAKRecoveryPointLifecycle")
}

_awsArgumentCompleterRegistration $BAK_SelectCompleters $BAK_SelectMap
# Argument completions for service AWS Batch


$BAT_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Batch.CEState
        {
            ($_ -eq "New-BATComputeEnvironment/State") -Or
            ($_ -eq "Update-BATComputeEnvironment/State")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.Batch.CEType
        "New-BATComputeEnvironment/Type"
        {
            $v = "MANAGED","UNMANAGED"
            break
        }

        # Amazon.Batch.CRAllocationStrategy
        "New-BATComputeEnvironment/ComputeResources_AllocationStrategy"
        {
            $v = "BEST_FIT","BEST_FIT_PROGRESSIVE","SPOT_CAPACITY_OPTIMIZED"
            break
        }

        # Amazon.Batch.CRType
        "New-BATComputeEnvironment/ComputeResources_Type"
        {
            $v = "EC2","SPOT"
            break
        }

        # Amazon.Batch.JobDefinitionType
        "Register-BATJobDefinition/Type"
        {
            $v = "container","multinode"
            break
        }

        # Amazon.Batch.JobStatus
        "Get-BATJobList/JobStatus"
        {
            $v = "FAILED","PENDING","RUNNABLE","RUNNING","STARTING","SUBMITTED","SUCCEEDED"
            break
        }

        # Amazon.Batch.JQState
        {
            ($_ -eq "New-BATJobQueue/State") -Or
            ($_ -eq "Update-BATJobQueue/State")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$BAT_map = @{
    "ComputeResources_AllocationStrategy"=@("New-BATComputeEnvironment")
    "ComputeResources_Type"=@("New-BATComputeEnvironment")
    "JobStatus"=@("Get-BATJobList")
    "State"=@("New-BATComputeEnvironment","New-BATJobQueue","Update-BATComputeEnvironment","Update-BATJobQueue")
    "Type"=@("New-BATComputeEnvironment","Register-BATJobDefinition")
}

_awsArgumentCompleterRegistration $BAT_Completers $BAT_map

$BAT_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.BAT.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$BAT_SelectMap = @{
    "Select"=@("Stop-BATJob",
               "New-BATComputeEnvironment",
               "New-BATJobQueue",
               "Remove-BATComputeEnvironment",
               "Remove-BATJobQueue",
               "Unregister-BATJobDefinition",
               "Get-BATComputeEnvironment",
               "Get-BATJobDefinition",
               "Get-BATJobQueue",
               "Get-BATJobDetail",
               "Get-BATJobList",
               "Register-BATJobDefinition",
               "Submit-BATJob",
               "Remove-BATJob",
               "Update-BATComputeEnvironment",
               "Update-BATJobQueue")
}

_awsArgumentCompleterRegistration $BAT_SelectCompleters $BAT_SelectMap
# Argument completions for service AWS Budgets


$BGT_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Budgets.BudgetType
        {
            ($_ -eq "New-BGTBudget/Budget_BudgetType") -Or
            ($_ -eq "Update-BGTBudget/NewBudget_BudgetType")
        }
        {
            $v = "COST","RI_COVERAGE","RI_UTILIZATION","SAVINGS_PLANS_COVERAGE","SAVINGS_PLANS_UTILIZATION","USAGE"
            break
        }

        # Amazon.Budgets.ComparisonOperator
        {
            ($_ -eq "Update-BGTNotification/NewNotification_ComparisonOperator") -Or
            ($_ -eq "Get-BGTSubscribersForNotification/Notification_ComparisonOperator") -Or
            ($_ -eq "New-BGTNotification/Notification_ComparisonOperator") -Or
            ($_ -eq "New-BGTSubscriber/Notification_ComparisonOperator") -Or
            ($_ -eq "Remove-BGTNotification/Notification_ComparisonOperator") -Or
            ($_ -eq "Remove-BGTSubscriber/Notification_ComparisonOperator") -Or
            ($_ -eq "Update-BGTSubscriber/Notification_ComparisonOperator") -Or
            ($_ -eq "Update-BGTNotification/OldNotification_ComparisonOperator")
        }
        {
            $v = "EQUAL_TO","GREATER_THAN","LESS_THAN"
            break
        }

        # Amazon.Budgets.NotificationState
        {
            ($_ -eq "Update-BGTNotification/NewNotification_NotificationState") -Or
            ($_ -eq "Get-BGTSubscribersForNotification/Notification_NotificationState") -Or
            ($_ -eq "New-BGTNotification/Notification_NotificationState") -Or
            ($_ -eq "New-BGTSubscriber/Notification_NotificationState") -Or
            ($_ -eq "Remove-BGTNotification/Notification_NotificationState") -Or
            ($_ -eq "Remove-BGTSubscriber/Notification_NotificationState") -Or
            ($_ -eq "Update-BGTSubscriber/Notification_NotificationState") -Or
            ($_ -eq "Update-BGTNotification/OldNotification_NotificationState")
        }
        {
            $v = "ALARM","OK"
            break
        }

        # Amazon.Budgets.NotificationType
        {
            ($_ -eq "Update-BGTNotification/NewNotification_NotificationType") -Or
            ($_ -eq "Get-BGTSubscribersForNotification/Notification_NotificationType") -Or
            ($_ -eq "New-BGTNotification/Notification_NotificationType") -Or
            ($_ -eq "New-BGTSubscriber/Notification_NotificationType") -Or
            ($_ -eq "Remove-BGTNotification/Notification_NotificationType") -Or
            ($_ -eq "Remove-BGTSubscriber/Notification_NotificationType") -Or
            ($_ -eq "Update-BGTSubscriber/Notification_NotificationType") -Or
            ($_ -eq "Update-BGTNotification/OldNotification_NotificationType")
        }
        {
            $v = "ACTUAL","FORECASTED"
            break
        }

        # Amazon.Budgets.SubscriptionType
        {
            ($_ -eq "Update-BGTSubscriber/NewSubscriber_SubscriptionType") -Or
            ($_ -eq "Update-BGTSubscriber/OldSubscriber_SubscriptionType") -Or
            ($_ -eq "New-BGTSubscriber/Subscriber_SubscriptionType") -Or
            ($_ -eq "Remove-BGTSubscriber/Subscriber_SubscriptionType")
        }
        {
            $v = "EMAIL","SNS"
            break
        }

        # Amazon.Budgets.ThresholdType
        {
            ($_ -eq "Update-BGTNotification/NewNotification_ThresholdType") -Or
            ($_ -eq "Get-BGTSubscribersForNotification/Notification_ThresholdType") -Or
            ($_ -eq "New-BGTNotification/Notification_ThresholdType") -Or
            ($_ -eq "New-BGTSubscriber/Notification_ThresholdType") -Or
            ($_ -eq "Remove-BGTNotification/Notification_ThresholdType") -Or
            ($_ -eq "Remove-BGTSubscriber/Notification_ThresholdType") -Or
            ($_ -eq "Update-BGTSubscriber/Notification_ThresholdType") -Or
            ($_ -eq "Update-BGTNotification/OldNotification_ThresholdType")
        }
        {
            $v = "ABSOLUTE_VALUE","PERCENTAGE"
            break
        }

        # Amazon.Budgets.TimeUnit
        {
            ($_ -eq "New-BGTBudget/Budget_TimeUnit") -Or
            ($_ -eq "Update-BGTBudget/NewBudget_TimeUnit")
        }
        {
            $v = "ANNUALLY","DAILY","MONTHLY","QUARTERLY"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$BGT_map = @{
    "Budget_BudgetType"=@("New-BGTBudget")
    "Budget_TimeUnit"=@("New-BGTBudget")
    "NewBudget_BudgetType"=@("Update-BGTBudget")
    "NewBudget_TimeUnit"=@("Update-BGTBudget")
    "NewNotification_ComparisonOperator"=@("Update-BGTNotification")
    "NewNotification_NotificationState"=@("Update-BGTNotification")
    "NewNotification_NotificationType"=@("Update-BGTNotification")
    "NewNotification_ThresholdType"=@("Update-BGTNotification")
    "NewSubscriber_SubscriptionType"=@("Update-BGTSubscriber")
    "Notification_ComparisonOperator"=@("Get-BGTSubscribersForNotification","New-BGTNotification","New-BGTSubscriber","Remove-BGTNotification","Remove-BGTSubscriber","Update-BGTSubscriber")
    "Notification_NotificationState"=@("Get-BGTSubscribersForNotification","New-BGTNotification","New-BGTSubscriber","Remove-BGTNotification","Remove-BGTSubscriber","Update-BGTSubscriber")
    "Notification_NotificationType"=@("Get-BGTSubscribersForNotification","New-BGTNotification","New-BGTSubscriber","Remove-BGTNotification","Remove-BGTSubscriber","Update-BGTSubscriber")
    "Notification_ThresholdType"=@("Get-BGTSubscribersForNotification","New-BGTNotification","New-BGTSubscriber","Remove-BGTNotification","Remove-BGTSubscriber","Update-BGTSubscriber")
    "OldNotification_ComparisonOperator"=@("Update-BGTNotification")
    "OldNotification_NotificationState"=@("Update-BGTNotification")
    "OldNotification_NotificationType"=@("Update-BGTNotification")
    "OldNotification_ThresholdType"=@("Update-BGTNotification")
    "OldSubscriber_SubscriptionType"=@("Update-BGTSubscriber")
    "Subscriber_SubscriptionType"=@("New-BGTSubscriber","Remove-BGTSubscriber")
}

_awsArgumentCompleterRegistration $BGT_Completers $BGT_map

$BGT_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.BGT.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$BGT_SelectMap = @{
    "Select"=@("New-BGTBudget",
               "New-BGTNotification",
               "New-BGTSubscriber",
               "Remove-BGTBudget",
               "Remove-BGTNotification",
               "Remove-BGTSubscriber",
               "Get-BGTBudget",
               "Get-BGTBudgetPerformanceHistory",
               "Get-BGTBudgetList",
               "Get-BGTNotificationsForBudget",
               "Get-BGTSubscribersForNotification",
               "Update-BGTBudget",
               "Update-BGTNotification",
               "Update-BGTSubscriber")
}

_awsArgumentCompleterRegistration $BGT_SelectCompleters $BGT_SelectMap
# Argument completions for service AWS Cost Explorer


$CE_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CostExplorer.AccountScope
        "Get-CEReservationPurchaseRecommendation/AccountScope"
        {
            $v = "LINKED","PAYER"
            break
        }

        # Amazon.CostExplorer.Context
        "Get-CEDimensionValue/Context"
        {
            $v = "COST_AND_USAGE","RESERVATIONS","SAVINGS_PLANS"
            break
        }

        # Amazon.CostExplorer.CostCategoryRuleVersion
        {
            ($_ -eq "New-CECostCategoryDefinition/RuleVersion") -Or
            ($_ -eq "Update-CECostCategoryDefinition/RuleVersion")
        }
        {
            $v = "CostCategoryExpression.v1"
            break
        }

        # Amazon.CostExplorer.Dimension
        "Get-CEDimensionValue/Dimension"
        {
            $v = "AZ","BILLING_ENTITY","CACHE_ENGINE","DATABASE_ENGINE","DEPLOYMENT_OPTION","INSTANCE_TYPE","INSTANCE_TYPE_FAMILY","LEGAL_ENTITY_NAME","LINKED_ACCOUNT","OPERATING_SYSTEM","OPERATION","PAYMENT_OPTION","PLATFORM","PURCHASE_TYPE","RECORD_TYPE","REGION","RESERVATION_ID","RESOURCE_ID","RIGHTSIZING_TYPE","SAVINGS_PLANS_TYPE","SAVINGS_PLAN_ARN","SCOPE","SERVICE","SUBSCRIPTION_ID","TENANCY","USAGE_TYPE","USAGE_TYPE_GROUP"
            break
        }

        # Amazon.CostExplorer.Granularity
        {
            ($_ -eq "Get-CECostAndUsage/Granularity") -Or
            ($_ -eq "Get-CECostAndUsageWithResource/Granularity") -Or
            ($_ -eq "Get-CECostForecast/Granularity") -Or
            ($_ -eq "Get-CEReservationCoverage/Granularity") -Or
            ($_ -eq "Get-CEReservationUtilization/Granularity") -Or
            ($_ -eq "Get-CESavingsPlansCoverage/Granularity") -Or
            ($_ -eq "Get-CESavingsPlansUtilization/Granularity") -Or
            ($_ -eq "Get-CEUsageForecast/Granularity")
        }
        {
            $v = "DAILY","HOURLY","MONTHLY"
            break
        }

        # Amazon.CostExplorer.LookbackPeriodInDays
        {
            ($_ -eq "Get-CEReservationPurchaseRecommendation/LookbackPeriodInDays") -Or
            ($_ -eq "Get-CESavingsPlansPurchaseRecommendation/LookbackPeriodInDays")
        }
        {
            $v = "SEVEN_DAYS","SIXTY_DAYS","THIRTY_DAYS"
            break
        }

        # Amazon.CostExplorer.Metric
        {
            ($_ -eq "Get-CECostForecast/Metric") -Or
            ($_ -eq "Get-CEUsageForecast/Metric")
        }
        {
            $v = "AMORTIZED_COST","BLENDED_COST","NET_AMORTIZED_COST","NET_UNBLENDED_COST","NORMALIZED_USAGE_AMOUNT","UNBLENDED_COST","USAGE_QUANTITY"
            break
        }

        # Amazon.CostExplorer.OfferingClass
        "Get-CEReservationPurchaseRecommendation/ServiceSpecification_EC2Specification_OfferingClass"
        {
            $v = "CONVERTIBLE","STANDARD"
            break
        }

        # Amazon.CostExplorer.PaymentOption
        {
            ($_ -eq "Get-CEReservationPurchaseRecommendation/PaymentOption") -Or
            ($_ -eq "Get-CESavingsPlansPurchaseRecommendation/PaymentOption")
        }
        {
            $v = "ALL_UPFRONT","HEAVY_UTILIZATION","LIGHT_UTILIZATION","MEDIUM_UTILIZATION","NO_UPFRONT","PARTIAL_UPFRONT"
            break
        }

        # Amazon.CostExplorer.SupportedSavingsPlansType
        "Get-CESavingsPlansPurchaseRecommendation/SavingsPlansType"
        {
            $v = "COMPUTE_SP","EC2_INSTANCE_SP"
            break
        }

        # Amazon.CostExplorer.TermInYears
        {
            ($_ -eq "Get-CEReservationPurchaseRecommendation/TermInYears") -Or
            ($_ -eq "Get-CESavingsPlansPurchaseRecommendation/TermInYears")
        }
        {
            $v = "ONE_YEAR","THREE_YEARS"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CE_map = @{
    "AccountScope"=@("Get-CEReservationPurchaseRecommendation")
    "Context"=@("Get-CEDimensionValue")
    "Dimension"=@("Get-CEDimensionValue")
    "Granularity"=@("Get-CECostAndUsage","Get-CECostAndUsageWithResource","Get-CECostForecast","Get-CEReservationCoverage","Get-CEReservationUtilization","Get-CESavingsPlansCoverage","Get-CESavingsPlansUtilization","Get-CEUsageForecast")
    "LookbackPeriodInDays"=@("Get-CEReservationPurchaseRecommendation","Get-CESavingsPlansPurchaseRecommendation")
    "Metric"=@("Get-CECostForecast","Get-CEUsageForecast")
    "PaymentOption"=@("Get-CEReservationPurchaseRecommendation","Get-CESavingsPlansPurchaseRecommendation")
    "RuleVersion"=@("New-CECostCategoryDefinition","Update-CECostCategoryDefinition")
    "SavingsPlansType"=@("Get-CESavingsPlansPurchaseRecommendation")
    "ServiceSpecification_EC2Specification_OfferingClass"=@("Get-CEReservationPurchaseRecommendation")
    "TermInYears"=@("Get-CEReservationPurchaseRecommendation","Get-CESavingsPlansPurchaseRecommendation")
}

_awsArgumentCompleterRegistration $CE_Completers $CE_map

$CE_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CE.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CE_SelectMap = @{
    "Select"=@("New-CECostCategoryDefinition",
               "Remove-CECostCategoryDefinition",
               "Get-CECostCategoryDefinition",
               "Get-CECostAndUsage",
               "Get-CECostAndUsageWithResource",
               "Get-CECostForecast",
               "Get-CEDimensionValue",
               "Get-CEReservationCoverage",
               "Get-CEReservationPurchaseRecommendation",
               "Get-CEReservationUtilization",
               "Get-CERightsizingRecommendation",
               "Get-CESavingsPlansCoverage",
               "Get-CESavingsPlansPurchaseRecommendation",
               "Get-CESavingsPlansUtilization",
               "Get-CESavingsPlansUtilizationDetail",
               "Get-CETag",
               "Get-CEUsageForecast",
               "Get-CECostCategoryDefinitionList",
               "Update-CECostCategoryDefinition")
}

_awsArgumentCompleterRegistration $CE_SelectCompleters $CE_SelectMap
# Argument completions for service Amazon Chime


$CHM_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Chime.License
        "Update-CHMUser/LicenseType"
        {
            $v = "Basic","Plus","Pro","ProTrial"
            break
        }

        # Amazon.Chime.PhoneNumberAssociationName
        "Get-CHMPhoneNumberList/FilterName"
        {
            $v = "AccountId","UserId","VoiceConnectorGroupId","VoiceConnectorId"
            break
        }

        # Amazon.Chime.PhoneNumberProductType
        {
            ($_ -eq "Get-CHMPhoneNumberList/ProductType") -Or
            ($_ -eq "New-CHMPhoneNumberOrder/ProductType") -Or
            ($_ -eq "Update-CHMPhoneNumber/ProductType")
        }
        {
            $v = "BusinessCalling","VoiceConnector"
            break
        }

        # Amazon.Chime.PhoneNumberStatus
        "Get-CHMPhoneNumberList/Status"
        {
            $v = "AcquireFailed","AcquireInProgress","Assigned","DeleteFailed","DeleteInProgress","ReleaseFailed","ReleaseInProgress","Unassigned"
            break
        }

        # Amazon.Chime.RoomMembershipRole
        {
            ($_ -eq "New-CHMRoomMembership/Role") -Or
            ($_ -eq "Update-CHMRoomMembership/Role")
        }
        {
            $v = "Administrator","Member"
            break
        }

        # Amazon.Chime.VoiceConnectorAwsRegion
        "New-CHMVoiceConnector/AwsRegion"
        {
            $v = "us-east-1","us-west-2"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CHM_map = @{
    "AwsRegion"=@("New-CHMVoiceConnector")
    "FilterName"=@("Get-CHMPhoneNumberList")
    "LicenseType"=@("Update-CHMUser")
    "ProductType"=@("Get-CHMPhoneNumberList","New-CHMPhoneNumberOrder","Update-CHMPhoneNumber")
    "Role"=@("New-CHMRoomMembership","Update-CHMRoomMembership")
    "Status"=@("Get-CHMPhoneNumberList")
}

_awsArgumentCompleterRegistration $CHM_Completers $CHM_map

$CHM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CHM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CHM_SelectMap = @{
    "Select"=@("Add-CHMPhoneNumbersToVoiceConnector",
               "Add-CHMPhoneNumbersToVoiceConnectorGroup",
               "Add-CHMPhoneNumberToUser",
               "New-CHMAttendeeBatch",
               "New-CHMRoomMembershipBatch",
               "Remove-CHMPhoneNumberBatch",
               "Enable-CHMUserSuspensionBatch",
               "Disable-CHMUserSuspensionBatch",
               "Update-CHMPhoneNumberBatch",
               "Update-CHMUserBatch",
               "New-CHMAccount",
               "New-CHMAttendee",
               "New-CHMBot",
               "New-CHMMeeting",
               "New-CHMPhoneNumberOrder",
               "New-CHMRoom",
               "New-CHMRoomMembership",
               "New-CHMVoiceConnector",
               "New-CHMVoiceConnectorGroup",
               "Remove-CHMAccount",
               "Remove-CHMAttendee",
               "Remove-CHMEventsConfiguration",
               "Remove-CHMMeeting",
               "Remove-CHMPhoneNumber",
               "Remove-CHMRoom",
               "Remove-CHMRoomMembership",
               "Remove-CHMVoiceConnector",
               "Remove-CHMVoiceConnectorGroup",
               "Remove-CHMVoiceConnectorOrigination",
               "Remove-CHMVoiceConnectorStreamingConfiguration",
               "Remove-CHMVoiceConnectorTermination",
               "Remove-CHMVoiceConnectorTerminationCredential",
               "Remove-CHMPhoneNumberFromUser",
               "Remove-CHMPhoneNumbersFromVoiceConnector",
               "Remove-CHMPhoneNumbersFromVoiceConnectorGroup",
               "Get-CHMAccount",
               "Get-CHMAccountSetting",
               "Get-CHMAttendee",
               "Get-CHMBot",
               "Get-CHMEventsConfiguration",
               "Get-CHMGlobalSetting",
               "Get-CHMMeeting",
               "Get-CHMPhoneNumber",
               "Get-CHMPhoneNumberOrder",
               "Get-CHMPhoneNumberSetting",
               "Get-CHMRoom",
               "Get-CHMUser",
               "Get-CHMUserSetting",
               "Get-CHMVoiceConnector",
               "Get-CHMVoiceConnectorGroup",
               "Get-CHMVoiceConnectorLoggingConfiguration",
               "Get-CHMVoiceConnectorOrigination",
               "Get-CHMVoiceConnectorStreamingConfiguration",
               "Get-CHMVoiceConnectorTermination",
               "Get-CHMVoiceConnectorTerminationHealth",
               "Send-CHMUserInvitation",
               "Get-CHMAccountList",
               "Get-CHMAttendeeList",
               "Get-CHMBotList",
               "Get-CHMMeetingList",
               "Get-CHMPhoneNumberOrderList",
               "Get-CHMPhoneNumberList",
               "Get-CHMRoomMembershipList",
               "Get-CHMRoomList",
               "Get-CHMUserList",
               "Get-CHMVoiceConnectorGroupList",
               "Get-CHMVoiceConnectorList",
               "Get-CHMVoiceConnectorTerminationCredentialList",
               "Invoke-CHMUserLogout",
               "Write-CHMEventsConfiguration",
               "Write-CHMVoiceConnectorLoggingConfiguration",
               "Write-CHMVoiceConnectorOrigination",
               "Write-CHMVoiceConnectorStreamingConfiguration",
               "Write-CHMVoiceConnectorTermination",
               "Write-CHMVoiceConnectorTerminationCredential",
               "Update-CHMSecurityToken",
               "Reset-CHMPersonalPIN",
               "Restore-CHMPhoneNumber",
               "Search-CHMAvailablePhoneNumber",
               "Update-CHMAccount",
               "Update-CHMAccountSetting",
               "Update-CHMBot",
               "Update-CHMGlobalSetting",
               "Update-CHMPhoneNumber",
               "Update-CHMPhoneNumberSetting",
               "Update-CHMRoom",
               "Update-CHMRoomMembership",
               "Update-CHMUser",
               "Update-CHMUserSetting",
               "Update-CHMVoiceConnector",
               "Update-CHMVoiceConnectorGroup")
}

_awsArgumentCompleterRegistration $CHM_SelectCompleters $CHM_SelectMap
# Argument completions for service AWS Cloud9


$C9_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Cloud9.MemberPermissions
        {
            ($_ -eq "New-C9EnvironmentMembership/Permissions") -Or
            ($_ -eq "Update-C9EnvironmentMembership/Permissions")
        }
        {
            $v = "read-only","read-write"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$C9_map = @{
    "Permissions"=@("New-C9EnvironmentMembership","Update-C9EnvironmentMembership")
}

_awsArgumentCompleterRegistration $C9_Completers $C9_map

$C9_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.C9.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$C9_SelectMap = @{
    "Select"=@("New-C9EnvironmentEC2",
               "New-C9EnvironmentMembership",
               "Remove-C9Environment",
               "Remove-C9EnvironmentMembership",
               "Get-C9EnvironmentMembershipList",
               "Get-C9EnvironmentData",
               "Get-C9EnvironmentStatus",
               "Get-C9EnvironmentList",
               "Update-C9Environment",
               "Update-C9EnvironmentMembership")
}

_awsArgumentCompleterRegistration $C9_SelectCompleters $C9_SelectMap
# Argument completions for service Amazon Cloud Directory


$CDIR_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CloudDirectory.ConsistencyLevel
        {
            ($_ -eq "Get-CDIRIncomingTypedLink/ConsistencyLevel") -Or
            ($_ -eq "Get-CDIRIndex/ConsistencyLevel") -Or
            ($_ -eq "Get-CDIRLinkAttribute/ConsistencyLevel") -Or
            ($_ -eq "Get-CDIRObjectAttribute/ConsistencyLevel") -Or
            ($_ -eq "Get-CDIRObjectAttributeList/ConsistencyLevel") -Or
            ($_ -eq "Get-CDIRObjectChild/ConsistencyLevel") -Or
            ($_ -eq "Get-CDIRObjectIndex/ConsistencyLevel") -Or
            ($_ -eq "Get-CDIRObjectInformation/ConsistencyLevel") -Or
            ($_ -eq "Get-CDIRObjectParent/ConsistencyLevel") -Or
            ($_ -eq "Get-CDIRObjectPolicy/ConsistencyLevel") -Or
            ($_ -eq "Get-CDIROutgoingTypedLink/ConsistencyLevel") -Or
            ($_ -eq "Get-CDIRPolicyAttachment/ConsistencyLevel") -Or
            ($_ -eq "Read-CDIRDirectoryBatch/ConsistencyLevel")
        }
        {
            $v = "EVENTUAL","SERIALIZABLE"
            break
        }

        # Amazon.CloudDirectory.DirectoryState
        "Get-CDIRDirectory/State"
        {
            $v = "DELETED","DISABLED","ENABLED"
            break
        }

        # Amazon.CloudDirectory.FacetStyle
        "New-CDIRFacet/FacetStyle"
        {
            $v = "DYNAMIC","STATIC"
            break
        }

        # Amazon.CloudDirectory.ObjectType
        {
            ($_ -eq "New-CDIRFacet/ObjectType") -Or
            ($_ -eq "Update-CDIRFacet/ObjectType")
        }
        {
            $v = "INDEX","LEAF_NODE","NODE","POLICY"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CDIR_map = @{
    "ConsistencyLevel"=@("Get-CDIRIncomingTypedLink","Get-CDIRIndex","Get-CDIRLinkAttribute","Get-CDIRObjectAttribute","Get-CDIRObjectAttributeList","Get-CDIRObjectChild","Get-CDIRObjectIndex","Get-CDIRObjectInformation","Get-CDIRObjectParent","Get-CDIRObjectPolicy","Get-CDIROutgoingTypedLink","Get-CDIRPolicyAttachment","Read-CDIRDirectoryBatch")
    "FacetStyle"=@("New-CDIRFacet")
    "ObjectType"=@("New-CDIRFacet","Update-CDIRFacet")
    "State"=@("Get-CDIRDirectory")
}

_awsArgumentCompleterRegistration $CDIR_Completers $CDIR_map

$CDIR_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CDIR.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CDIR_SelectMap = @{
    "Select"=@("Add-CDIRFacetToObject",
               "Add-CDIRSchema",
               "Connect-CDIRObject",
               "Mount-CDIRPolicy",
               "Mount-CDIRObjectToIndex",
               "Mount-CDIRTypedLink",
               "Read-CDIRDirectoryBatch",
               "Write-CDIRDirectoryBatch",
               "New-CDIRDirectory",
               "New-CDIRFacet",
               "New-CDIRIndex",
               "New-CDIRDirectoryObject",
               "New-CDIRSchema",
               "New-CDIRTypedLinkFacet",
               "Remove-CDIRDirectory",
               "Remove-CDIRFacet",
               "Remove-CDIRDirectoryObject",
               "Remove-CDIRSchema",
               "Remove-CDIRTypedLinkFacet",
               "Dismount-CDIRObjectFromIndex",
               "Disconnect-CDIRObject",
               "Dismount-CDIRPolicyFromObject",
               "Dismount-CDIRTypedLink",
               "Disable-CDIRDirectory",
               "Enable-CDIRDirectory",
               "Get-CDIRAppliedSchemaVersion",
               "Get-CDIRDirectoryMetadata",
               "Get-CDIRFacet",
               "Get-CDIRLinkAttribute",
               "Get-CDIRObjectAttribute",
               "Get-CDIRObjectInformation",
               "Get-CDIRSchemaAsJson",
               "Get-CDIRTypedLinkFacetInformation",
               "Get-CDIRAppliedSchemaArn",
               "Get-CDIRObjectIndex",
               "Get-CDIRDevelopmentSchemaArn",
               "Get-CDIRDirectory",
               "Get-CDIRFacetAttribute",
               "Get-CDIRFacetName",
               "Get-CDIRIncomingTypedLink",
               "Get-CDIRIndex",
               "Get-CDIRManagedSchemaArn",
               "Get-CDIRObjectAttributeList",
               "Get-CDIRObjectChild",
               "Get-CDIRObjectParentPath",
               "Get-CDIRObjectParent",
               "Get-CDIRObjectPolicy",
               "Get-CDIROutgoingTypedLink",
               "Get-CDIRPolicyAttachment",
               "Get-CDIRPublishedSchemaArn",
               "Get-CDIRResourceTag",
               "Get-CDIRTypedLinkFacetAttribute",
               "Get-CDIRTypedLinkFacetName",
               "Get-CDIRDirectoryPolicy",
               "Publish-CDIRSchema",
               "Write-CDIRSchemaFromJson",
               "Remove-CDIRFacetFromObject",
               "Add-CDIRResourceTag",
               "Remove-CDIRResourceTag",
               "Update-CDIRFacet",
               "Update-CDIRLinkAttribute",
               "Update-CDIRObjectAttribute",
               "Update-CDIRSchema",
               "Update-CDIRTypedLinkFacet",
               "Update-CDIRAppliedSchema",
               "Update-CDIRPublishedSchema")
}

_awsArgumentCompleterRegistration $CDIR_SelectCompleters $CDIR_SelectMap
# Argument completions for service AWS CloudFormation


$CFN_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CloudFormation.ChangeSetType
        "New-CFNChangeSet/ChangeSetType"
        {
            $v = "CREATE","IMPORT","UPDATE"
            break
        }

        # Amazon.CloudFormation.DeprecatedStatus
        {
            ($_ -eq "Get-CFNTypeList/DeprecatedStatus") -Or
            ($_ -eq "Get-CFNTypeVersion/DeprecatedStatus")
        }
        {
            $v = "DEPRECATED","LIVE"
            break
        }

        # Amazon.CloudFormation.HandlerErrorCode
        "Write-CFNHandlerProgress/ErrorCode"
        {
            $v = "AccessDenied","AlreadyExists","GeneralServiceException","InternalFailure","InvalidCredentials","InvalidRequest","NetworkFailure","NotFound","NotStabilized","NotUpdatable","ResourceConflict","ServiceInternalError","ServiceLimitExceeded","Throttling"
            break
        }

        # Amazon.CloudFormation.OnFailure
        "New-CFNStack/OnFailure"
        {
            $v = "DELETE","DO_NOTHING","ROLLBACK"
            break
        }

        # Amazon.CloudFormation.OperationStatus
        {
            ($_ -eq "Write-CFNHandlerProgress/CurrentOperationStatus") -Or
            ($_ -eq "Write-CFNHandlerProgress/OperationStatus")
        }
        {
            $v = "FAILED","IN_PROGRESS","PENDING","SUCCESS"
            break
        }

        # Amazon.CloudFormation.ProvisioningType
        "Get-CFNTypeList/ProvisioningType"
        {
            $v = "FULLY_MUTABLE","IMMUTABLE","NON_PROVISIONABLE"
            break
        }

        # Amazon.CloudFormation.RegistrationStatus
        "Get-CFNTypeRegistrationList/RegistrationStatusFilter"
        {
            $v = "COMPLETE","FAILED","IN_PROGRESS"
            break
        }

        # Amazon.CloudFormation.RegistryType
        {
            ($_ -eq "Get-CFNType/Type") -Or
            ($_ -eq "Get-CFNTypeRegistrationList/Type") -Or
            ($_ -eq "Get-CFNTypeVersion/Type") -Or
            ($_ -eq "Register-CFNType/Type") -Or
            ($_ -eq "Set-CFNTypeDefaultVersion/Type") -Or
            ($_ -eq "Unregister-CFNType/Type")
        }
        {
            $v = "RESOURCE"
            break
        }

        # Amazon.CloudFormation.ResourceSignalStatus
        "Send-CFNResourceSignal/Status"
        {
            $v = "FAILURE","SUCCESS"
            break
        }

        # Amazon.CloudFormation.StackSetStatus
        "Get-CFNStackSetList/Status"
        {
            $v = "ACTIVE","DELETED"
            break
        }

        # Amazon.CloudFormation.StackStatus
        {
            ($_ -eq "Test-CFNStack/Status") -Or
            ($_ -eq "Wait-CFNStack/Status")
        }
        {
            $v = "CREATE_COMPLETE","CREATE_FAILED","CREATE_IN_PROGRESS","DELETE_COMPLETE","DELETE_FAILED","DELETE_IN_PROGRESS","IMPORT_COMPLETE","IMPORT_IN_PROGRESS","IMPORT_ROLLBACK_COMPLETE","IMPORT_ROLLBACK_FAILED","IMPORT_ROLLBACK_IN_PROGRESS","REVIEW_IN_PROGRESS","ROLLBACK_COMPLETE","ROLLBACK_FAILED","ROLLBACK_IN_PROGRESS","UPDATE_COMPLETE","UPDATE_COMPLETE_CLEANUP_IN_PROGRESS","UPDATE_IN_PROGRESS","UPDATE_ROLLBACK_COMPLETE","UPDATE_ROLLBACK_COMPLETE_CLEANUP_IN_PROGRESS","UPDATE_ROLLBACK_FAILED","UPDATE_ROLLBACK_IN_PROGRESS"
            break
        }

        # Amazon.CloudFormation.TemplateStage
        "Get-CFNTemplate/TemplateStage"
        {
            $v = "Original","Processed"
            break
        }

        # Amazon.CloudFormation.Visibility
        "Get-CFNTypeList/Visibility"
        {
            $v = "PRIVATE","PUBLIC"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CFN_map = @{
    "ChangeSetType"=@("New-CFNChangeSet")
    "CurrentOperationStatus"=@("Write-CFNHandlerProgress")
    "DeprecatedStatus"=@("Get-CFNTypeList","Get-CFNTypeVersion")
    "ErrorCode"=@("Write-CFNHandlerProgress")
    "OnFailure"=@("New-CFNStack")
    "OperationStatus"=@("Write-CFNHandlerProgress")
    "ProvisioningType"=@("Get-CFNTypeList")
    "RegistrationStatusFilter"=@("Get-CFNTypeRegistrationList")
    "Status"=@("Get-CFNStackSetList","Send-CFNResourceSignal","Test-CFNStack","Wait-CFNStack")
    "TemplateStage"=@("Get-CFNTemplate")
    "Type"=@("Get-CFNType","Get-CFNTypeRegistrationList","Get-CFNTypeVersion","Register-CFNType","Set-CFNTypeDefaultVersion","Unregister-CFNType")
    "Visibility"=@("Get-CFNTypeList")
}

_awsArgumentCompleterRegistration $CFN_Completers $CFN_map

$CFN_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CFN.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CFN_SelectMap = @{
    "Select"=@("Stop-CFNUpdateStack",
               "Resume-CFNUpdateRollback",
               "New-CFNChangeSet",
               "New-CFNStack",
               "New-CFNStackInstance",
               "New-CFNStackSet",
               "Remove-CFNChangeSet",
               "Remove-CFNStack",
               "Remove-CFNStackInstance",
               "Remove-CFNStackSet",
               "Unregister-CFNType",
               "Get-CFNAccountLimit",
               "Get-CFNChangeSet",
               "Get-CFNStackDriftDetectionStatus",
               "Get-CFNStackEvent",
               "Get-CFNStackInstance",
               "Get-CFNStackResource",
               "Get-CFNDetectedStackResourceDrift",
               "Get-CFNStackResourceList",
               "Get-CFNStack",
               "Get-CFNStackSet",
               "Get-CFNStackSetOperation",
               "Get-CFNType",
               "Get-CFNTypeRegistration",
               "Start-CFNStackDriftDetection",
               "Get-CFNStackResourceDrift",
               "Start-CFNStackSetDriftDetection",
               "Measure-CFNTemplateCost",
               "Start-CFNChangeSet",
               "Get-CFNStackPolicy",
               "Get-CFNTemplate",
               "Get-CFNTemplateSummary",
               "Get-CFNChangeSetList",
               "Get-CFNExport",
               "Get-CFNImportList",
               "Get-CFNStackInstanceList",
               "Get-CFNStackResourceSummary",
               "Get-CFNStackSummary",
               "Get-CFNStackSetOperationResultList",
               "Get-CFNStackSetOperationList",
               "Get-CFNStackSetList",
               "Get-CFNTypeRegistrationList",
               "Get-CFNTypeList",
               "Get-CFNTypeVersion",
               "Write-CFNHandlerProgress",
               "Register-CFNType",
               "Set-CFNStackPolicy",
               "Set-CFNTypeDefaultVersion",
               "Send-CFNResourceSignal",
               "Stop-CFNStackSetOperation",
               "Update-CFNStack",
               "Update-CFNStackInstance",
               "Update-CFNStackSet",
               "Update-CFNTerminationProtection",
               "Test-CFNTemplate",
               "Test-CFNStack",
               "Wait-CFNStack")
}

_awsArgumentCompleterRegistration $CFN_SelectCompleters $CFN_SelectMap
# Argument completions for service Amazon CloudFront


$CF_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CloudFront.CertificateSource
        {
            ($_ -eq "New-CFDistribution/DistributionConfig_ViewerCertificate_CertificateSource") -Or
            ($_ -eq "Update-CFDistribution/DistributionConfig_ViewerCertificate_CertificateSource") -Or
            ($_ -eq "New-CFDistributionWithTag/DistributionConfigWithTags_DistributionConfig_ViewerCertificate_CertificateSource")
        }
        {
            $v = "acm","cloudfront","iam"
            break
        }

        # Amazon.CloudFront.GeoRestrictionType
        {
            ($_ -eq "New-CFDistribution/DistributionConfig_Restrictions_GeoRestriction_RestrictionType") -Or
            ($_ -eq "Update-CFDistribution/DistributionConfig_Restrictions_GeoRestriction_RestrictionType") -Or
            ($_ -eq "New-CFDistributionWithTag/DistributionConfigWithTags_DistributionConfig_Restrictions_GeoRestriction_RestrictionType")
        }
        {
            $v = "blacklist","none","whitelist"
            break
        }

        # Amazon.CloudFront.HttpVersion
        {
            ($_ -eq "New-CFDistribution/DistributionConfig_HttpVersion") -Or
            ($_ -eq "Update-CFDistribution/DistributionConfig_HttpVersion") -Or
            ($_ -eq "New-CFDistributionWithTag/DistributionConfigWithTags_DistributionConfig_HttpVersion")
        }
        {
            $v = "http1.1","http2"
            break
        }

        # Amazon.CloudFront.ItemSelection
        {
            ($_ -eq "New-CFDistribution/DistributionConfig_DefaultCacheBehavior_ForwardedValues_Cookies_Forward") -Or
            ($_ -eq "Update-CFDistribution/DistributionConfig_DefaultCacheBehavior_ForwardedValues_Cookies_Forward") -Or
            ($_ -eq "New-CFDistributionWithTag/DistributionConfigWithTags_DistributionConfig_DefaultCacheBehavior_ForwardedValues_Cookies_Forward")
        }
        {
            $v = "all","none","whitelist"
            break
        }

        # Amazon.CloudFront.MinimumProtocolVersion
        {
            ($_ -eq "New-CFDistribution/DistributionConfig_ViewerCertificate_MinimumProtocolVersion") -Or
            ($_ -eq "Update-CFDistribution/DistributionConfig_ViewerCertificate_MinimumProtocolVersion") -Or
            ($_ -eq "New-CFDistributionWithTag/DistributionConfigWithTags_DistributionConfig_ViewerCertificate_MinimumProtocolVersion")
        }
        {
            $v = "SSLv3","TLSv1","TLSv1.1_2016","TLSv1.2_2018","TLSv1_2016"
            break
        }

        # Amazon.CloudFront.PriceClass
        {
            ($_ -eq "New-CFDistribution/DistributionConfig_PriceClass") -Or
            ($_ -eq "Update-CFDistribution/DistributionConfig_PriceClass") -Or
            ($_ -eq "New-CFDistributionWithTag/DistributionConfigWithTags_DistributionConfig_PriceClass") -Or
            ($_ -eq "New-CFStreamingDistribution/StreamingDistributionConfig_PriceClass") -Or
            ($_ -eq "Update-CFStreamingDistribution/StreamingDistributionConfig_PriceClass") -Or
            ($_ -eq "New-CFStreamingDistributionWithTag/StreamingDistributionConfigWithTags_StreamingDistributionConfig_PriceClass")
        }
        {
            $v = "PriceClass_100","PriceClass_200","PriceClass_All"
            break
        }

        # Amazon.CloudFront.SSLSupportMethod
        {
            ($_ -eq "New-CFDistribution/DistributionConfig_ViewerCertificate_SSLSupportMethod") -Or
            ($_ -eq "Update-CFDistribution/DistributionConfig_ViewerCertificate_SSLSupportMethod") -Or
            ($_ -eq "New-CFDistributionWithTag/DistributionConfigWithTags_DistributionConfig_ViewerCertificate_SSLSupportMethod")
        }
        {
            $v = "sni-only","vip"
            break
        }

        # Amazon.CloudFront.ViewerProtocolPolicy
        {
            ($_ -eq "New-CFDistribution/DistributionConfig_DefaultCacheBehavior_ViewerProtocolPolicy") -Or
            ($_ -eq "Update-CFDistribution/DistributionConfig_DefaultCacheBehavior_ViewerProtocolPolicy") -Or
            ($_ -eq "New-CFDistributionWithTag/DistributionConfigWithTags_DistributionConfig_DefaultCacheBehavior_ViewerProtocolPolicy")
        }
        {
            $v = "allow-all","https-only","redirect-to-https"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CF_map = @{
    "DistributionConfig_DefaultCacheBehavior_ForwardedValues_Cookies_Forward"=@("New-CFDistribution","Update-CFDistribution")
    "DistributionConfig_DefaultCacheBehavior_ViewerProtocolPolicy"=@("New-CFDistribution","Update-CFDistribution")
    "DistributionConfig_HttpVersion"=@("New-CFDistribution","Update-CFDistribution")
    "DistributionConfig_PriceClass"=@("New-CFDistribution","Update-CFDistribution")
    "DistributionConfig_Restrictions_GeoRestriction_RestrictionType"=@("New-CFDistribution","Update-CFDistribution")
    "DistributionConfig_ViewerCertificate_CertificateSource"=@("New-CFDistribution","Update-CFDistribution")
    "DistributionConfig_ViewerCertificate_MinimumProtocolVersion"=@("New-CFDistribution","Update-CFDistribution")
    "DistributionConfig_ViewerCertificate_SSLSupportMethod"=@("New-CFDistribution","Update-CFDistribution")
    "DistributionConfigWithTags_DistributionConfig_DefaultCacheBehavior_ForwardedValues_Cookies_Forward"=@("New-CFDistributionWithTag")
    "DistributionConfigWithTags_DistributionConfig_DefaultCacheBehavior_ViewerProtocolPolicy"=@("New-CFDistributionWithTag")
    "DistributionConfigWithTags_DistributionConfig_HttpVersion"=@("New-CFDistributionWithTag")
    "DistributionConfigWithTags_DistributionConfig_PriceClass"=@("New-CFDistributionWithTag")
    "DistributionConfigWithTags_DistributionConfig_Restrictions_GeoRestriction_RestrictionType"=@("New-CFDistributionWithTag")
    "DistributionConfigWithTags_DistributionConfig_ViewerCertificate_CertificateSource"=@("New-CFDistributionWithTag")
    "DistributionConfigWithTags_DistributionConfig_ViewerCertificate_MinimumProtocolVersion"=@("New-CFDistributionWithTag")
    "DistributionConfigWithTags_DistributionConfig_ViewerCertificate_SSLSupportMethod"=@("New-CFDistributionWithTag")
    "StreamingDistributionConfig_PriceClass"=@("New-CFStreamingDistribution","Update-CFStreamingDistribution")
    "StreamingDistributionConfigWithTags_StreamingDistributionConfig_PriceClass"=@("New-CFStreamingDistributionWithTag")
}

_awsArgumentCompleterRegistration $CF_Completers $CF_map

$CF_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CF.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CF_SelectMap = @{
    "Select"=@("New-CFCloudFrontOriginAccessIdentity",
               "New-CFDistribution",
               "New-CFDistributionWithTag",
               "New-CFFieldLevelEncryptionConfig",
               "New-CFFieldLevelEncryptionProfile",
               "New-CFInvalidation",
               "New-CFPublicKey",
               "New-CFStreamingDistribution",
               "New-CFStreamingDistributionWithTag",
               "Remove-CFCloudFrontOriginAccessIdentity",
               "Remove-CFDistribution",
               "Remove-CFFieldLevelEncryptionConfig",
               "Remove-CFFieldLevelEncryptionProfile",
               "Remove-CFPublicKey",
               "Remove-CFStreamingDistribution",
               "Get-CFCloudFrontOriginAccessIdentity",
               "Get-CFCloudFrontOriginAccessIdentityConfig",
               "Get-CFDistribution",
               "Get-CFDistributionConfig",
               "Get-CFFieldLevelEncryption",
               "Get-CFFieldLevelEncryptionConfig",
               "Get-CFFieldLevelEncryptionProfile",
               "Get-CFFieldLevelEncryptionProfileConfig",
               "Get-CFInvalidation",
               "Get-CFPublicKey",
               "Get-CFPublicKeyConfig",
               "Get-CFStreamingDistribution",
               "Get-CFStreamingDistributionConfig",
               "Get-CFCloudFrontOriginAccessIdentityList",
               "Get-CFDistributionList",
               "Get-CFDistributionListByWebACLId",
               "Get-CFFieldLevelEncryptionConfigList",
               "Get-CFFieldLevelEncryptionProfileList",
               "Get-CFInvalidationList",
               "Get-CFPublicKeyList",
               "Get-CFStreamingDistributionList",
               "Get-CFResourceTag",
               "Add-CFResourceTag",
               "Remove-CFResourceTag",
               "Update-CFCloudFrontOriginAccessIdentity",
               "Update-CFDistribution",
               "Update-CFFieldLevelEncryptionConfig",
               "Update-CFFieldLevelEncryptionProfile",
               "Update-CFPublicKey",
               "Update-CFStreamingDistribution",
               "New-CFSignedCookie",
               "New-CFSignedUrl")
}

_awsArgumentCompleterRegistration $CF_SelectCompleters $CF_SelectMap
# Argument completions for service AWS CloudHSM


$HSM_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CloudHSM.ClientVersion
        "Get-HSMConfig/ClientVersion"
        {
            $v = "5.1","5.3"
            break
        }

        # Amazon.CloudHSM.SubscriptionType
        "New-HSMItem/SubscriptionType"
        {
            $v = "PRODUCTION"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$HSM_map = @{
    "ClientVersion"=@("Get-HSMConfig")
    "SubscriptionType"=@("New-HSMItem")
}

_awsArgumentCompleterRegistration $HSM_Completers $HSM_map

$HSM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.HSM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$HSM_SelectMap = @{
    "Select"=@("Set-HSMResourceTag",
               "New-HSMPartitionGroup",
               "New-HSMItem",
               "New-HSMLunaClient",
               "Remove-HSMPartitionGroup",
               "Remove-HSMItem",
               "Remove-HSMLunaClient",
               "Get-HSMPartitionGroup",
               "Get-HSMItem",
               "Get-HSMLunaClient",
               "Get-HSMConfig",
               "Get-HSMAvailableZone",
               "Get-HSMPartitionGroupList",
               "Get-HSMItemList",
               "Get-HSMLunaClientList",
               "Get-HSMResourceTag",
               "Edit-HSMPartitionGroup",
               "Edit-HSMItem",
               "Edit-HSMLunaClient",
               "Remove-HSMResourceTag")
}

_awsArgumentCompleterRegistration $HSM_SelectCompleters $HSM_SelectMap
# Argument completions for service AWS CloudHSM V2


$HSM2_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.HSM2.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$HSM2_SelectMap = @{
    "Select"=@("Copy-HSM2BackupToRegion",
               "New-HSM2Cluster",
               "New-HSM2Hsm",
               "Remove-HSM2Backup",
               "Remove-HSM2Cluster",
               "Remove-HSM2Hsm",
               "Get-HSM2Backup",
               "Get-HSM2Cluster",
               "Initialize-HSM2Cluster",
               "Get-HSM2ResourceTag",
               "Restore-HSM2Backup",
               "Add-HSM2ResourceTag",
               "Remove-HSM2ResourceTag")
}

_awsArgumentCompleterRegistration $HSM2_SelectCompleters $HSM2_SelectMap
# Argument completions for service Amazon CloudSearch


$CS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CloudSearch.AlgorithmicStemming
        "Set-CSAnalysisScheme/AnalysisScheme_AnalysisOptions_AlgorithmicStemming"
        {
            $v = "full","light","minimal","none"
            break
        }

        # Amazon.CloudSearch.AnalysisSchemeLanguage
        "Set-CSAnalysisScheme/AnalysisScheme_AnalysisSchemeLanguage"
        {
            $v = "ar","bg","ca","cs","da","de","el","en","es","eu","fa","fi","fr","ga","gl","he","hi","hu","hy","id","it","ja","ko","lv","mul","nl","no","pt","ro","ru","sv","th","tr","zh-Hans","zh-Hant"
            break
        }

        # Amazon.CloudSearch.IndexFieldType
        "Set-CSIndexField/IndexField_IndexFieldType"
        {
            $v = "date","date-array","double","double-array","int","int-array","latlon","literal","literal-array","text","text-array"
            break
        }

        # Amazon.CloudSearch.PartitionInstanceType
        "Update-CSScalingParameter/ScalingParameters_DesiredInstanceType"
        {
            $v = "search.m1.large","search.m1.small","search.m2.2xlarge","search.m2.xlarge","search.m3.2xlarge","search.m3.large","search.m3.medium","search.m3.xlarge"
            break
        }

        # Amazon.CloudSearch.SuggesterFuzzyMatching
        "Set-CSSuggester/Suggester_DocumentSuggesterOptions_FuzzyMatching"
        {
            $v = "high","low","none"
            break
        }

        # Amazon.CloudSearch.TLSSecurityPolicy
        "Update-CSDomainEndpointOption/DomainEndpointOptions_TLSSecurityPolicy"
        {
            $v = "Policy-Min-TLS-1-0-2019-07","Policy-Min-TLS-1-2-2019-07"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CS_map = @{
    "AnalysisScheme_AnalysisOptions_AlgorithmicStemming"=@("Set-CSAnalysisScheme")
    "AnalysisScheme_AnalysisSchemeLanguage"=@("Set-CSAnalysisScheme")
    "DomainEndpointOptions_TLSSecurityPolicy"=@("Update-CSDomainEndpointOption")
    "IndexField_IndexFieldType"=@("Set-CSIndexField")
    "ScalingParameters_DesiredInstanceType"=@("Update-CSScalingParameter")
    "Suggester_DocumentSuggesterOptions_FuzzyMatching"=@("Set-CSSuggester")
}

_awsArgumentCompleterRegistration $CS_Completers $CS_map

$CS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CS_SelectMap = @{
    "Select"=@("Start-CSSuggestersBuild",
               "New-CSDomain",
               "Set-CSAnalysisScheme",
               "Set-CSExpression",
               "Set-CSIndexField",
               "Set-CSSuggester",
               "Remove-CSAnalysisScheme",
               "Remove-CSDomain",
               "Remove-CSExpression",
               "Remove-CSIndexField",
               "Remove-CSSuggester",
               "Get-CSAnalysisScheme",
               "Get-CSAvailabilityOption",
               "Get-CSDomainEndpointOption",
               "Get-CSDomain",
               "Get-CSExpression",
               "Get-CSIndexField",
               "Get-CSScalingParameter",
               "Get-CSServiceAccessPolicy",
               "Get-CSSuggester",
               "Start-CSIndex",
               "Get-CSDomainNameList",
               "Update-CSAvailabilityOption",
               "Update-CSDomainEndpointOption",
               "Update-CSScalingParameter",
               "Update-CSServiceAccessPolicy")
}

_awsArgumentCompleterRegistration $CS_SelectCompleters $CS_SelectMap
# Argument completions for service Amazon CloudSearch Domain


$CSD_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CloudSearchDomain.ContentType
        "Write-CSDDocument/ContentType"
        {
            $v = "application/json","application/xml"
            break
        }

        # Amazon.CloudSearchDomain.QueryParser
        "Search-CSDDocument/QueryParser"
        {
            $v = "dismax","lucene","simple","structured"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CSD_map = @{
    "ContentType"=@("Write-CSDDocument")
    "QueryParser"=@("Search-CSDDocument")
}

_awsArgumentCompleterRegistration $CSD_Completers $CSD_map

$CSD_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CSD.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CSD_SelectMap = @{
    "Select"=@("Get-CSDSuggestion",
               "Search-CSDDocument",
               "Write-CSDDocument")
}

_awsArgumentCompleterRegistration $CSD_SelectCompleters $CSD_SelectMap
# Argument completions for service AWS CloudTrail


$CT_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CloudTrail.EventCategory
        "Find-CTEvent/EventCategory"
        {
            $v = "insight"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CT_map = @{
    "EventCategory"=@("Find-CTEvent")
}

_awsArgumentCompleterRegistration $CT_Completers $CT_map

$CT_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CT.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CT_SelectMap = @{
    "Select"=@("Add-CTResourceTag",
               "New-CTTrail",
               "Remove-CTTrail",
               "Get-CTTrail",
               "Get-CTEventSelector",
               "Get-CTInsightSelector",
               "Get-CTTrailByName",
               "Get-CTTrailStatus",
               "Get-CTPublicKey",
               "Get-CTResourceTag",
               "Get-CTTrailSummary",
               "Find-CTEvent",
               "Write-CTEventSelector",
               "Write-CTInsightSelector",
               "Remove-CTResourceTag",
               "Start-CTLogging",
               "Stop-CTLogging",
               "Update-CTTrail")
}

_awsArgumentCompleterRegistration $CT_SelectCompleters $CT_SelectMap
# Argument completions for service AWS CodeBuild


$CB_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CodeBuild.ArtifactNamespace
        {
            ($_ -eq "New-CBProject/Artifacts_NamespaceType") -Or
            ($_ -eq "Update-CBProject/Artifacts_NamespaceType") -Or
            ($_ -eq "Start-CBBuild/ArtifactsOverride_NamespaceType")
        }
        {
            $v = "BUILD_ID","NONE"
            break
        }

        # Amazon.CodeBuild.ArtifactPackaging
        {
            ($_ -eq "New-CBProject/Artifacts_Packaging") -Or
            ($_ -eq "Update-CBProject/Artifacts_Packaging") -Or
            ($_ -eq "Start-CBBuild/ArtifactsOverride_Packaging")
        }
        {
            $v = "NONE","ZIP"
            break
        }

        # Amazon.CodeBuild.ArtifactsType
        {
            ($_ -eq "New-CBProject/Artifacts_Type") -Or
            ($_ -eq "Update-CBProject/Artifacts_Type") -Or
            ($_ -eq "Start-CBBuild/ArtifactsOverride_Type")
        }
        {
            $v = "CODEPIPELINE","NO_ARTIFACTS","S3"
            break
        }

        # Amazon.CodeBuild.AuthType
        "Import-CBSourceCredential/AuthType"
        {
            $v = "BASIC_AUTH","OAUTH","PERSONAL_ACCESS_TOKEN"
            break
        }

        # Amazon.CodeBuild.CacheType
        {
            ($_ -eq "New-CBProject/Cache_Type") -Or
            ($_ -eq "Update-CBProject/Cache_Type") -Or
            ($_ -eq "Start-CBBuild/CacheOverride_Type")
        }
        {
            $v = "LOCAL","NO_CACHE","S3"
            break
        }

        # Amazon.CodeBuild.ComputeType
        {
            ($_ -eq "Start-CBBuild/ComputeTypeOverride") -Or
            ($_ -eq "New-CBProject/Environment_ComputeType") -Or
            ($_ -eq "Update-CBProject/Environment_ComputeType")
        }
        {
            $v = "BUILD_GENERAL1_2XLARGE","BUILD_GENERAL1_LARGE","BUILD_GENERAL1_MEDIUM","BUILD_GENERAL1_SMALL"
            break
        }

        # Amazon.CodeBuild.CredentialProviderType
        {
            ($_ -eq "New-CBProject/Environment_RegistryCredential_CredentialProvider") -Or
            ($_ -eq "Update-CBProject/Environment_RegistryCredential_CredentialProvider") -Or
            ($_ -eq "Start-CBBuild/RegistryCredentialOverride_CredentialProvider")
        }
        {
            $v = "SECRETS_MANAGER"
            break
        }

        # Amazon.CodeBuild.EnvironmentType
        {
            ($_ -eq "New-CBProject/Environment_Type") -Or
            ($_ -eq "Update-CBProject/Environment_Type") -Or
            ($_ -eq "Start-CBBuild/EnvironmentTypeOverride")
        }
        {
            $v = "ARM_CONTAINER","LINUX_CONTAINER","LINUX_GPU_CONTAINER","WINDOWS_CONTAINER"
            break
        }

        # Amazon.CodeBuild.ImagePullCredentialsType
        {
            ($_ -eq "New-CBProject/Environment_ImagePullCredentialsType") -Or
            ($_ -eq "Update-CBProject/Environment_ImagePullCredentialsType") -Or
            ($_ -eq "Start-CBBuild/ImagePullCredentialsTypeOverride")
        }
        {
            $v = "CODEBUILD","SERVICE_ROLE"
            break
        }

        # Amazon.CodeBuild.LogsConfigStatusType
        {
            ($_ -eq "New-CBProject/LogsConfig_CloudWatchLogs_Status") -Or
            ($_ -eq "Update-CBProject/LogsConfig_CloudWatchLogs_Status") -Or
            ($_ -eq "New-CBProject/LogsConfig_S3Logs_Status") -Or
            ($_ -eq "Update-CBProject/LogsConfig_S3Logs_Status") -Or
            ($_ -eq "Start-CBBuild/LogsConfigOverride_CloudWatchLogs_Status") -Or
            ($_ -eq "Start-CBBuild/LogsConfigOverride_S3Logs_Status")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.CodeBuild.ProjectSortByType
        "Get-CBProjectList/SortBy"
        {
            $v = "CREATED_TIME","LAST_MODIFIED_TIME","NAME"
            break
        }

        # Amazon.CodeBuild.ReportExportConfigType
        {
            ($_ -eq "New-CBReportGroup/ExportConfig_ExportConfigType") -Or
            ($_ -eq "Update-CBReportGroup/ExportConfig_ExportConfigType")
        }
        {
            $v = "NO_EXPORT","S3"
            break
        }

        # Amazon.CodeBuild.ReportGroupSortByType
        "Get-CBReportGroupList/SortBy"
        {
            $v = "CREATED_TIME","LAST_MODIFIED_TIME","NAME"
            break
        }

        # Amazon.CodeBuild.ReportPackagingType
        {
            ($_ -eq "New-CBReportGroup/ExportConfig_S3Destination_Packaging") -Or
            ($_ -eq "Update-CBReportGroup/ExportConfig_S3Destination_Packaging")
        }
        {
            $v = "NONE","ZIP"
            break
        }

        # Amazon.CodeBuild.ReportStatusType
        {
            ($_ -eq "Get-CBReportList/Filter_Status") -Or
            ($_ -eq "Get-CBReportsForReportGroupList/Filter_Status")
        }
        {
            $v = "DELETING","FAILED","GENERATING","INCOMPLETE","SUCCEEDED"
            break
        }

        # Amazon.CodeBuild.ReportType
        "New-CBReportGroup/Type"
        {
            $v = "TEST"
            break
        }

        # Amazon.CodeBuild.ServerType
        "Import-CBSourceCredential/ServerType"
        {
            $v = "BITBUCKET","GITHUB","GITHUB_ENTERPRISE"
            break
        }

        # Amazon.CodeBuild.SortOrderType
        {
            ($_ -eq "Get-CBBuildIdList/SortOrder") -Or
            ($_ -eq "Get-CBBuildIdListForProject/SortOrder") -Or
            ($_ -eq "Get-CBProjectList/SortOrder") -Or
            ($_ -eq "Get-CBReportGroupList/SortOrder") -Or
            ($_ -eq "Get-CBReportList/SortOrder") -Or
            ($_ -eq "Get-CBReportsForReportGroupList/SortOrder")
        }
        {
            $v = "ASCENDING","DESCENDING"
            break
        }

        # Amazon.CodeBuild.SourceAuthType
        {
            ($_ -eq "New-CBProject/Source_Auth_Type") -Or
            ($_ -eq "Update-CBProject/Source_Auth_Type") -Or
            ($_ -eq "Start-CBBuild/SourceAuthOverride_Type")
        }
        {
            $v = "OAUTH"
            break
        }

        # Amazon.CodeBuild.SourceType
        {
            ($_ -eq "New-CBProject/Source_Type") -Or
            ($_ -eq "Update-CBProject/Source_Type") -Or
            ($_ -eq "Start-CBBuild/SourceTypeOverride")
        }
        {
            $v = "BITBUCKET","CODECOMMIT","CODEPIPELINE","GITHUB","GITHUB_ENTERPRISE","NO_SOURCE","S3"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CB_map = @{
    "Artifacts_NamespaceType"=@("New-CBProject","Update-CBProject")
    "Artifacts_Packaging"=@("New-CBProject","Update-CBProject")
    "Artifacts_Type"=@("New-CBProject","Update-CBProject")
    "ArtifactsOverride_NamespaceType"=@("Start-CBBuild")
    "ArtifactsOverride_Packaging"=@("Start-CBBuild")
    "ArtifactsOverride_Type"=@("Start-CBBuild")
    "AuthType"=@("Import-CBSourceCredential")
    "Cache_Type"=@("New-CBProject","Update-CBProject")
    "CacheOverride_Type"=@("Start-CBBuild")
    "ComputeTypeOverride"=@("Start-CBBuild")
    "Environment_ComputeType"=@("New-CBProject","Update-CBProject")
    "Environment_ImagePullCredentialsType"=@("New-CBProject","Update-CBProject")
    "Environment_RegistryCredential_CredentialProvider"=@("New-CBProject","Update-CBProject")
    "Environment_Type"=@("New-CBProject","Update-CBProject")
    "EnvironmentTypeOverride"=@("Start-CBBuild")
    "ExportConfig_ExportConfigType"=@("New-CBReportGroup","Update-CBReportGroup")
    "ExportConfig_S3Destination_Packaging"=@("New-CBReportGroup","Update-CBReportGroup")
    "Filter_Status"=@("Get-CBReportList","Get-CBReportsForReportGroupList")
    "ImagePullCredentialsTypeOverride"=@("Start-CBBuild")
    "LogsConfig_CloudWatchLogs_Status"=@("New-CBProject","Update-CBProject")
    "LogsConfig_S3Logs_Status"=@("New-CBProject","Update-CBProject")
    "LogsConfigOverride_CloudWatchLogs_Status"=@("Start-CBBuild")
    "LogsConfigOverride_S3Logs_Status"=@("Start-CBBuild")
    "RegistryCredentialOverride_CredentialProvider"=@("Start-CBBuild")
    "ServerType"=@("Import-CBSourceCredential")
    "SortBy"=@("Get-CBProjectList","Get-CBReportGroupList")
    "SortOrder"=@("Get-CBBuildIdList","Get-CBBuildIdListForProject","Get-CBProjectList","Get-CBReportGroupList","Get-CBReportList","Get-CBReportsForReportGroupList")
    "Source_Auth_Type"=@("New-CBProject","Update-CBProject")
    "Source_Type"=@("New-CBProject","Update-CBProject")
    "SourceAuthOverride_Type"=@("Start-CBBuild")
    "SourceTypeOverride"=@("Start-CBBuild")
    "Type"=@("New-CBReportGroup")
}

_awsArgumentCompleterRegistration $CB_Completers $CB_map

$CB_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CB.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CB_SelectMap = @{
    "Select"=@("Remove-CBBuildBatch",
               "Get-CBBuildBatch",
               "Get-CBProjectBatch",
               "Get-CBReportGroupBatch",
               "Get-CBReportBatch",
               "New-CBProject",
               "New-CBReportGroup",
               "New-CBWebhook",
               "Remove-CBProject",
               "Remove-CBReport",
               "Remove-CBReportGroup",
               "Remove-CBSourceCredential",
               "Remove-CBWebhook",
               "Get-CBTestCase",
               "Import-CBSourceCredential",
               "Reset-CBProjectCache",
               "Get-CBBuildIdList",
               "Get-CBBuildIdListForProject",
               "Get-CBCuratedEnvironmentImageList",
               "Get-CBProjectList",
               "Get-CBReportGroupList",
               "Get-CBReportList",
               "Get-CBReportsForReportGroupList",
               "Get-CBSourceCredentialList",
               "Start-CBBuild",
               "Stop-CBBuild",
               "Update-CBProject",
               "Update-CBReportGroup",
               "Update-CBWebhook")
}

_awsArgumentCompleterRegistration $CB_SelectCompleters $CB_SelectMap
# Argument completions for service AWS CodeCommit


$CC_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CodeCommit.ApprovalState
        "Update-CCPullRequestApprovalState/ApprovalState"
        {
            $v = "APPROVE","REVOKE"
            break
        }

        # Amazon.CodeCommit.ConflictDetailLevelTypeEnum
        {
            ($_ -eq "Get-CCFileMergeConflict/ConflictDetailLevel") -Or
            ($_ -eq "Get-CCFileMergeConflictBatch/ConflictDetailLevel") -Or
            ($_ -eq "Get-CCMergeCommit/ConflictDetailLevel") -Or
            ($_ -eq "Get-CCMergeConflict/ConflictDetailLevel") -Or
            ($_ -eq "Get-CCMergeOption/ConflictDetailLevel") -Or
            ($_ -eq "Merge-CCBranchesBySquash/ConflictDetailLevel") -Or
            ($_ -eq "Merge-CCBranchesByThreeWay/ConflictDetailLevel") -Or
            ($_ -eq "Merge-CCPullRequestBySquash/ConflictDetailLevel") -Or
            ($_ -eq "Merge-CCPullRequestByThreeWay/ConflictDetailLevel") -Or
            ($_ -eq "New-CCUnreferencedMergeCommit/ConflictDetailLevel")
        }
        {
            $v = "FILE_LEVEL","LINE_LEVEL"
            break
        }

        # Amazon.CodeCommit.ConflictResolutionStrategyTypeEnum
        {
            ($_ -eq "Get-CCFileMergeConflict/ConflictResolutionStrategy") -Or
            ($_ -eq "Get-CCFileMergeConflictBatch/ConflictResolutionStrategy") -Or
            ($_ -eq "Get-CCMergeCommit/ConflictResolutionStrategy") -Or
            ($_ -eq "Get-CCMergeConflict/ConflictResolutionStrategy") -Or
            ($_ -eq "Get-CCMergeOption/ConflictResolutionStrategy") -Or
            ($_ -eq "Merge-CCBranchesBySquash/ConflictResolutionStrategy") -Or
            ($_ -eq "Merge-CCBranchesByThreeWay/ConflictResolutionStrategy") -Or
            ($_ -eq "Merge-CCPullRequestBySquash/ConflictResolutionStrategy") -Or
            ($_ -eq "Merge-CCPullRequestByThreeWay/ConflictResolutionStrategy") -Or
            ($_ -eq "New-CCUnreferencedMergeCommit/ConflictResolutionStrategy")
        }
        {
            $v = "ACCEPT_DESTINATION","ACCEPT_SOURCE","AUTOMERGE","NONE"
            break
        }

        # Amazon.CodeCommit.FileModeTypeEnum
        "Write-CCFile/FileMode"
        {
            $v = "EXECUTABLE","NORMAL","SYMLINK"
            break
        }

        # Amazon.CodeCommit.MergeOptionTypeEnum
        {
            ($_ -eq "Get-CCFileMergeConflict/MergeOption") -Or
            ($_ -eq "Get-CCFileMergeConflictBatch/MergeOption") -Or
            ($_ -eq "Get-CCMergeConflict/MergeOption") -Or
            ($_ -eq "New-CCUnreferencedMergeCommit/MergeOption")
        }
        {
            $v = "FAST_FORWARD_MERGE","SQUASH_MERGE","THREE_WAY_MERGE"
            break
        }

        # Amazon.CodeCommit.OrderEnum
        "Get-CCRepositoryList/Order"
        {
            $v = "ascending","descending"
            break
        }

        # Amazon.CodeCommit.OverrideStatus
        "Skip-CCPullRequestApprovalRule/OverrideStatus"
        {
            $v = "OVERRIDE","REVOKE"
            break
        }

        # Amazon.CodeCommit.PullRequestEventType
        "Get-CCPullRequestEvent/PullRequestEventType"
        {
            $v = "PULL_REQUEST_APPROVAL_RULE_CREATED","PULL_REQUEST_APPROVAL_RULE_DELETED","PULL_REQUEST_APPROVAL_RULE_OVERRIDDEN","PULL_REQUEST_APPROVAL_RULE_UPDATED","PULL_REQUEST_APPROVAL_STATE_CHANGED","PULL_REQUEST_CREATED","PULL_REQUEST_MERGE_STATE_CHANGED","PULL_REQUEST_SOURCE_REFERENCE_UPDATED","PULL_REQUEST_STATUS_CHANGED"
            break
        }

        # Amazon.CodeCommit.PullRequestStatusEnum
        {
            ($_ -eq "Get-CCPullRequestList/PullRequestStatus") -Or
            ($_ -eq "Update-CCPullRequestStatus/PullRequestStatus")
        }
        {
            $v = "CLOSED","OPEN"
            break
        }

        # Amazon.CodeCommit.RelativeFileVersionEnum
        {
            ($_ -eq "Send-CCCommentForComparedCommit/Location_RelativeFileVersion") -Or
            ($_ -eq "Send-CCCommentForPullRequest/Location_RelativeFileVersion")
        }
        {
            $v = "AFTER","BEFORE"
            break
        }

        # Amazon.CodeCommit.SortByEnum
        "Get-CCRepositoryList/SortBy"
        {
            $v = "lastModifiedDate","repositoryName"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CC_map = @{
    "ApprovalState"=@("Update-CCPullRequestApprovalState")
    "ConflictDetailLevel"=@("Get-CCFileMergeConflict","Get-CCFileMergeConflictBatch","Get-CCMergeCommit","Get-CCMergeConflict","Get-CCMergeOption","Merge-CCBranchesBySquash","Merge-CCBranchesByThreeWay","Merge-CCPullRequestBySquash","Merge-CCPullRequestByThreeWay","New-CCUnreferencedMergeCommit")
    "ConflictResolutionStrategy"=@("Get-CCFileMergeConflict","Get-CCFileMergeConflictBatch","Get-CCMergeCommit","Get-CCMergeConflict","Get-CCMergeOption","Merge-CCBranchesBySquash","Merge-CCBranchesByThreeWay","Merge-CCPullRequestBySquash","Merge-CCPullRequestByThreeWay","New-CCUnreferencedMergeCommit")
    "FileMode"=@("Write-CCFile")
    "Location_RelativeFileVersion"=@("Send-CCCommentForComparedCommit","Send-CCCommentForPullRequest")
    "MergeOption"=@("Get-CCFileMergeConflict","Get-CCFileMergeConflictBatch","Get-CCMergeConflict","New-CCUnreferencedMergeCommit")
    "Order"=@("Get-CCRepositoryList")
    "OverrideStatus"=@("Skip-CCPullRequestApprovalRule")
    "PullRequestEventType"=@("Get-CCPullRequestEvent")
    "PullRequestStatus"=@("Get-CCPullRequestList","Update-CCPullRequestStatus")
    "SortBy"=@("Get-CCRepositoryList")
}

_awsArgumentCompleterRegistration $CC_Completers $CC_map

$CC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CC_SelectMap = @{
    "Select"=@("Add-CCApprovalRuleTemplateToRepository",
               "Add-CCApprovalRuleTemplateToRepositoryBatch",
               "Get-CCFileMergeConflictBatch",
               "Remove-CCApprovalRuleTemplateFromRepositoryBatch",
               "Get-CCCommitBatch",
               "Get-CCRepositoryBatch",
               "New-CCApprovalRuleTemplate",
               "New-CCBranch",
               "New-CCCommit",
               "New-CCPullRequest",
               "New-CCPullRequestApprovalRule",
               "New-CCRepository",
               "New-CCUnreferencedMergeCommit",
               "Remove-CCApprovalRuleTemplate",
               "Remove-CCBranch",
               "Remove-CCCommentContent",
               "Remove-CCFile",
               "Remove-CCPullRequestApprovalRule",
               "Remove-CCRepository",
               "Get-CCFileMergeConflict",
               "Get-CCPullRequestEvent",
               "Remove-CCApprovalRuleTemplateFromRepository",
               "Invoke-CCPullRequestApprovalRule",
               "Get-CCApprovalRuleTemplate",
               "Get-CCBlob",
               "Get-CCBranch",
               "Get-CCComment",
               "Get-CCCommentsForComparedCommit",
               "Get-CCCommentsForPullRequest",
               "Get-CCCommit",
               "Get-CCDifferenceList",
               "Get-CCFile",
               "Get-CCFolder",
               "Get-CCMergeCommit",
               "Get-CCMergeConflict",
               "Get-CCMergeOption",
               "Get-CCPullRequest",
               "Get-CCPullRequestApprovalState",
               "Get-CCPullRequestOverrideState",
               "Get-CCRepository",
               "Get-CCRepositoryTrigger",
               "Get-CCApprovalRuleTemplateList",
               "Get-CCAssociatedApprovalRuleTemplatesForRepositoryList",
               "Get-CCBranchList",
               "Get-CCPullRequestList",
               "Get-CCRepositoryList",
               "Get-CCRepositoriesForApprovalRuleTemplateList",
               "Get-CCResourceTag",
               "Merge-CCBranchesByFastForward",
               "Merge-CCBranchesBySquash",
               "Merge-CCBranchesByThreeWay",
               "Merge-CCPullRequestByFastForward",
               "Merge-CCPullRequestBySquash",
               "Merge-CCPullRequestByThreeWay",
               "Skip-CCPullRequestApprovalRule",
               "Send-CCCommentForComparedCommit",
               "Send-CCCommentForPullRequest",
               "Send-CCCommentReply",
               "Write-CCFile",
               "Set-CCRepositoryTrigger",
               "Add-CCResourceTag",
               "Test-CCRepositoryTrigger",
               "Remove-CCResourceTag",
               "Update-CCApprovalRuleTemplateContent",
               "Update-CCApprovalRuleTemplateDescription",
               "Update-CCApprovalRuleTemplateName",
               "Update-CCComment",
               "Update-CCDefaultBranch",
               "Update-CCPullRequestApprovalRuleContent",
               "Update-CCPullRequestApprovalState",
               "Update-CCPullRequestDescription",
               "Update-CCPullRequestStatus",
               "Update-CCPullRequestTitle",
               "Update-CCRepositoryDescription",
               "Update-CCRepositoryName")
}

_awsArgumentCompleterRegistration $CC_SelectCompleters $CC_SelectMap
# Argument completions for service AWS CodeDeploy


$CD_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CodeDeploy.ApplicationRevisionSortBy
        "Get-CDApplicationRevisionList/SortBy"
        {
            $v = "firstUsedTime","lastUsedTime","registerTime"
            break
        }

        # Amazon.CodeDeploy.BundleType
        {
            ($_ -eq "Get-CDApplicationRevision/Revision_S3Location_BundleType") -Or
            ($_ -eq "New-CDDeployment/Revision_S3Location_BundleType") -Or
            ($_ -eq "Register-CDApplicationRevision/Revision_S3Location_BundleType")
        }
        {
            $v = "JSON","tar","tgz","YAML","zip"
            break
        }

        # Amazon.CodeDeploy.ComputePlatform
        {
            ($_ -eq "New-CDApplication/ComputePlatform") -Or
            ($_ -eq "New-CDDeploymentConfig/ComputePlatform")
        }
        {
            $v = "ECS","Lambda","Server"
            break
        }

        # Amazon.CodeDeploy.DeploymentOption
        {
            ($_ -eq "New-CDDeploymentGroup/DeploymentStyle_DeploymentOption") -Or
            ($_ -eq "Update-CDDeploymentGroup/DeploymentStyle_DeploymentOption")
        }
        {
            $v = "WITHOUT_TRAFFIC_CONTROL","WITH_TRAFFIC_CONTROL"
            break
        }

        # Amazon.CodeDeploy.DeploymentReadyAction
        {
            ($_ -eq "New-CDDeploymentGroup/BlueGreenDeploymentConfiguration_DeploymentReadyOption_ActionOnTimeout") -Or
            ($_ -eq "Update-CDDeploymentGroup/BlueGreenDeploymentConfiguration_DeploymentReadyOption_ActionOnTimeout")
        }
        {
            $v = "CONTINUE_DEPLOYMENT","STOP_DEPLOYMENT"
            break
        }

        # Amazon.CodeDeploy.DeploymentType
        {
            ($_ -eq "New-CDDeploymentGroup/DeploymentStyle_DeploymentType") -Or
            ($_ -eq "Update-CDDeploymentGroup/DeploymentStyle_DeploymentType")
        }
        {
            $v = "BLUE_GREEN","IN_PLACE"
            break
        }

        # Amazon.CodeDeploy.DeploymentWaitType
        "Resume-CDDeployment/DeploymentWaitType"
        {
            $v = "READY_WAIT","TERMINATION_WAIT"
            break
        }

        # Amazon.CodeDeploy.FileExistsBehavior
        "New-CDDeployment/FileExistsBehavior"
        {
            $v = "DISALLOW","OVERWRITE","RETAIN"
            break
        }

        # Amazon.CodeDeploy.GreenFleetProvisioningAction
        {
            ($_ -eq "New-CDDeploymentGroup/BlueGreenDeploymentConfiguration_GreenFleetProvisioningOption_Action") -Or
            ($_ -eq "Update-CDDeploymentGroup/BlueGreenDeploymentConfiguration_GreenFleetProvisioningOption_Action")
        }
        {
            $v = "COPY_AUTO_SCALING_GROUP","DISCOVER_EXISTING"
            break
        }

        # Amazon.CodeDeploy.InstanceAction
        {
            ($_ -eq "New-CDDeploymentGroup/BlueGreenDeploymentConfiguration_TerminateBlueInstancesOnDeploymentSuccess_Action") -Or
            ($_ -eq "Update-CDDeploymentGroup/BlueGreenDeploymentConfiguration_TerminateBlueInstancesOnDeploymentSuccess_Action")
        }
        {
            $v = "KEEP_ALIVE","TERMINATE"
            break
        }

        # Amazon.CodeDeploy.LifecycleEventStatus
        "Write-CDLifecycleEventHookExecutionStatus/Status"
        {
            $v = "Failed","InProgress","Pending","Skipped","Succeeded","Unknown"
            break
        }

        # Amazon.CodeDeploy.ListStateFilterAction
        "Get-CDApplicationRevisionList/Deployed"
        {
            $v = "exclude","ignore","include"
            break
        }

        # Amazon.CodeDeploy.MinimumHealthyHostsType
        "New-CDDeploymentConfig/MinimumHealthyHosts_Type"
        {
            $v = "FLEET_PERCENT","HOST_COUNT"
            break
        }

        # Amazon.CodeDeploy.RegistrationStatus
        "Get-CDOnPremiseInstanceList/RegistrationStatus"
        {
            $v = "Deregistered","Registered"
            break
        }

        # Amazon.CodeDeploy.RevisionLocationType
        {
            ($_ -eq "Get-CDApplicationRevision/Revision_RevisionType") -Or
            ($_ -eq "New-CDDeployment/Revision_RevisionType") -Or
            ($_ -eq "Register-CDApplicationRevision/Revision_RevisionType")
        }
        {
            $v = "AppSpecContent","GitHub","S3","String"
            break
        }

        # Amazon.CodeDeploy.SortOrder
        "Get-CDApplicationRevisionList/SortOrder"
        {
            $v = "ascending","descending"
            break
        }

        # Amazon.CodeDeploy.TrafficRoutingType
        "New-CDDeploymentConfig/TrafficRoutingConfig_Type"
        {
            $v = "AllAtOnce","TimeBasedCanary","TimeBasedLinear"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CD_map = @{
    "BlueGreenDeploymentConfiguration_DeploymentReadyOption_ActionOnTimeout"=@("New-CDDeploymentGroup","Update-CDDeploymentGroup")
    "BlueGreenDeploymentConfiguration_GreenFleetProvisioningOption_Action"=@("New-CDDeploymentGroup","Update-CDDeploymentGroup")
    "BlueGreenDeploymentConfiguration_TerminateBlueInstancesOnDeploymentSuccess_Action"=@("New-CDDeploymentGroup","Update-CDDeploymentGroup")
    "ComputePlatform"=@("New-CDApplication","New-CDDeploymentConfig")
    "Deployed"=@("Get-CDApplicationRevisionList")
    "DeploymentStyle_DeploymentOption"=@("New-CDDeploymentGroup","Update-CDDeploymentGroup")
    "DeploymentStyle_DeploymentType"=@("New-CDDeploymentGroup","Update-CDDeploymentGroup")
    "DeploymentWaitType"=@("Resume-CDDeployment")
    "FileExistsBehavior"=@("New-CDDeployment")
    "MinimumHealthyHosts_Type"=@("New-CDDeploymentConfig")
    "RegistrationStatus"=@("Get-CDOnPremiseInstanceList")
    "Revision_RevisionType"=@("Get-CDApplicationRevision","New-CDDeployment","Register-CDApplicationRevision")
    "Revision_S3Location_BundleType"=@("Get-CDApplicationRevision","New-CDDeployment","Register-CDApplicationRevision")
    "SortBy"=@("Get-CDApplicationRevisionList")
    "SortOrder"=@("Get-CDApplicationRevisionList")
    "Status"=@("Write-CDLifecycleEventHookExecutionStatus")
    "TrafficRoutingConfig_Type"=@("New-CDDeploymentConfig")
}

_awsArgumentCompleterRegistration $CD_Completers $CD_map

$CD_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CD.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CD_SelectMap = @{
    "Select"=@("Add-CDOnPremiseInstanceTag",
               "Get-CDApplicationRevisionBatch",
               "Get-CDApplicationBatch",
               "Get-CDDeploymentGroupBatch",
               "Get-CDDeploymentInstanceBatch",
               "Get-CDDeploymentBatch",
               "Get-CDDeploymentTargetBatch",
               "Get-CDOnPremiseInstanceBatch",
               "Resume-CDDeployment",
               "New-CDApplication",
               "New-CDDeployment",
               "New-CDDeploymentConfig",
               "New-CDDeploymentGroup",
               "Remove-CDApplication",
               "Remove-CDDeploymentConfig",
               "Remove-CDDeploymentGroup",
               "Remove-CDGitHubAccountToken",
               "Unregister-CDOnPremiseInstance",
               "Get-CDApplication",
               "Get-CDApplicationRevision",
               "Get-CDDeployment",
               "Get-CDDeploymentConfig",
               "Get-CDDeploymentGroup",
               "Get-CDDeploymentInstance",
               "Get-CDDeploymentTarget",
               "Get-CDOnPremiseInstance",
               "Get-CDApplicationRevisionList",
               "Get-CDApplicationList",
               "Get-CDDeploymentConfigList",
               "Get-CDDeploymentGroupList",
               "Get-CDDeploymentInstanceList",
               "Get-CDDeploymentList",
               "Get-CDDeploymentTargetList",
               "Get-CDGitHubAccountTokenNameList",
               "Get-CDOnPremiseInstanceList",
               "Get-CDResourceTag",
               "Write-CDLifecycleEventHookExecutionStatus",
               "Register-CDApplicationRevision",
               "Register-CDOnPremiseInstance",
               "Remove-CDOnPremiseInstanceTag",
               "Skip-CDWaitTimeForInstanceTermination",
               "Stop-CDDeployment",
               "Add-CDResourceTag",
               "Remove-CDResourceTag",
               "Update-CDApplication",
               "Update-CDDeploymentGroup")
}

_awsArgumentCompleterRegistration $CD_SelectCompleters $CD_SelectMap
# Argument completions for service Amazon CodeGuru Profiler


$CGP_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CodeGuruProfiler.AggregationPeriod
        "Get-CGPProfileTimeList/Period"
        {
            $v = "P1D","PT1H","PT5M"
            break
        }

        # Amazon.CodeGuruProfiler.OrderBy
        "Get-CGPProfileTimeList/OrderBy"
        {
            $v = "TimestampAscending","TimestampDescending"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CGP_map = @{
    "OrderBy"=@("Get-CGPProfileTimeList")
    "Period"=@("Get-CGPProfileTimeList")
}

_awsArgumentCompleterRegistration $CGP_Completers $CGP_map

$CGP_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CGP.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CGP_SelectMap = @{
    "Select"=@("Set-CGPAgentConfiguration",
               "New-CGPProfilingGroup",
               "Remove-CGPProfilingGroup",
               "Get-CGPProfilingGroup",
               "Get-CGPProfile",
               "Get-CGPProfileTimeList",
               "Get-CGPProfilingGroupList",
               "Send-CGPAgentProfile",
               "Update-CGPProfilingGroup")
}

_awsArgumentCompleterRegistration $CGP_SelectCompleters $CGP_SelectMap
# Argument completions for service Amazon CodeGuru Reviewer


$CGR_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CGR.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CGR_SelectMap = @{
    "Select"=@("Register-CGRRepository",
               "Get-CGRRepositoryAssociation",
               "Unregister-CGRRepository",
               "Get-CGRRepositoryAssociationList")
}

_awsArgumentCompleterRegistration $CGR_SelectCompleters $CGR_SelectMap
# Argument completions for service AWS CodePipeline


$CP_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CodePipeline.ActionCategory
        {
            ($_ -eq "Get-CPActionableJobList/ActionTypeId_Category") -Or
            ($_ -eq "Get-CPActionableThirdPartyJobList/ActionTypeId_Category") -Or
            ($_ -eq "New-CPCustomActionType/Category") -Or
            ($_ -eq "Remove-CPCustomActionType/Category")
        }
        {
            $v = "Approval","Build","Deploy","Invoke","Source","Test"
            break
        }

        # Amazon.CodePipeline.ActionOwner
        {
            ($_ -eq "Get-CPActionType/ActionOwnerFilter") -Or
            ($_ -eq "Get-CPActionableJobList/ActionTypeId_Owner") -Or
            ($_ -eq "Get-CPActionableThirdPartyJobList/ActionTypeId_Owner")
        }
        {
            $v = "AWS","Custom","ThirdParty"
            break
        }

        # Amazon.CodePipeline.ApprovalStatus
        "Write-CPApprovalResult/Result_Status"
        {
            $v = "Approved","Rejected"
            break
        }

        # Amazon.CodePipeline.FailureType
        {
            ($_ -eq "Write-CPJobFailureResult/FailureDetails_Type") -Or
            ($_ -eq "Write-CPThirdPartyJobFailureResult/FailureDetails_Type")
        }
        {
            $v = "ConfigurationError","JobFailed","PermissionError","RevisionOutOfSync","RevisionUnavailable","SystemUnavailable"
            break
        }

        # Amazon.CodePipeline.StageRetryMode
        "Redo-CPStageExecution/RetryMode"
        {
            $v = "FAILED_ACTIONS"
            break
        }

        # Amazon.CodePipeline.StageTransitionType
        {
            ($_ -eq "Disable-CPStageTransition/TransitionType") -Or
            ($_ -eq "Enable-CPStageTransition/TransitionType")
        }
        {
            $v = "Inbound","Outbound"
            break
        }

        # Amazon.CodePipeline.WebhookAuthenticationType
        "Write-CPWebhook/Webhook_Authentication"
        {
            $v = "GITHUB_HMAC","IP","UNAUTHENTICATED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CP_map = @{
    "ActionOwnerFilter"=@("Get-CPActionType")
    "ActionTypeId_Category"=@("Get-CPActionableJobList","Get-CPActionableThirdPartyJobList")
    "ActionTypeId_Owner"=@("Get-CPActionableJobList","Get-CPActionableThirdPartyJobList")
    "Category"=@("New-CPCustomActionType","Remove-CPCustomActionType")
    "FailureDetails_Type"=@("Write-CPJobFailureResult","Write-CPThirdPartyJobFailureResult")
    "Result_Status"=@("Write-CPApprovalResult")
    "RetryMode"=@("Redo-CPStageExecution")
    "TransitionType"=@("Disable-CPStageTransition","Enable-CPStageTransition")
    "Webhook_Authentication"=@("Write-CPWebhook")
}

_awsArgumentCompleterRegistration $CP_Completers $CP_map

$CP_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CP.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CP_SelectMap = @{
    "Select"=@("Confirm-CPJob",
               "Confirm-CPThirdPartyJob",
               "New-CPCustomActionType",
               "New-CPPipeline",
               "Remove-CPCustomActionType",
               "Remove-CPPipeline",
               "Remove-CPWebhook",
               "Unregister-CPWebhookWithThirdParty",
               "Disable-CPStageTransition",
               "Enable-CPStageTransition",
               "Get-CPJobDetail",
               "Get-CPPipeline",
               "Get-CPPipelineExecution",
               "Get-CPPipelineState",
               "Get-CPThirdPartyJobDetail",
               "Get-CPActionExecutionList",
               "Get-CPActionType",
               "Get-CPPipelineExecutionSummary",
               "Get-CPPipelineList",
               "Get-CPResourceTag",
               "Get-CPWebhookList",
               "Get-CPActionableJobList",
               "Get-CPActionableThirdPartyJobList",
               "Write-CPActionRevision",
               "Write-CPApprovalResult",
               "Write-CPJobFailureResult",
               "Write-CPJobSuccessResult",
               "Write-CPThirdPartyJobFailureResult",
               "Write-CPThirdPartyJobSuccessResult",
               "Write-CPWebhook",
               "Register-CPWebhookWithThirdParty",
               "Redo-CPStageExecution",
               "Start-CPPipelineExecution",
               "Add-CPResourceTag",
               "Remove-CPResourceTag",
               "Update-CPPipeline")
}

_awsArgumentCompleterRegistration $CP_SelectCompleters $CP_SelectMap
# Argument completions for service AWS CodeStar


$CST_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CST.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CST_SelectMap = @{
    "Select"=@("Add-CSTTeamMember",
               "New-CSTProject",
               "New-CSTUserProfile",
               "Remove-CSTProject",
               "Remove-CSTUserProfile",
               "Get-CSTProject",
               "Get-CSTUserProfile",
               "Remove-CSTTeamMember",
               "Get-CSTProjectList",
               "Get-CSTResourceList",
               "Get-CSTTagsForProject",
               "Get-CSTTeamMemberList",
               "Get-CSTUserProfileList",
               "Add-CSTTagsForProject",
               "Remove-CSTTagsForProject",
               "Update-CSTProject",
               "Update-CSTTeamMember",
               "Update-CSTUserProfile")
}

_awsArgumentCompleterRegistration $CST_SelectCompleters $CST_SelectMap
# Argument completions for service AWS CodeStar Notifications


$CSTN_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CodeStarNotifications.DetailType
        {
            ($_ -eq "New-CSTNNotificationRule/DetailType") -Or
            ($_ -eq "Update-CSTNNotificationRule/DetailType")
        }
        {
            $v = "BASIC","FULL"
            break
        }

        # Amazon.CodeStarNotifications.NotificationRuleStatus
        {
            ($_ -eq "New-CSTNNotificationRule/Status") -Or
            ($_ -eq "Update-CSTNNotificationRule/Status")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CSTN_map = @{
    "DetailType"=@("New-CSTNNotificationRule","Update-CSTNNotificationRule")
    "Status"=@("New-CSTNNotificationRule","Update-CSTNNotificationRule")
}

_awsArgumentCompleterRegistration $CSTN_Completers $CSTN_map

$CSTN_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CSTN.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CSTN_SelectMap = @{
    "Select"=@("New-CSTNNotificationRule",
               "Remove-CSTNNotificationRule",
               "Remove-CSTNTarget",
               "Get-CSTNNotificationRule",
               "Get-CSTNEventTypeList",
               "Get-CSTNNotificationRuleList",
               "Get-CSTNResourceTag",
               "Get-CSTNTargetList",
               "Add-CSTNSubscription",
               "Add-CSTNResourceTag",
               "Remove-CSTNSubscription",
               "Remove-CSTNResourceTag",
               "Update-CSTNNotificationRule")
}

_awsArgumentCompleterRegistration $CSTN_SelectCompleters $CSTN_SelectMap
# Argument completions for service Amazon Cognito Identity


$CGI_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CGI.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CGI_SelectMap = @{
    "Select"=@("New-CGIIdentityPool",
               "Remove-CGIIdentityPool",
               "Get-CGIIdentityPool",
               "Get-CGIIdentityPoolRole",
               "Get-CGIIdentityPoolList",
               "Get-CGIResourceTag",
               "Set-CGIIdentityPoolRole",
               "Add-CGIResourceTag",
               "Remove-CGIResourceTag",
               "Update-CGIIdentityPool")
}

_awsArgumentCompleterRegistration $CGI_SelectCompleters $CGI_SelectMap
# Argument completions for service Amazon Cognito Identity Provider


$CGIP_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CognitoIdentityProvider.AccountTakeoverEventActionType
        {
            ($_ -eq "Set-CGIPRiskConfiguration/AccountTakeoverRiskConfiguration_Actions_HighAction_EventAction") -Or
            ($_ -eq "Set-CGIPRiskConfiguration/AccountTakeoverRiskConfiguration_Actions_LowAction_EventAction") -Or
            ($_ -eq "Set-CGIPRiskConfiguration/AccountTakeoverRiskConfiguration_Actions_MediumAction_EventAction")
        }
        {
            $v = "BLOCK","MFA_IF_CONFIGURED","MFA_REQUIRED","NO_ACTION"
            break
        }

        # Amazon.CognitoIdentityProvider.AdvancedSecurityModeType
        {
            ($_ -eq "New-CGIPUserPool/UserPoolAddOns_AdvancedSecurityMode") -Or
            ($_ -eq "Update-CGIPUserPool/UserPoolAddOns_AdvancedSecurityMode")
        }
        {
            $v = "AUDIT","ENFORCED","OFF"
            break
        }

        # Amazon.CognitoIdentityProvider.AuthFlowType
        {
            ($_ -eq "Start-CGIPAuth/AuthFlow") -Or
            ($_ -eq "Start-CGIPAuthAdmin/AuthFlow")
        }
        {
            $v = "ADMIN_NO_SRP_AUTH","ADMIN_USER_PASSWORD_AUTH","CUSTOM_AUTH","REFRESH_TOKEN","REFRESH_TOKEN_AUTH","USER_PASSWORD_AUTH","USER_SRP_AUTH"
            break
        }

        # Amazon.CognitoIdentityProvider.ChallengeNameType
        {
            ($_ -eq "Send-CGIPAuthChallengeResponse/ChallengeName") -Or
            ($_ -eq "Send-CGIPAuthChallengeResponseAdmin/ChallengeName")
        }
        {
            $v = "ADMIN_NO_SRP_AUTH","CUSTOM_CHALLENGE","DEVICE_PASSWORD_VERIFIER","DEVICE_SRP_AUTH","MFA_SETUP","NEW_PASSWORD_REQUIRED","PASSWORD_VERIFIER","SELECT_MFA_TYPE","SMS_MFA","SOFTWARE_TOKEN_MFA"
            break
        }

        # Amazon.CognitoIdentityProvider.CompromisedCredentialsEventActionType
        "Set-CGIPRiskConfiguration/CompromisedCredentialsRiskConfiguration_Actions_EventAction"
        {
            $v = "BLOCK","NO_ACTION"
            break
        }

        # Amazon.CognitoIdentityProvider.DefaultEmailOptionType
        {
            ($_ -eq "New-CGIPUserPool/VerificationMessageTemplate_DefaultEmailOption") -Or
            ($_ -eq "Update-CGIPUserPool/VerificationMessageTemplate_DefaultEmailOption")
        }
        {
            $v = "CONFIRM_WITH_CODE","CONFIRM_WITH_LINK"
            break
        }

        # Amazon.CognitoIdentityProvider.DeviceRememberedStatusType
        {
            ($_ -eq "Edit-CGIPDeviceStatus/DeviceRememberedStatus") -Or
            ($_ -eq "Edit-CGIPDeviceStatusAdmin/DeviceRememberedStatus")
        }
        {
            $v = "not_remembered","remembered"
            break
        }

        # Amazon.CognitoIdentityProvider.EmailSendingAccountType
        {
            ($_ -eq "New-CGIPUserPool/EmailConfiguration_EmailSendingAccount") -Or
            ($_ -eq "Update-CGIPUserPool/EmailConfiguration_EmailSendingAccount")
        }
        {
            $v = "COGNITO_DEFAULT","DEVELOPER"
            break
        }

        # Amazon.CognitoIdentityProvider.FeedbackValueType
        {
            ($_ -eq "Update-CGIPAuthEventFeedback/FeedbackValue") -Or
            ($_ -eq "Update-CGIPAuthEventFeedbackAdmin/FeedbackValue")
        }
        {
            $v = "Invalid","Valid"
            break
        }

        # Amazon.CognitoIdentityProvider.IdentityProviderTypeType
        "New-CGIPIdentityProvider/ProviderType"
        {
            $v = "Facebook","Google","LoginWithAmazon","OIDC","SAML","SignInWithApple"
            break
        }

        # Amazon.CognitoIdentityProvider.MessageActionType
        "New-CGIPUserAdmin/MessageAction"
        {
            $v = "RESEND","SUPPRESS"
            break
        }

        # Amazon.CognitoIdentityProvider.PreventUserExistenceErrorTypes
        {
            ($_ -eq "New-CGIPUserPoolClient/PreventUserExistenceErrors") -Or
            ($_ -eq "Update-CGIPUserPoolClient/PreventUserExistenceErrors")
        }
        {
            $v = "ENABLED","LEGACY"
            break
        }

        # Amazon.CognitoIdentityProvider.UserPoolMfaType
        {
            ($_ -eq "New-CGIPUserPool/MfaConfiguration") -Or
            ($_ -eq "Set-CGIPUserPoolMfaConfig/MfaConfiguration") -Or
            ($_ -eq "Update-CGIPUserPool/MfaConfiguration")
        }
        {
            $v = "OFF","ON","OPTIONAL"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CGIP_map = @{
    "AccountTakeoverRiskConfiguration_Actions_HighAction_EventAction"=@("Set-CGIPRiskConfiguration")
    "AccountTakeoverRiskConfiguration_Actions_LowAction_EventAction"=@("Set-CGIPRiskConfiguration")
    "AccountTakeoverRiskConfiguration_Actions_MediumAction_EventAction"=@("Set-CGIPRiskConfiguration")
    "AuthFlow"=@("Start-CGIPAuth","Start-CGIPAuthAdmin")
    "ChallengeName"=@("Send-CGIPAuthChallengeResponse","Send-CGIPAuthChallengeResponseAdmin")
    "CompromisedCredentialsRiskConfiguration_Actions_EventAction"=@("Set-CGIPRiskConfiguration")
    "DeviceRememberedStatus"=@("Edit-CGIPDeviceStatus","Edit-CGIPDeviceStatusAdmin")
    "EmailConfiguration_EmailSendingAccount"=@("New-CGIPUserPool","Update-CGIPUserPool")
    "FeedbackValue"=@("Update-CGIPAuthEventFeedback","Update-CGIPAuthEventFeedbackAdmin")
    "MessageAction"=@("New-CGIPUserAdmin")
    "MfaConfiguration"=@("New-CGIPUserPool","Set-CGIPUserPoolMfaConfig","Update-CGIPUserPool")
    "PreventUserExistenceErrors"=@("New-CGIPUserPoolClient","Update-CGIPUserPoolClient")
    "ProviderType"=@("New-CGIPIdentityProvider")
    "UserPoolAddOns_AdvancedSecurityMode"=@("New-CGIPUserPool","Update-CGIPUserPool")
    "VerificationMessageTemplate_DefaultEmailOption"=@("New-CGIPUserPool","Update-CGIPUserPool")
}

_awsArgumentCompleterRegistration $CGIP_Completers $CGIP_map

$CGIP_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CGIP.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CGIP_SelectMap = @{
    "Select"=@("Add-CGIPCustomAttribute",
               "Add-CGIPUserToGroupAdmin",
               "Confirm-CGIPUserRegistrationAdmin",
               "New-CGIPUserAdmin",
               "Remove-CGIPUserAdmin",
               "Remove-CGIPUserAttributeAdmin",
               "Disable-CGIPProviderForUserAdmin",
               "Disable-CGIPUserAdmin",
               "Enable-CGIPUserAdmin",
               "Stop-CGIPDeviceTrackingAdmin",
               "Get-CGIPDeviceAdmin",
               "Get-CGIPUserAdmin",
               "Start-CGIPAuthAdmin",
               "Connect-CGIPProviderForUserAdmin",
               "Get-CGIPDeviceListAdmin",
               "Get-CGIPGroupsForUserAdmin",
               "Get-CGIPUserAuthEventListAdmin",
               "Remove-CGIPUserFromGroupAdmin",
               "Reset-CGIPUserPasswordAdmin",
               "Send-CGIPAuthChallengeResponseAdmin",
               "Set-CGIPUserMFAPreferenceAdmin",
               "Set-CGIPUserPasswordAdmin",
               "Set-CGIPUserSettingAdmin",
               "Update-CGIPAuthEventFeedbackAdmin",
               "Edit-CGIPDeviceStatusAdmin",
               "Update-CGIPUserAttributeAdmin",
               "Disconnect-CGIPUserGlobalAdmin",
               "Add-CGIPSoftwareToken",
               "Update-CGIPPassword",
               "Approve-CGIPDevice",
               "Confirm-CGIPForgotPassword",
               "Confirm-CGIPUserRegistration",
               "New-CGIPGroup",
               "New-CGIPIdentityProvider",
               "New-CGIPResourceServer",
               "New-CGIPUserImportJob",
               "New-CGIPUserPool",
               "New-CGIPUserPoolClient",
               "New-CGIPUserPoolDomain",
               "Remove-CGIPGroup",
               "Remove-CGIPIdentityProvider",
               "Remove-CGIPResourceServer",
               "Remove-CGIPUser",
               "Remove-CGIPUserAttribute",
               "Remove-CGIPUserPool",
               "Remove-CGIPUserPoolClient",
               "Remove-CGIPUserPoolDomain",
               "Get-CGIPIdentityProvider",
               "Get-CGIPResourceServer",
               "Get-CGIPRiskConfiguration",
               "Get-CGIPUserImportJob",
               "Get-CGIPUserPool",
               "Get-CGIPUserPoolClient",
               "Get-CGIPUserPoolDomain",
               "Stop-CGIPDeviceTracking",
               "Reset-CGIPForgottenPassword",
               "Get-CGIPCSVHeader",
               "Get-CGIPDevice",
               "Get-CGIPGroup",
               "Get-CGIPIdentityProviderByIdentifier",
               "Get-CGIPSigningCertificate",
               "Get-CGIPUICustomization",
               "Get-CGIPUser",
               "Get-CGIPUserAttributeVerificationCode",
               "Get-CGIPUserPoolMfaConfig",
               "Disconnect-CGIPDeviceGlobal",
               "Start-CGIPAuth",
               "Get-CGIPDeviceList",
               "Get-CGIPGroupList",
               "Get-CGIPIdentityProviderList",
               "Get-CGIPResourceServerList",
               "Get-CGIPResourceTag",
               "Get-CGIPUserImportJobList",
               "Get-CGIPUserPoolClientList",
               "Get-CGIPUserPoolList",
               "Get-CGIPUserList",
               "Get-CGIPUsersInGroup",
               "Send-CGIPConfirmationCode",
               "Send-CGIPAuthChallengeResponse",
               "Set-CGIPRiskConfiguration",
               "Set-CGIPUICustomization",
               "Set-CGIPUserMFAPreference",
               "Set-CGIPUserPoolMfaConfig",
               "Set-CGIPUserSetting",
               "Register-CGIPUserInPool",
               "Start-CGIPUserImportJob",
               "Stop-CGIPUserImportJob",
               "Add-CGIPResourceTag",
               "Remove-CGIPResourceTag",
               "Update-CGIPAuthEventFeedback",
               "Edit-CGIPDeviceStatus",
               "Update-CGIPGroup",
               "Update-CGIPIdentityProvider",
               "Update-CGIPResourceServer",
               "Update-CGIPUserAttribute",
               "Update-CGIPUserPool",
               "Update-CGIPUserPoolClient",
               "Update-CGIPUserPoolDomain",
               "Test-CGIPSoftwareToken",
               "Test-CGIPUserAttribute")
}

_awsArgumentCompleterRegistration $CGIP_SelectCompleters $CGIP_SelectMap
# Argument completions for service Amazon Cognito Sync


$CGIS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CognitoSync.Platform
        "Register-CGISDevice/Platform"
        {
            $v = "ADM","APNS","APNS_SANDBOX","GCM"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CGIS_map = @{
    "Platform"=@("Register-CGISDevice")
}

_awsArgumentCompleterRegistration $CGIS_Completers $CGIS_map

$CGIS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CGIS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CGIS_SelectMap = @{
    "Select"=@("Publish-CGISBulkDataset",
               "Remove-CGISDataset",
               "Get-CGISDataset",
               "Get-CGISIdentityPoolUsage",
               "Get-CGISIdentityUsage",
               "Get-CGISBulkPublishDetail",
               "Get-CGISCognitoEvent",
               "Get-CGISIdentityPoolConfiguration",
               "Get-CGISDatasetList",
               "Get-CGISIdentityPoolUsageList",
               "Get-CGISRecordList",
               "Register-CGISDevice",
               "Set-CGISCognitoEventLambdaFunction",
               "Set-CGISIdentityPoolConfiguration",
               "Add-CGISDatasetSubscription",
               "Remove-CGISDatasetSubscription",
               "Update-CGISRecord")
}

_awsArgumentCompleterRegistration $CGIS_SelectCompleters $CGIS_SelectMap
# Argument completions for service Amazon Comprehend


$COMP_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Comprehend.EndpointStatus
        "Get-COMPEndpointList/Filter_Status"
        {
            $v = "CREATING","DELETING","FAILED","IN_SERVICE","UPDATING"
            break
        }

        # Amazon.Comprehend.JobStatus
        "Get-COMPDocumentClassificationJobList/Filter_JobStatus"
        {
            $v = "COMPLETED","FAILED","IN_PROGRESS","STOPPED","STOP_REQUESTED","SUBMITTED"
            break
        }

        # Amazon.Comprehend.LanguageCode
        {
            ($_ -eq "Find-COMPEntity/LanguageCode") -Or
            ($_ -eq "Find-COMPEntityBatch/LanguageCode") -Or
            ($_ -eq "Find-COMPKeyPhrase/LanguageCode") -Or
            ($_ -eq "Find-COMPKeyPhrasesBatch/LanguageCode") -Or
            ($_ -eq "Find-COMPSentiment/LanguageCode") -Or
            ($_ -eq "Find-COMPSentimentBatch/LanguageCode") -Or
            ($_ -eq "New-COMPDocumentClassifier/LanguageCode") -Or
            ($_ -eq "New-COMPEntityRecognizer/LanguageCode") -Or
            ($_ -eq "Start-COMPEntitiesDetectionJob/LanguageCode") -Or
            ($_ -eq "Start-COMPKeyPhrasesDetectionJob/LanguageCode") -Or
            ($_ -eq "Start-COMPSentimentDetectionJob/LanguageCode")
        }
        {
            $v = "ar","de","en","es","fr","hi","it","ja","ko","pt","zh","zh-TW"
            break
        }

        # Amazon.Comprehend.ModelStatus
        {
            ($_ -eq "Get-COMPDocumentClassifierList/Filter_Status") -Or
            ($_ -eq "Get-COMPEntityRecognizerList/Filter_Status")
        }
        {
            $v = "DELETING","IN_ERROR","STOPPED","STOP_REQUESTED","SUBMITTED","TRAINED","TRAINING"
            break
        }

        # Amazon.Comprehend.SyntaxLanguageCode
        {
            ($_ -eq "Find-COMPSyntax/LanguageCode") -Or
            ($_ -eq "Find-COMPSyntaxBatch/LanguageCode")
        }
        {
            $v = "de","en","es","fr","it","pt"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$COMP_map = @{
    "Filter_JobStatus"=@("Get-COMPDocumentClassificationJobList")
    "Filter_Status"=@("Get-COMPDocumentClassifierList","Get-COMPEndpointList","Get-COMPEntityRecognizerList")
    "LanguageCode"=@("Find-COMPEntity","Find-COMPEntityBatch","Find-COMPKeyPhrase","Find-COMPKeyPhrasesBatch","Find-COMPSentiment","Find-COMPSentimentBatch","Find-COMPSyntax","Find-COMPSyntaxBatch","New-COMPDocumentClassifier","New-COMPEntityRecognizer","Start-COMPEntitiesDetectionJob","Start-COMPKeyPhrasesDetectionJob","Start-COMPSentimentDetectionJob")
}

_awsArgumentCompleterRegistration $COMP_Completers $COMP_map

$COMP_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.COMP.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$COMP_SelectMap = @{
    "Select"=@("Find-COMPDominantLanguageBatch",
               "Find-COMPEntityBatch",
               "Find-COMPKeyPhrasesBatch",
               "Find-COMPSentimentBatch",
               "Find-COMPSyntaxBatch",
               "Invoke-COMPDocumentClassification",
               "New-COMPDocumentClassifier",
               "New-COMPEndpoint",
               "New-COMPEntityRecognizer",
               "Remove-COMPDocumentClassifier",
               "Remove-COMPEndpoint",
               "Remove-COMPEntityRecognizer",
               "Get-COMPDocumentClassificationJob",
               "Get-COMPDocumentClassifier",
               "Get-COMPDominantLanguageDetectionJob",
               "Get-COMPEndpoint",
               "Get-COMPEntitiesDetectionJob",
               "Get-COMPEntityRecognizer",
               "Get-COMPKeyPhrasesDetectionJob",
               "Get-COMPSentimentDetectionJob",
               "Get-COMPTopicsDetectionJob",
               "Find-COMPDominantLanguage",
               "Find-COMPEntity",
               "Find-COMPKeyPhrase",
               "Find-COMPSentiment",
               "Find-COMPSyntax",
               "Get-COMPDocumentClassificationJobList",
               "Get-COMPDocumentClassifierList",
               "Get-COMPDominantLanguageDetectionJobList",
               "Get-COMPEndpointList",
               "Get-COMPEntitiesDetectionJobList",
               "Get-COMPEntityRecognizerList",
               "Get-COMPKeyPhrasesDetectionJobList",
               "Get-COMPSentimentDetectionJobList",
               "Get-COMPResourceTag",
               "Get-COMPTopicsDetectionJobList",
               "Start-COMPDocumentClassificationJob",
               "Start-COMPDominantLanguageDetectionJob",
               "Start-COMPEntitiesDetectionJob",
               "Start-COMPKeyPhrasesDetectionJob",
               "Start-COMPSentimentDetectionJob",
               "Start-COMPTopicsDetectionJob",
               "Stop-COMPDominantLanguageDetectionJob",
               "Stop-COMPEntitiesDetectionJob",
               "Stop-COMPKeyPhrasesDetectionJob",
               "Stop-COMPSentimentDetectionJob",
               "Stop-COMPTrainingDocumentClassifier",
               "Stop-COMPTrainingEntityRecognizer",
               "Add-COMPResourceTag",
               "Remove-COMPResourceTag",
               "Update-COMPEndpoint")
}

_awsArgumentCompleterRegistration $COMP_SelectCompleters $COMP_SelectMap
# Argument completions for service AWS Comprehend Medical


$CMPM_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ComprehendMedical.JobStatus
        {
            ($_ -eq "Get-CMPMEntitiesDetectionV2JobList/Filter_JobStatus") -Or
            ($_ -eq "Get-CMPMPersonalHealthInformationDetectionJobList/Filter_JobStatus")
        }
        {
            $v = "COMPLETED","FAILED","IN_PROGRESS","PARTIAL_SUCCESS","STOPPED","STOP_REQUESTED","SUBMITTED"
            break
        }

        # Amazon.ComprehendMedical.LanguageCode
        {
            ($_ -eq "Start-CMPMEntitiesDetectionV2Job/LanguageCode") -Or
            ($_ -eq "Start-CMPMPersonalHealthInformationDetectionJob/LanguageCode")
        }
        {
            $v = "en"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CMPM_map = @{
    "Filter_JobStatus"=@("Get-CMPMEntitiesDetectionV2JobList","Get-CMPMPersonalHealthInformationDetectionJobList")
    "LanguageCode"=@("Start-CMPMEntitiesDetectionV2Job","Start-CMPMPersonalHealthInformationDetectionJob")
}

_awsArgumentCompleterRegistration $CMPM_Completers $CMPM_map

$CMPM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CMPM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CMPM_SelectMap = @{
    "Select"=@("Get-CMPMEntitiesDetectionV2Job",
               "Get-CMPMPersonalHealthInformationDetectionJob",
               "Find-CMPMMedicalEntity",
               "Find-CMPMMedicalEntityV2",
               "Find-CMPMPersonalHealthInformation",
               "Get-CMPMEntitiesDetectionV2JobList",
               "Get-CMPMPersonalHealthInformationDetectionJobList",
               "Start-CMPMEntitiesDetectionV2Job",
               "Start-CMPMPersonalHealthInformationDetectionJob",
               "Stop-CMPMEntitiesDetectionV2Job",
               "Stop-CMPMPersonalHealthInformationDetectionJob")
}

_awsArgumentCompleterRegistration $CMPM_SelectCompleters $CMPM_SelectMap
# Argument completions for service AWS Compute Optimizer


$CO_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ComputeOptimizer.MetricStatistic
        "Get-COEC2RecommendationProjectedMetric/Stat"
        {
            $v = "Average","Maximum"
            break
        }

        # Amazon.ComputeOptimizer.Status
        "Update-COEnrollmentStatus/Status"
        {
            $v = "Active","Failed","Inactive","Pending"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CO_map = @{
    "Stat"=@("Get-COEC2RecommendationProjectedMetric")
    "Status"=@("Update-COEnrollmentStatus")
}

_awsArgumentCompleterRegistration $CO_Completers $CO_map

$CO_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CO.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CO_SelectMap = @{
    "Select"=@("Get-COAutoScalingGroupRecommendation",
               "Get-COEC2InstanceRecommendation",
               "Get-COEC2RecommendationProjectedMetric",
               "Get-COEnrollmentStatus",
               "Get-CORecommendationSummary",
               "Update-COEnrollmentStatus")
}

_awsArgumentCompleterRegistration $CO_SelectCompleters $CO_SelectMap
# Argument completions for service AWS Config


$CFG_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ConfigService.ChronologicalOrder
        "Get-CFGResourceConfigHistory/ChronologicalOrder"
        {
            $v = "Forward","Reverse"
            break
        }

        # Amazon.ConfigService.ComplianceType
        {
            ($_ -eq "Get-CFGAggregateComplianceDetailsByConfigRule/ComplianceType") -Or
            ($_ -eq "Get-CFGAggregateComplianceByConfigRuleList/Filters_ComplianceType")
        }
        {
            $v = "COMPLIANT","INSUFFICIENT_DATA","NON_COMPLIANT","NOT_APPLICABLE"
            break
        }

        # Amazon.ConfigService.ConfigRuleComplianceSummaryGroupKey
        "Get-CFGAggregateConfigRuleComplianceSummary/GroupByKey"
        {
            $v = "ACCOUNT_ID","AWS_REGION"
            break
        }

        # Amazon.ConfigService.ConfigRuleState
        "Write-CFGConfigRule/ConfigRule_ConfigRuleState"
        {
            $v = "ACTIVE","DELETING","DELETING_RESULTS","EVALUATING"
            break
        }

        # Amazon.ConfigService.ConformancePackComplianceType
        {
            ($_ -eq "Get-CFGConformancePackCompliance/Filters_ComplianceType") -Or
            ($_ -eq "Get-CFGConformancePackComplianceDetail/Filters_ComplianceType")
        }
        {
            $v = "COMPLIANT","NON_COMPLIANT"
            break
        }

        # Amazon.ConfigService.MaximumExecutionFrequency
        {
            ($_ -eq "Write-CFGConfigRule/ConfigRule_MaximumExecutionFrequency") -Or
            ($_ -eq "Write-CFGDeliveryChannel/DeliveryChannel_ConfigSnapshotDeliveryProperties_DeliveryFrequency") -Or
            ($_ -eq "Write-CFGOrganizationConfigRule/OrganizationCustomRuleMetadata_MaximumExecutionFrequency") -Or
            ($_ -eq "Write-CFGOrganizationConfigRule/OrganizationManagedRuleMetadata_MaximumExecutionFrequency")
        }
        {
            $v = "One_Hour","Six_Hours","Three_Hours","Twelve_Hours","TwentyFour_Hours"
            break
        }

        # Amazon.ConfigService.MemberAccountRuleStatus
        "Get-CFGOrganizationConfigRuleDetailedStatus/Filters_MemberAccountRuleStatus"
        {
            $v = "CREATE_FAILED","CREATE_IN_PROGRESS","CREATE_SUCCESSFUL","DELETE_FAILED","DELETE_IN_PROGRESS","DELETE_SUCCESSFUL","UPDATE_FAILED","UPDATE_IN_PROGRESS","UPDATE_SUCCESSFUL"
            break
        }

        # Amazon.ConfigService.OrganizationResourceDetailedStatus
        "Get-CFGOrganizationConformancePackDetailedStatus/Filters_Status"
        {
            $v = "CREATE_FAILED","CREATE_IN_PROGRESS","CREATE_SUCCESSFUL","DELETE_FAILED","DELETE_IN_PROGRESS","DELETE_SUCCESSFUL","UPDATE_FAILED","UPDATE_IN_PROGRESS","UPDATE_SUCCESSFUL"
            break
        }

        # Amazon.ConfigService.Owner
        "Write-CFGConfigRule/ConfigRule_Source_Owner"
        {
            $v = "AWS","CUSTOM_LAMBDA"
            break
        }

        # Amazon.ConfigService.ResourceCountGroupKey
        "Get-CFGAggregateDiscoveredResourceCount/GroupByKey"
        {
            $v = "ACCOUNT_ID","AWS_REGION","RESOURCE_TYPE"
            break
        }

        # Amazon.ConfigService.ResourceType
        {
            ($_ -eq "Get-CFGAggregateDiscoveredResourceCount/Filters_ResourceType") -Or
            ($_ -eq "Get-CFGAggregateResourceConfig/ResourceIdentifier_ResourceType") -Or
            ($_ -eq "Get-CFGAggregateDiscoveredResourceList/ResourceType") -Or
            ($_ -eq "Get-CFGDiscoveredResource/ResourceType") -Or
            ($_ -eq "Get-CFGResourceConfigHistory/ResourceType")
        }
        {
            $v = "AWS::ACM::Certificate","AWS::ApiGateway::DomainName","AWS::ApiGateway::Method","AWS::ApiGateway::RestApi","AWS::ApiGateway::Stage","AWS::ApiGatewayV2::Api","AWS::ApiGatewayV2::DomainName","AWS::ApiGatewayV2::Stage","AWS::AutoScaling::AutoScalingGroup","AWS::AutoScaling::LaunchConfiguration","AWS::AutoScaling::ScalingPolicy","AWS::AutoScaling::ScheduledAction","AWS::CloudFormation::Stack","AWS::CloudFront::Distribution","AWS::CloudFront::StreamingDistribution","AWS::CloudTrail::Trail","AWS::CloudWatch::Alarm","AWS::CodeBuild::Project","AWS::CodePipeline::Pipeline","AWS::Config::ResourceCompliance","AWS::DynamoDB::Table","AWS::EC2::CustomerGateway","AWS::EC2::EgressOnlyInternetGateway","AWS::EC2::EIP","AWS::EC2::FlowLog","AWS::EC2::Host","AWS::EC2::Instance","AWS::EC2::InternetGateway","AWS::EC2::NatGateway","AWS::EC2::NetworkAcl","AWS::EC2::NetworkInterface","AWS::EC2::RegisteredHAInstance","AWS::EC2::RouteTable","AWS::EC2::SecurityGroup","AWS::EC2::Subnet","AWS::EC2::Volume","AWS::EC2::VPC","AWS::EC2::VPCEndpoint","AWS::EC2::VPCEndpointService","AWS::EC2::VPCPeeringConnection","AWS::EC2::VPNConnection","AWS::EC2::VPNGateway","AWS::ElasticBeanstalk::Application","AWS::ElasticBeanstalk::ApplicationVersion","AWS::ElasticBeanstalk::Environment","AWS::ElasticLoadBalancing::LoadBalancer","AWS::ElasticLoadBalancingV2::LoadBalancer","AWS::IAM::Group","AWS::IAM::Policy","AWS::IAM::Role","AWS::IAM::User","AWS::Lambda::Alias","AWS::Lambda::Function","AWS::LicenseManager::LicenseConfiguration","AWS::MobileHub::Project","AWS::RDS::DBCluster","AWS::RDS::DBClusterParameterGroup","AWS::RDS::DBClusterSnapshot","AWS::RDS::DBInstance","AWS::RDS::DBOptionGroup","AWS::RDS::DBParameterGroup","AWS::RDS::DBSecurityGroup","AWS::RDS::DBSnapshot","AWS::RDS::DBSubnetGroup","AWS::RDS::EventSubscription","AWS::Redshift::Cluster","AWS::Redshift::ClusterParameterGroup","AWS::Redshift::ClusterSecurityGroup","AWS::Redshift::ClusterSnapshot","AWS::Redshift::ClusterSubnetGroup","AWS::Redshift::EventSubscription","AWS::S3::AccountPublicAccessBlock","AWS::S3::Bucket","AWS::ServiceCatalog::CloudFormationProduct","AWS::ServiceCatalog::CloudFormationProvisionedProduct","AWS::ServiceCatalog::Portfolio","AWS::Shield::Protection","AWS::ShieldRegional::Protection","AWS::SSM::AssociationCompliance","AWS::SSM::ManagedInstanceInventory","AWS::SSM::PatchCompliance","AWS::WAF::RateBasedRule","AWS::WAF::Rule","AWS::WAF::RuleGroup","AWS::WAF::WebACL","AWS::WAFRegional::RateBasedRule","AWS::WAFRegional::Rule","AWS::WAFRegional::RuleGroup","AWS::WAFRegional::WebACL","AWS::XRay::EncryptionConfig"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CFG_map = @{
    "ChronologicalOrder"=@("Get-CFGResourceConfigHistory")
    "ComplianceType"=@("Get-CFGAggregateComplianceDetailsByConfigRule")
    "ConfigRule_ConfigRuleState"=@("Write-CFGConfigRule")
    "ConfigRule_MaximumExecutionFrequency"=@("Write-CFGConfigRule")
    "ConfigRule_Source_Owner"=@("Write-CFGConfigRule")
    "DeliveryChannel_ConfigSnapshotDeliveryProperties_DeliveryFrequency"=@("Write-CFGDeliveryChannel")
    "Filters_ComplianceType"=@("Get-CFGAggregateComplianceByConfigRuleList","Get-CFGConformancePackCompliance","Get-CFGConformancePackComplianceDetail")
    "Filters_MemberAccountRuleStatus"=@("Get-CFGOrganizationConfigRuleDetailedStatus")
    "Filters_ResourceType"=@("Get-CFGAggregateDiscoveredResourceCount")
    "Filters_Status"=@("Get-CFGOrganizationConformancePackDetailedStatus")
    "GroupByKey"=@("Get-CFGAggregateConfigRuleComplianceSummary","Get-CFGAggregateDiscoveredResourceCount")
    "OrganizationCustomRuleMetadata_MaximumExecutionFrequency"=@("Write-CFGOrganizationConfigRule")
    "OrganizationManagedRuleMetadata_MaximumExecutionFrequency"=@("Write-CFGOrganizationConfigRule")
    "ResourceIdentifier_ResourceType"=@("Get-CFGAggregateResourceConfig")
    "ResourceType"=@("Get-CFGAggregateDiscoveredResourceList","Get-CFGDiscoveredResource","Get-CFGResourceConfigHistory")
}

_awsArgumentCompleterRegistration $CFG_Completers $CFG_map

$CFG_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CFG.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CFG_SelectMap = @{
    "Select"=@("Get-CFGAggregateResourceConfigBatch",
               "Get-CFGGetResourceConfigBatch",
               "Remove-CFGAggregationAuthorization",
               "Remove-CFGConfigRule",
               "Remove-CFGConfigurationAggregator",
               "Remove-CFGConfigurationRecorder",
               "Remove-CFGConformancePack",
               "Remove-CFGDeliveryChannel",
               "Remove-CFGEvaluationResult",
               "Remove-CFGOrganizationConfigRule",
               "Remove-CFGOrganizationConformancePack",
               "Remove-CFGPendingAggregationRequest",
               "Remove-CFGRemediationConfiguration",
               "Remove-CFGRemediationException",
               "Remove-CFGResourceConfig",
               "Remove-CFGRetentionConfiguration",
               "Submit-CFGConfigSnapshotDelivery",
               "Get-CFGAggregateComplianceByConfigRuleList",
               "Get-CFGAggregationAuthorizationList",
               "Get-CFGComplianceByConfigRule",
               "Get-CFGComplianceByResource",
               "Get-CFGConfigRuleEvaluationStatus",
               "Get-CFGConfigRule",
               "Get-CFGConfigurationAggregatorList",
               "Get-CFGConfigurationAggregatorSourcesStatus",
               "Get-CFGConfigurationRecorder",
               "Get-CFGConfigurationRecorderStatus",
               "Get-CFGConformancePackCompliance",
               "Get-CFGConformancePack",
               "Get-CFGConformancePackStatus",
               "Get-CFGDeliveryChannel",
               "Get-CFGDeliveryChannelStatus",
               "Get-CFGOrganizationConfigRule",
               "Get-CFGOrganizationConfigRuleStatus",
               "Get-CFGOrganizationConformancePack",
               "Get-CFGOrganizationConformancePackStatus",
               "Get-CFGPendingAggregationRequestList",
               "Get-CFGRemediationConfiguration",
               "Get-CFGRemediationException",
               "Get-CFGRemediationExecutionStatus",
               "Get-CFGRetentionConfiguration",
               "Get-CFGAggregateComplianceDetailsByConfigRule",
               "Get-CFGAggregateConfigRuleComplianceSummary",
               "Get-CFGAggregateDiscoveredResourceCount",
               "Get-CFGAggregateResourceConfig",
               "Get-CFGComplianceDetailsByConfigRule",
               "Get-CFGComplianceDetailsByResource",
               "Get-CFGComplianceSummaryByConfigRule",
               "Get-CFGComplianceSummaryByResourceType",
               "Get-CFGConformancePackComplianceDetail",
               "Get-CFGConformancePackComplianceSummary",
               "Get-CFGDiscoveredResourceCount",
               "Get-CFGOrganizationConfigRuleDetailedStatus",
               "Get-CFGOrganizationConformancePackDetailedStatus",
               "Get-CFGResourceConfigHistory",
               "Get-CFGAggregateDiscoveredResourceList",
               "Get-CFGDiscoveredResource",
               "Get-CFGResourceTag",
               "Write-CFGAggregationAuthorization",
               "Write-CFGConfigRule",
               "Write-CFGConfigurationAggregator",
               "Write-CFGConfigurationRecorder",
               "Write-CFGConformancePack",
               "Write-CFGDeliveryChannel",
               "Write-CFGEvaluation",
               "Write-CFGOrganizationConfigRule",
               "Write-CFGOrganizationConformancePack",
               "Write-CFGRemediationConfiguration",
               "Write-CFGRemediationException",
               "Write-CFGResourceConfig",
               "Write-CFGRetentionConfiguration",
               "Select-CFGResourceConfig",
               "Start-CFGConfigRulesEvaluation",
               "Start-CFGConfigurationRecorder",
               "Start-CFGRemediationExecution",
               "Stop-CFGConfigurationRecorder",
               "Add-CFGResourceTag",
               "Remove-CFGResourceTag")
}

_awsArgumentCompleterRegistration $CFG_SelectCompleters $CFG_SelectMap
# Argument completions for service Amazon Connect Service


$CONN_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CONN.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CONN_SelectMap = @{
    "Select"=@("New-CONNUser",
               "Remove-CONNUser",
               "Get-CONNUser",
               "Get-CONNUserHierarchyGroup",
               "Get-CONNUserHierarchyStructure",
               "Get-CONNContactAttribute",
               "Get-CONNCurrentMetricData",
               "Get-CONNFederationToken",
               "Get-CONNMetricData",
               "Get-CONNContactFlowList",
               "Get-CONNHoursOfOperationList",
               "Get-CONNPhoneNumberList",
               "Get-CONNQueueList",
               "Get-CONNRoutingProfileList",
               "Get-CONNSecurityProfileList",
               "Get-CONNResourceTag",
               "Get-CONNUserHierarchyGroupList",
               "Get-CONNUserList",
               "Start-CONNChatContact",
               "Start-CONNOutboundVoiceContact",
               "Stop-CONNContact",
               "Add-CONNResourceTag",
               "Remove-CONNResourceTag",
               "Update-CONNContactAttribute",
               "Update-CONNUserHierarchy",
               "Update-CONNUserIdentityInfo",
               "Update-CONNUserPhoneConfig",
               "Update-CONNUserRoutingProfile",
               "Update-CONNUserSecurityProfile")
}

_awsArgumentCompleterRegistration $CONN_SelectCompleters $CONN_SelectMap
# Argument completions for service Amazon Connect Participant Service


$CONNP_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ConnectParticipant.ScanDirection
        "Get-CONNPTranscript/ScanDirection"
        {
            $v = "BACKWARD","FORWARD"
            break
        }

        # Amazon.ConnectParticipant.SortKey
        "Get-CONNPTranscript/SortOrder"
        {
            $v = "ASCENDING","DESCENDING"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CONNP_map = @{
    "ScanDirection"=@("Get-CONNPTranscript")
    "SortOrder"=@("Get-CONNPTranscript")
}

_awsArgumentCompleterRegistration $CONNP_Completers $CONNP_map

$CONNP_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CONNP.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CONNP_SelectMap = @{
    "Select"=@("New-CONNPParticipantConnection",
               "Disconnect-CONNPParticipant",
               "Get-CONNPTranscript",
               "Send-CONNPEvent",
               "Send-CONNPMessage")
}

_awsArgumentCompleterRegistration $CONNP_SelectCompleters $CONNP_SelectMap
# Argument completions for service AWS Cost and Usage Report


$CUR_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CostAndUsageReport.AWSRegion
        {
            ($_ -eq "Edit-CURReportDefinition/ReportDefinition_S3Region") -Or
            ($_ -eq "Write-CURReportDefinition/ReportDefinition_S3Region")
        }
        {
            $v = "ap-east-1","ap-northeast-1","ap-northeast-3","ap-southeast-1","ap-southeast-2","eu-central-1","eu-north-1","eu-west-1","us-east-1","us-west-1","us-west-2"
            break
        }

        # Amazon.CostAndUsageReport.CompressionFormat
        {
            ($_ -eq "Edit-CURReportDefinition/ReportDefinition_Compression") -Or
            ($_ -eq "Write-CURReportDefinition/ReportDefinition_Compression")
        }
        {
            $v = "GZIP","Parquet","ZIP"
            break
        }

        # Amazon.CostAndUsageReport.ReportFormat
        {
            ($_ -eq "Edit-CURReportDefinition/ReportDefinition_Format") -Or
            ($_ -eq "Write-CURReportDefinition/ReportDefinition_Format")
        }
        {
            $v = "Parquet","textORcsv"
            break
        }

        # Amazon.CostAndUsageReport.ReportVersioning
        {
            ($_ -eq "Edit-CURReportDefinition/ReportDefinition_ReportVersioning") -Or
            ($_ -eq "Write-CURReportDefinition/ReportDefinition_ReportVersioning")
        }
        {
            $v = "CREATE_NEW_REPORT","OVERWRITE_REPORT"
            break
        }

        # Amazon.CostAndUsageReport.TimeUnit
        {
            ($_ -eq "Edit-CURReportDefinition/ReportDefinition_TimeUnit") -Or
            ($_ -eq "Write-CURReportDefinition/ReportDefinition_TimeUnit")
        }
        {
            $v = "DAILY","HOURLY"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CUR_map = @{
    "ReportDefinition_Compression"=@("Edit-CURReportDefinition","Write-CURReportDefinition")
    "ReportDefinition_Format"=@("Edit-CURReportDefinition","Write-CURReportDefinition")
    "ReportDefinition_ReportVersioning"=@("Edit-CURReportDefinition","Write-CURReportDefinition")
    "ReportDefinition_S3Region"=@("Edit-CURReportDefinition","Write-CURReportDefinition")
    "ReportDefinition_TimeUnit"=@("Edit-CURReportDefinition","Write-CURReportDefinition")
}

_awsArgumentCompleterRegistration $CUR_Completers $CUR_map

$CUR_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CUR.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CUR_SelectMap = @{
    "Select"=@("Remove-CURReportDefinition",
               "Get-CURReportDefinition",
               "Edit-CURReportDefinition",
               "Write-CURReportDefinition")
}

_awsArgumentCompleterRegistration $CUR_SelectCompleters $CUR_SelectMap
# Argument completions for service AWS Data Exchange


$DTEX_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.DataExchange.AssetType
        "New-DTEXDataSet/AssetType"
        {
            $v = "S3_SNAPSHOT"
            break
        }

        # Amazon.DataExchange.Type
        "New-DTEXJob/Type"
        {
            $v = "EXPORT_ASSETS_TO_S3","EXPORT_ASSET_TO_SIGNED_URL","IMPORT_ASSETS_FROM_S3","IMPORT_ASSET_FROM_SIGNED_URL"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DTEX_map = @{
    "AssetType"=@("New-DTEXDataSet")
    "Type"=@("New-DTEXJob")
}

_awsArgumentCompleterRegistration $DTEX_Completers $DTEX_map

$DTEX_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.DTEX.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DTEX_SelectMap = @{
    "Select"=@("Stop-DTEXJob",
               "New-DTEXDataSet",
               "New-DTEXJob",
               "New-DTEXRevision",
               "Remove-DTEXAsset",
               "Remove-DTEXDataSet",
               "Remove-DTEXRevision",
               "Get-DTEXAsset",
               "Get-DTEXDataSet",
               "Get-DTEXJob",
               "Get-DTEXRevision",
               "Get-DTEXDataSetRevisionList",
               "Get-DTEXDataSetList",
               "Get-DTEXJobList",
               "Get-DTEXRevisionAssetList",
               "Get-DTEXResourceTag",
               "Start-DTEXJob",
               "Add-DTEXResourceTag",
               "Remove-DTEXResourceTag",
               "Update-DTEXAsset",
               "Update-DTEXDataSet",
               "Update-DTEXRevision")
}

_awsArgumentCompleterRegistration $DTEX_SelectCompleters $DTEX_SelectMap
# Argument completions for service AWS Data Pipeline


$DP_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.DataPipeline.TaskStatus
        "Set-DPTaskStatus/TaskStatus"
        {
            $v = "FAILED","FALSE","FINISHED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DP_map = @{
    "TaskStatus"=@("Set-DPTaskStatus")
}

_awsArgumentCompleterRegistration $DP_Completers $DP_map

$DP_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.DP.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DP_SelectMap = @{
    "Select"=@("Enable-DPPipeline",
               "Add-DPResourceTag",
               "New-DPPipeline",
               "Disable-DPPipeline",
               "Remove-DPPipeline",
               "Get-DPObject",
               "Get-DPPipelineDescription",
               "Invoke-DPExpression",
               "Get-DPPipelineDefinition",
               "Get-DPPipeline",
               "Get-DPTask",
               "Write-DPPipelineDefinition",
               "Find-DPObject",
               "Remove-DPResourceTag",
               "Update-DPTaskProgress",
               "Update-DPTaskRunnerHeartbeat",
               "Set-DPStatus",
               "Set-DPTaskStatus",
               "Test-DPPipelineDefinition")
}

_awsArgumentCompleterRegistration $DP_SelectCompleters $DP_SelectMap
# Argument completions for service AWS DataSync


$DSYN_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.DataSync.NfsVersion
        "New-DSYNLocationNfs/MountOptions_Version"
        {
            $v = "AUTOMATIC","NFS3","NFS4_0","NFS4_1"
            break
        }

        # Amazon.DataSync.S3StorageClass
        "New-DSYNLocationS3/S3StorageClass"
        {
            $v = "DEEP_ARCHIVE","GLACIER","INTELLIGENT_TIERING","ONEZONE_IA","STANDARD","STANDARD_IA"
            break
        }

        # Amazon.DataSync.SmbVersion
        "New-DSYNLocationSmb/MountOptions_Version"
        {
            $v = "AUTOMATIC","SMB2","SMB3"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DSYN_map = @{
    "MountOptions_Version"=@("New-DSYNLocationNfs","New-DSYNLocationSmb")
    "S3StorageClass"=@("New-DSYNLocationS3")
}

_awsArgumentCompleterRegistration $DSYN_Completers $DSYN_map

$DSYN_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.DSYN.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DSYN_SelectMap = @{
    "Select"=@("Stop-DSYNTaskExecution",
               "New-DSYNAgent",
               "New-DSYNLocationEfs",
               "New-DSYNLocationNfs",
               "New-DSYNLocationS3",
               "New-DSYNLocationSmb",
               "New-DSYNTask",
               "Remove-DSYNAgent",
               "Remove-DSYNLocation",
               "Remove-DSYNTask",
               "Get-DSYNAgent",
               "Get-DSYNLocationEfs",
               "Get-DSYNLocationNfs",
               "Get-DSYNLocationS3",
               "Get-DSYNLocationSmb",
               "Get-DSYNTask",
               "Get-DSYNTaskExecution",
               "Get-DSYNAgentList",
               "Get-DSYNLocationList",
               "Get-DSYNResourceTagList",
               "Get-DSYNTaskExecutionList",
               "Get-DSYNTaskList",
               "Start-DSYNTaskExecution",
               "Add-DSYNResourceTag",
               "Remove-DSYNResourceTag",
               "Update-DSYNAgent",
               "Update-DSYNTask")
}

_awsArgumentCompleterRegistration $DSYN_SelectCompleters $DSYN_SelectMap
# Argument completions for service Amazon DynamoDB Accelerator (DAX)


$DAX_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.DAX.SourceType
        "Get-DAXEvent/SourceType"
        {
            $v = "CLUSTER","PARAMETER_GROUP","SUBNET_GROUP"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DAX_map = @{
    "SourceType"=@("Get-DAXEvent")
}

_awsArgumentCompleterRegistration $DAX_Completers $DAX_map

$DAX_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.DAX.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DAX_SelectMap = @{
    "Select"=@("New-DAXCluster",
               "New-DAXParameterGroup",
               "New-DAXSubnetGroup",
               "Set-DAXReplicationFactorDecrease",
               "Remove-DAXCluster",
               "Remove-DAXParameterGroup",
               "Remove-DAXSubnetGroup",
               "Get-DAXCluster",
               "Get-DAXDefaultParameter",
               "Get-DAXEvent",
               "Get-DAXParameterGroup",
               "Get-DAXParameter",
               "Get-DAXSubnetGroup",
               "Set-DAXReplicationFactorIncrease",
               "Get-DAXResourceTag",
               "Restart-DAXNode",
               "Add-DAXResourceTag",
               "Remove-DAXResourceTag",
               "Update-DAXCluster",
               "Update-DAXParameterGroup",
               "Update-DAXSubnetGroup")
}

_awsArgumentCompleterRegistration $DAX_SelectCompleters $DAX_SelectMap
# Argument completions for service AWS Device Farm


$DF_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.DeviceFarm.ArtifactCategory
        "Get-DFArtifactList/Type"
        {
            $v = "FILE","LOG","SCREENSHOT"
            break
        }

        # Amazon.DeviceFarm.BillingMethod
        {
            ($_ -eq "Get-DFDevicePoolCompatibility/Configuration_BillingMethod") -Or
            ($_ -eq "New-DFRemoteAccessSession/Configuration_BillingMethod") -Or
            ($_ -eq "Submit-DFTestRun/Configuration_BillingMethod")
        }
        {
            $v = "METERED","UNMETERED"
            break
        }

        # Amazon.DeviceFarm.DevicePoolType
        "Get-DFDevicePoolList/Type"
        {
            $v = "CURATED","PRIVATE"
            break
        }

        # Amazon.DeviceFarm.InteractionMode
        "New-DFRemoteAccessSession/InteractionMode"
        {
            $v = "INTERACTIVE","NO_VIDEO","VIDEO_ONLY"
            break
        }

        # Amazon.DeviceFarm.NetworkProfileType
        {
            ($_ -eq "Get-DFNetworkProfileList/Type") -Or
            ($_ -eq "New-DFNetworkProfile/Type") -Or
            ($_ -eq "Update-DFNetworkProfile/Type")
        }
        {
            $v = "CURATED","PRIVATE"
            break
        }

        # Amazon.DeviceFarm.TestType
        {
            ($_ -eq "Get-DFDevicePoolCompatibility/Test_Type") -Or
            ($_ -eq "Submit-DFTestRun/Test_Type") -Or
            ($_ -eq "Get-DFDevicePoolCompatibility/TestType")
        }
        {
            $v = "APPIUM_JAVA_JUNIT","APPIUM_JAVA_TESTNG","APPIUM_NODE","APPIUM_PYTHON","APPIUM_RUBY","APPIUM_WEB_JAVA_JUNIT","APPIUM_WEB_JAVA_TESTNG","APPIUM_WEB_NODE","APPIUM_WEB_PYTHON","APPIUM_WEB_RUBY","BUILTIN_EXPLORER","BUILTIN_FUZZ","CALABASH","INSTRUMENTATION","REMOTE_ACCESS_RECORD","REMOTE_ACCESS_REPLAY","UIAUTOMATION","UIAUTOMATOR","WEB_PERFORMANCE_PROFILE","XCTEST","XCTEST_UI"
            break
        }

        # Amazon.DeviceFarm.UploadType
        {
            ($_ -eq "Get-DFUploadList/Type") -Or
            ($_ -eq "New-DFUpload/Type")
        }
        {
            $v = "ANDROID_APP","APPIUM_JAVA_JUNIT_TEST_PACKAGE","APPIUM_JAVA_JUNIT_TEST_SPEC","APPIUM_JAVA_TESTNG_TEST_PACKAGE","APPIUM_JAVA_TESTNG_TEST_SPEC","APPIUM_NODE_TEST_PACKAGE","APPIUM_NODE_TEST_SPEC","APPIUM_PYTHON_TEST_PACKAGE","APPIUM_PYTHON_TEST_SPEC","APPIUM_RUBY_TEST_PACKAGE","APPIUM_RUBY_TEST_SPEC","APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE","APPIUM_WEB_JAVA_JUNIT_TEST_SPEC","APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE","APPIUM_WEB_JAVA_TESTNG_TEST_SPEC","APPIUM_WEB_NODE_TEST_PACKAGE","APPIUM_WEB_NODE_TEST_SPEC","APPIUM_WEB_PYTHON_TEST_PACKAGE","APPIUM_WEB_PYTHON_TEST_SPEC","APPIUM_WEB_RUBY_TEST_PACKAGE","APPIUM_WEB_RUBY_TEST_SPEC","CALABASH_TEST_PACKAGE","EXTERNAL_DATA","INSTRUMENTATION_TEST_PACKAGE","INSTRUMENTATION_TEST_SPEC","IOS_APP","UIAUTOMATION_TEST_PACKAGE","UIAUTOMATOR_TEST_PACKAGE","WEB_APP","XCTEST_TEST_PACKAGE","XCTEST_UI_TEST_PACKAGE","XCTEST_UI_TEST_SPEC"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DF_map = @{
    "Configuration_BillingMethod"=@("Get-DFDevicePoolCompatibility","New-DFRemoteAccessSession","Submit-DFTestRun")
    "InteractionMode"=@("New-DFRemoteAccessSession")
    "Test_Type"=@("Get-DFDevicePoolCompatibility","Submit-DFTestRun")
    "TestType"=@("Get-DFDevicePoolCompatibility")
    "Type"=@("Get-DFArtifactList","Get-DFDevicePoolList","Get-DFNetworkProfileList","Get-DFUploadList","New-DFNetworkProfile","New-DFUpload","Update-DFNetworkProfile")
}

_awsArgumentCompleterRegistration $DF_Completers $DF_map

$DF_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.DF.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DF_SelectMap = @{
    "Select"=@("New-DFDevicePool",
               "New-DFInstanceProfile",
               "New-DFNetworkProfile",
               "New-DFProject",
               "New-DFRemoteAccessSession",
               "New-DFUpload",
               "New-DFVPCEConfiguration",
               "Remove-DFDevicePool",
               "Remove-DFInstanceProfile",
               "Remove-DFNetworkProfile",
               "Remove-DFProject",
               "Remove-DFRemoteAccessSession",
               "Remove-DFRun",
               "Remove-DFUpload",
               "Remove-DFVPCEConfiguration",
               "Get-DFAccountSettingList",
               "Get-DFDevice",
               "Get-DFDeviceInstance",
               "Get-DFDevicePool",
               "Get-DFDevicePoolCompatibility",
               "Get-DFInstanceProfile",
               "Get-DFJob",
               "Get-DFNetworkProfile",
               "Get-DFOfferingStatus",
               "Get-DFProject",
               "Get-DFRemoteAccessSession",
               "Get-DFRun",
               "Get-DFSuite",
               "Get-DFTest",
               "Get-DFUpload",
               "Get-DFVPCEConfiguration",
               "Install-DFToRemoteAccessSession",
               "Get-DFArtifactList",
               "Get-DFDeviceInstanceList",
               "Get-DFDevicePoolList",
               "Get-DFDeviceList",
               "Get-DFInstanceProfileList",
               "Get-DFJobList",
               "Get-DFNetworkProfileList",
               "Get-DFOfferingPromotion",
               "Get-DFOffering",
               "Get-DFOfferingTransaction",
               "Get-DFProjectList",
               "Get-DFRemoteAccessSessionList",
               "Get-DFRunList",
               "Get-DFSampleList",
               "Get-DFSuiteList",
               "Get-DFResourceTag",
               "Get-DFTestList",
               "Get-DFUniqueProblemList",
               "Get-DFUploadList",
               "Get-DFVPCEConfigurationList",
               "New-DFOfferingPurchase",
               "New-DFOfferingRenewal",
               "Submit-DFTestRun",
               "Stop-DFJob",
               "Stop-DFRemoteAccessSession",
               "Stop-DFRun",
               "Add-DFResourceTag",
               "Remove-DFResourceTag",
               "Update-DFDeviceInstance",
               "Update-DFDevicePool",
               "Update-DFInstanceProfile",
               "Update-DFNetworkProfile",
               "Update-DFProject",
               "Update-DFUpload",
               "Update-DFVPCEConfiguration")
}

_awsArgumentCompleterRegistration $DF_SelectCompleters $DF_SelectMap
# Argument completions for service AWS Direct Connect


$DC_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.DirectConnect.AddressFamily
        {
            ($_ -eq "New-DCBGPPeer/NewBGPPeer_AddressFamily") -Or
            ($_ -eq "New-DCPrivateVirtualInterface/NewPrivateVirtualInterface_AddressFamily") -Or
            ($_ -eq "Enable-DCPrivateVirtualInterface/NewPrivateVirtualInterfaceAllocation_AddressFamily") -Or
            ($_ -eq "New-DCPublicVirtualInterface/NewPublicVirtualInterface_AddressFamily") -Or
            ($_ -eq "Enable-DCPublicVirtualInterface/NewPublicVirtualInterfaceAllocation_AddressFamily") -Or
            ($_ -eq "New-DCTransitVirtualInterface/NewTransitVirtualInterface_AddressFamily") -Or
            ($_ -eq "Enable-DCTransitVirtualInterface/NewTransitVirtualInterfaceAllocation_AddressFamily")
        }
        {
            $v = "ipv4","ipv6"
            break
        }

        # Amazon.DirectConnect.LoaContentType
        {
            ($_ -eq "Get-DCConnectionLoa/LoaContentType") -Or
            ($_ -eq "Get-DCInterconnectLoa/LoaContentType") -Or
            ($_ -eq "Get-DCLoa/LoaContentType")
        }
        {
            $v = "application/pdf"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DC_map = @{
    "LoaContentType"=@("Get-DCConnectionLoa","Get-DCInterconnectLoa","Get-DCLoa")
    "NewBGPPeer_AddressFamily"=@("New-DCBGPPeer")
    "NewPrivateVirtualInterface_AddressFamily"=@("New-DCPrivateVirtualInterface")
    "NewPrivateVirtualInterfaceAllocation_AddressFamily"=@("Enable-DCPrivateVirtualInterface")
    "NewPublicVirtualInterface_AddressFamily"=@("New-DCPublicVirtualInterface")
    "NewPublicVirtualInterfaceAllocation_AddressFamily"=@("Enable-DCPublicVirtualInterface")
    "NewTransitVirtualInterface_AddressFamily"=@("New-DCTransitVirtualInterface")
    "NewTransitVirtualInterfaceAllocation_AddressFamily"=@("Enable-DCTransitVirtualInterface")
}

_awsArgumentCompleterRegistration $DC_Completers $DC_map

$DC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.DC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DC_SelectMap = @{
    "Select"=@("Confirm-DCDirectConnectGatewayAssociationProposal",
               "Enable-DCConnectionOnInterconnect",
               "New-DCHostedConnection",
               "Enable-DCPrivateVirtualInterface",
               "Enable-DCPublicVirtualInterface",
               "Enable-DCTransitVirtualInterface",
               "Register-DCConnectionWithLag",
               "Register-DCHostedConnection",
               "Register-DCVirtualInterface",
               "Confirm-DCConnection",
               "Confirm-DCPrivateVirtualInterface",
               "Confirm-DCPublicVirtualInterface",
               "Confirm-DCTransitVirtualInterface",
               "New-DCBGPPeer",
               "New-DCConnection",
               "New-DCGateway",
               "New-DCGatewayAssociation",
               "New-DCDirectConnectGatewayAssociationProposal",
               "New-DCInterconnect",
               "New-DCLag",
               "New-DCPrivateVirtualInterface",
               "New-DCPublicVirtualInterface",
               "New-DCTransitVirtualInterface",
               "Remove-DCBGPPeer",
               "Remove-DCConnection",
               "Remove-DCGateway",
               "Remove-DCGatewayAssociation",
               "Remove-DCDirectConnectGatewayAssociationProposal",
               "Remove-DCInterconnect",
               "Remove-DCLag",
               "Remove-DCVirtualInterface",
               "Get-DCConnectionLoa",
               "Get-DCConnection",
               "Get-DCConnectionsOnInterconnect",
               "Get-DCDirectConnectGatewayAssociationProposal",
               "Get-DCGatewayAssociation",
               "Get-DCGatewayAttachment",
               "Get-DCGateway",
               "Get-DCHostedConnection",
               "Get-DCInterconnectLoa",
               "Get-DCInterconnect",
               "Get-DCLag",
               "Get-DCLoa",
               "Get-DCLocation",
               "Get-DCResourceTag",
               "Get-DCVirtualGateway",
               "Get-DCVirtualInterface",
               "Unregister-DCConnectionFromLag",
               "Add-DCResourceTag",
               "Remove-DCResourceTag",
               "Update-DCDirectConnectGatewayAssociation",
               "Update-DCLag",
               "Update-DCVirtualInterfaceAttribute")
}

_awsArgumentCompleterRegistration $DC_SelectCompleters $DC_SelectMap
# Argument completions for service AWS Application Discovery Service


$ADS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ApplicationDiscoveryService.ConfigurationItemType
        "Get-ADSConfigurationList/ConfigurationType"
        {
            $v = "APPLICATION","CONNECTION","PROCESS","SERVER"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ADS_map = @{
    "ConfigurationType"=@("Get-ADSConfigurationList")
}

_awsArgumentCompleterRegistration $ADS_Completers $ADS_map

$ADS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ADS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ADS_SelectMap = @{
    "Select"=@("Add-ADSConfigurationItemsToApplication",
               "Remove-ADSImportDataBatch",
               "New-ADSApplication",
               "New-ADSTag",
               "Remove-ADSApplication",
               "Remove-ADSTag",
               "Get-ADSAgent",
               "Get-ADSConfiguration",
               "Get-ADSContinuousExport",
               "Get-ADSExportConfiguration",
               "Get-ADSExportTask",
               "Get-ADSImportTask",
               "Get-ADSTag",
               "Remove-ADSConfigurationItemsFromApplication",
               "Get-ADSExportConfigurationsId",
               "Get-ADSDiscoverySummary",
               "Get-ADSConfigurationList",
               "Get-ADSServerNeighborList",
               "Start-ADSContinuousExport",
               "Start-ADSDataCollectionByAgentId",
               "Start-ADSExportTask",
               "Start-ADSImportTask",
               "Stop-ADSContinuousExport",
               "Stop-ADSDataCollectionByAgentId",
               "Update-ADSApplication")
}

_awsArgumentCompleterRegistration $ADS_SelectCompleters $ADS_SelectMap
# Argument completions for service Amazon Data Lifecycle Manager


$DLM_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.DLM.GettablePolicyStateValues
        "Get-DLMLifecyclePolicySummary/State"
        {
            $v = "DISABLED","ENABLED","ERROR"
            break
        }

        # Amazon.DLM.PolicyTypeValues
        {
            ($_ -eq "New-DLMLifecyclePolicy/PolicyDetails_PolicyType") -Or
            ($_ -eq "Update-DLMLifecyclePolicy/PolicyDetails_PolicyType")
        }
        {
            $v = "EBS_SNAPSHOT_MANAGEMENT"
            break
        }

        # Amazon.DLM.SettablePolicyStateValues
        {
            ($_ -eq "New-DLMLifecyclePolicy/State") -Or
            ($_ -eq "Update-DLMLifecyclePolicy/State")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DLM_map = @{
    "PolicyDetails_PolicyType"=@("New-DLMLifecyclePolicy","Update-DLMLifecyclePolicy")
    "State"=@("Get-DLMLifecyclePolicySummary","New-DLMLifecyclePolicy","Update-DLMLifecyclePolicy")
}

_awsArgumentCompleterRegistration $DLM_Completers $DLM_map

$DLM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.DLM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DLM_SelectMap = @{
    "Select"=@("New-DLMLifecyclePolicy",
               "Remove-DLMLifecyclePolicy",
               "Get-DLMLifecyclePolicySummary",
               "Get-DLMLifecyclePolicy",
               "Get-DLMResourceTag",
               "Add-DLMResourceTag",
               "Remove-DLMResourceTag",
               "Update-DLMLifecyclePolicy")
}

_awsArgumentCompleterRegistration $DLM_SelectCompleters $DLM_SelectMap
# Argument completions for service AWS Database Migration Service


$DMS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.DatabaseMigrationService.AuthMechanismValue
        {
            ($_ -eq "Edit-DMSEndpoint/MongoDbSettings_AuthMechanism") -Or
            ($_ -eq "New-DMSEndpoint/MongoDbSettings_AuthMechanism")
        }
        {
            $v = "default","mongodb_cr","scram_sha_1"
            break
        }

        # Amazon.DatabaseMigrationService.AuthTypeValue
        {
            ($_ -eq "Edit-DMSEndpoint/MongoDbSettings_AuthType") -Or
            ($_ -eq "New-DMSEndpoint/MongoDbSettings_AuthType")
        }
        {
            $v = "no","password"
            break
        }

        # Amazon.DatabaseMigrationService.CompressionTypeValue
        {
            ($_ -eq "Edit-DMSEndpoint/S3Settings_CompressionType") -Or
            ($_ -eq "New-DMSEndpoint/S3Settings_CompressionType")
        }
        {
            $v = "gzip","none"
            break
        }

        # Amazon.DatabaseMigrationService.DataFormatValue
        {
            ($_ -eq "Edit-DMSEndpoint/S3Settings_DataFormat") -Or
            ($_ -eq "New-DMSEndpoint/S3Settings_DataFormat")
        }
        {
            $v = "csv","parquet"
            break
        }

        # Amazon.DatabaseMigrationService.DmsSslModeValue
        {
            ($_ -eq "Edit-DMSEndpoint/SslMode") -Or
            ($_ -eq "New-DMSEndpoint/SslMode")
        }
        {
            $v = "none","require","verify-ca","verify-full"
            break
        }

        # Amazon.DatabaseMigrationService.EncodingTypeValue
        {
            ($_ -eq "Edit-DMSEndpoint/S3Settings_EncodingType") -Or
            ($_ -eq "New-DMSEndpoint/S3Settings_EncodingType")
        }
        {
            $v = "plain","plain-dictionary","rle-dictionary"
            break
        }

        # Amazon.DatabaseMigrationService.EncryptionModeValue
        {
            ($_ -eq "Edit-DMSEndpoint/RedshiftSettings_EncryptionMode") -Or
            ($_ -eq "New-DMSEndpoint/RedshiftSettings_EncryptionMode") -Or
            ($_ -eq "Edit-DMSEndpoint/S3Settings_EncryptionMode") -Or
            ($_ -eq "New-DMSEndpoint/S3Settings_EncryptionMode")
        }
        {
            $v = "sse-kms","sse-s3"
            break
        }

        # Amazon.DatabaseMigrationService.MessageFormatValue
        {
            ($_ -eq "Edit-DMSEndpoint/KinesisSettings_MessageFormat") -Or
            ($_ -eq "New-DMSEndpoint/KinesisSettings_MessageFormat")
        }
        {
            $v = "json"
            break
        }

        # Amazon.DatabaseMigrationService.MigrationTypeValue
        {
            ($_ -eq "Edit-DMSReplicationTask/MigrationType") -Or
            ($_ -eq "New-DMSReplicationTask/MigrationType")
        }
        {
            $v = "cdc","full-load","full-load-and-cdc"
            break
        }

        # Amazon.DatabaseMigrationService.NestingLevelValue
        {
            ($_ -eq "Edit-DMSEndpoint/MongoDbSettings_NestingLevel") -Or
            ($_ -eq "New-DMSEndpoint/MongoDbSettings_NestingLevel")
        }
        {
            $v = "none","one"
            break
        }

        # Amazon.DatabaseMigrationService.ParquetVersionValue
        {
            ($_ -eq "Edit-DMSEndpoint/S3Settings_ParquetVersion") -Or
            ($_ -eq "New-DMSEndpoint/S3Settings_ParquetVersion")
        }
        {
            $v = "parquet-1-0","parquet-2-0"
            break
        }

        # Amazon.DatabaseMigrationService.ReloadOptionValue
        "Restore-DMSTable/ReloadOption"
        {
            $v = "data-reload","validate-only"
            break
        }

        # Amazon.DatabaseMigrationService.ReplicationEndpointTypeValue
        {
            ($_ -eq "Edit-DMSEndpoint/EndpointType") -Or
            ($_ -eq "New-DMSEndpoint/EndpointType")
        }
        {
            $v = "source","target"
            break
        }

        # Amazon.DatabaseMigrationService.SourceType
        "Get-DMSEvent/SourceType"
        {
            $v = "replication-instance"
            break
        }

        # Amazon.DatabaseMigrationService.StartReplicationTaskTypeValue
        "Start-DMSReplicationTask/StartReplicationTaskType"
        {
            $v = "reload-target","resume-processing","start-replication"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DMS_map = @{
    "EndpointType"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "KinesisSettings_MessageFormat"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "MigrationType"=@("Edit-DMSReplicationTask","New-DMSReplicationTask")
    "MongoDbSettings_AuthMechanism"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "MongoDbSettings_AuthType"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "MongoDbSettings_NestingLevel"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "RedshiftSettings_EncryptionMode"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "ReloadOption"=@("Restore-DMSTable")
    "S3Settings_CompressionType"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "S3Settings_DataFormat"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "S3Settings_EncodingType"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "S3Settings_EncryptionMode"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "S3Settings_ParquetVersion"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "SourceType"=@("Get-DMSEvent")
    "SslMode"=@("Edit-DMSEndpoint","New-DMSEndpoint")
    "StartReplicationTaskType"=@("Start-DMSReplicationTask")
}

_awsArgumentCompleterRegistration $DMS_Completers $DMS_map

$DMS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.DMS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DMS_SelectMap = @{
    "Select"=@("Set-DMSResourceTag",
               "Complete-DMSPendingMaintenanceAction",
               "New-DMSEndpoint",
               "New-DMSEventSubscription",
               "New-DMSReplicationInstance",
               "New-DMSReplicationSubnetGroup",
               "New-DMSReplicationTask",
               "Remove-DMSCertificate",
               "Remove-DMSConnection",
               "Remove-DMSEndpoint",
               "Remove-DMSEventSubscription",
               "Remove-DMSReplicationInstance",
               "Remove-DMSReplicationSubnetGroup",
               "Remove-DMSReplicationTask",
               "Get-DMSAccountAttribute",
               "Get-DMSCertificate",
               "Get-DMSConnection",
               "Get-DMSEndpoint",
               "Get-DMSEndpointType",
               "Get-DMSEventCategory",
               "Get-DMSEvent",
               "Get-DMSEventSubscription",
               "Get-DMSOrderableReplicationInstance",
               "Get-DMSPendingMaintenanceAction",
               "Get-DMSRefreshSchemasStatus",
               "Get-DMSReplicationInstance",
               "Get-DMSReplicationInstanceTaskLog",
               "Get-DMSReplicationSubnetGroup",
               "Get-DMSReplicationTaskAssessmentResult",
               "Get-DMSReplicationTask",
               "Get-DMSSchema",
               "Get-DMSTableStatistic",
               "Import-DMSCertificate",
               "Get-DMSResourceTag",
               "Edit-DMSEndpoint",
               "Edit-DMSEventSubscription",
               "Edit-DMSReplicationInstance",
               "Edit-DMSReplicationSubnetGroup",
               "Edit-DMSReplicationTask",
               "Restart-DMSReplicationInstance",
               "Invoke-DMSSchemaRefresh",
               "Restore-DMSTable",
               "Remove-DMSResourceTag",
               "Start-DMSReplicationTask",
               "Start-DMSReplicationTaskAssessment",
               "Stop-DMSReplicationTask",
               "Test-DMSConnection")
}

_awsArgumentCompleterRegistration $DMS_SelectCompleters $DMS_SelectMap
# Argument completions for service Amazon DocumentDB (with MongoDB compatibility)


$DOC_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.DocDB.SourceType
        "Get-DOCEvent/SourceType"
        {
            $v = "db-cluster","db-cluster-snapshot","db-instance","db-parameter-group","db-security-group","db-snapshot"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DOC_map = @{
    "SourceType"=@("Get-DOCEvent")
}

_awsArgumentCompleterRegistration $DOC_Completers $DOC_map

$DOC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.DOC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DOC_SelectMap = @{
    "Select"=@("Add-DOCResourceTag",
               "Complete-DOCPendingMaintenanceAction",
               "Copy-DOCDBClusterParameterGroup",
               "Copy-DOCDBClusterSnapshot",
               "New-DOCDBCluster",
               "New-DOCDBClusterParameterGroup",
               "New-DOCDBClusterSnapshot",
               "New-DOCDBInstance",
               "New-DOCDBSubnetGroup",
               "Remove-DOCDBCluster",
               "Remove-DOCDBClusterParameterGroup",
               "Remove-DOCDBClusterSnapshot",
               "Remove-DOCDBInstance",
               "Remove-DOCDBSubnetGroup",
               "Get-DOCCertificate",
               "Get-DOCDBClusterParameterGroup",
               "Get-DOCDBClusterParameter",
               "Get-DOCDBCluster",
               "Get-DOCDBClusterSnapshotAttribute",
               "Get-DOCDBClusterSnapshot",
               "Get-DOCDBEngineVersion",
               "Get-DOCDBInstance",
               "Get-DOCDBSubnetGroup",
               "Get-DOCEngineDefaultClusterParameter",
               "Get-DOCEventCategory",
               "Get-DOCEvent",
               "Get-DOCOrderableDBInstanceOption",
               "Get-DOCPendingMaintenanceAction",
               "Start-DOCDBClusterFailover",
               "Get-DOCResourceTag",
               "Edit-DOCDBCluster",
               "Edit-DOCDBClusterParameterGroup",
               "Edit-DOCDBClusterSnapshotAttribute",
               "Edit-DOCDBInstance",
               "Edit-DOCDBSubnetGroup",
               "Restart-DOCDBInstance",
               "Remove-DOCResourceTag",
               "Reset-DOCDBClusterParameterGroup",
               "Restore-DOCDBClusterFromSnapshot",
               "Restore-DOCDBClusterToPointInTime",
               "Start-DOCDBCluster",
               "Stop-DOCDBCluster")
}

_awsArgumentCompleterRegistration $DOC_SelectCompleters $DOC_SelectMap
# Argument completions for service AWS Directory Service


$DS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.DirectoryService.DirectoryEdition
        "New-DSMicrosoftAD/Edition"
        {
            $v = "Enterprise","Standard"
            break
        }

        # Amazon.DirectoryService.DirectorySize
        {
            ($_ -eq "Connect-DSDirectory/Size") -Or
            ($_ -eq "New-DSDirectory/Size")
        }
        {
            $v = "Large","Small"
            break
        }

        # Amazon.DirectoryService.LDAPSType
        {
            ($_ -eq "Disable-DSLDAPS/Type") -Or
            ($_ -eq "Enable-DSLDAPS/Type") -Or
            ($_ -eq "Get-DSLDAPSSetting/Type")
        }
        {
            $v = "Client"
            break
        }

        # Amazon.DirectoryService.RadiusAuthenticationProtocol
        {
            ($_ -eq "Enable-DSRadius/RadiusSettings_AuthenticationProtocol") -Or
            ($_ -eq "Update-DSRadius/RadiusSettings_AuthenticationProtocol")
        }
        {
            $v = "CHAP","MS-CHAPv1","MS-CHAPv2","PAP"
            break
        }

        # Amazon.DirectoryService.SelectiveAuth
        {
            ($_ -eq "New-DSTrust/SelectiveAuth") -Or
            ($_ -eq "Update-DSTrust/SelectiveAuth")
        }
        {
            $v = "Disabled","Enabled"
            break
        }

        # Amazon.DirectoryService.ShareMethod
        "Enable-DSDirectoryShare/ShareMethod"
        {
            $v = "HANDSHAKE","ORGANIZATIONS"
            break
        }

        # Amazon.DirectoryService.TargetType
        {
            ($_ -eq "Enable-DSDirectoryShare/ShareTarget_Type") -Or
            ($_ -eq "Disable-DSDirectoryShare/UnshareTarget_Type")
        }
        {
            $v = "ACCOUNT"
            break
        }

        # Amazon.DirectoryService.TrustDirection
        "New-DSTrust/TrustDirection"
        {
            $v = "One-Way: Incoming","One-Way: Outgoing","Two-Way"
            break
        }

        # Amazon.DirectoryService.TrustType
        "New-DSTrust/TrustType"
        {
            $v = "External","Forest"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DS_map = @{
    "Edition"=@("New-DSMicrosoftAD")
    "RadiusSettings_AuthenticationProtocol"=@("Enable-DSRadius","Update-DSRadius")
    "SelectiveAuth"=@("New-DSTrust","Update-DSTrust")
    "ShareMethod"=@("Enable-DSDirectoryShare")
    "ShareTarget_Type"=@("Enable-DSDirectoryShare")
    "Size"=@("Connect-DSDirectory","New-DSDirectory")
    "TrustDirection"=@("New-DSTrust")
    "TrustType"=@("New-DSTrust")
    "Type"=@("Disable-DSLDAPS","Enable-DSLDAPS","Get-DSLDAPSSetting")
    "UnshareTarget_Type"=@("Disable-DSDirectoryShare")
}

_awsArgumentCompleterRegistration $DS_Completers $DS_map

$DS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.DS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DS_SelectMap = @{
    "Select"=@("Confirm-DSSharedDirectory",
               "Add-DSIpRoute",
               "Add-DSResourceTag",
               "Stop-DSSchemaExtension",
               "Connect-DSDirectory",
               "New-DSAlias",
               "New-DSComputer",
               "New-DSConditionalForwarder",
               "New-DSDirectory",
               "New-DSLogSubscription",
               "New-DSMicrosoftAD",
               "New-DSSnapshot",
               "New-DSTrust",
               "Remove-DSConditionalForwarder",
               "Remove-DSDirectory",
               "Remove-DSLogSubscription",
               "Remove-DSSnapshot",
               "Remove-DSTrust",
               "Unregister-DSCertificate",
               "Unregister-DSEventTopic",
               "Get-DSCertificate",
               "Get-DSConditionalForwarder",
               "Get-DSDirectory",
               "Get-DSDomainControllerList",
               "Get-DSEventTopic",
               "Get-DSLDAPSSetting",
               "Get-DSSharedDirectory",
               "Get-DSSnapshot",
               "Get-DSTrust",
               "Disable-DSLDAPS",
               "Disable-DSRadius",
               "Disable-DSSso",
               "Enable-DSLDAPS",
               "Enable-DSRadius",
               "Enable-DSSso",
               "Get-DSDirectoryLimit",
               "Get-DSSnapshotLimit",
               "Get-DSCertificateList",
               "Get-DSIpRouteList",
               "Get-DSLogSubscriptionList",
               "Get-DSSchemaExtension",
               "Get-DSResourceTag",
               "Register-DSCertificate",
               "Register-DSEventTopic",
               "Deny-DSSharedDirectory",
               "Remove-DSIpRoute",
               "Remove-DSResourceTag",
               "Reset-DSUserPassword",
               "Restore-DSFromSnapshot",
               "Enable-DSDirectoryShare",
               "Start-DSSchemaExtension",
               "Disable-DSDirectoryShare",
               "Update-DSConditionalForwarder",
               "Set-DSDomainControllerCount",
               "Update-DSRadius",
               "Update-DSTrust",
               "Approve-DSTrust")
}

_awsArgumentCompleterRegistration $DS_SelectCompleters $DS_SelectMap
# Argument completions for service Amazon DynamoDB


$DDB_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.DynamoDBv2.BackupTypeFilter
        "Get-DDBBackupList/BackupType"
        {
            $v = "ALL","AWS_BACKUP","SYSTEM","USER"
            break
        }

        # Amazon.DynamoDBv2.BillingMode
        {
            ($_ -eq "Update-DDBTable/BillingMode") -Or
            ($_ -eq "Restore-DDBTableFromBackup/BillingModeOverride") -Or
            ($_ -eq "Restore-DDBTableToPointInTime/BillingModeOverride") -Or
            ($_ -eq "Update-DDBGlobalTableSetting/GlobalTableBillingMode")
        }
        {
            $v = "PAY_PER_REQUEST","PROVISIONED"
            break
        }

        # Amazon.DynamoDBv2.ContributorInsightsAction
        "Update-DDBContributorInsight/ContributorInsightsAction"
        {
            $v = "DISABLE","ENABLE"
            break
        }

        # Amazon.DynamoDBv2.KeyType
        "Add-DDBKeySchema/KeyType"
        {
            $v = "HASH","RANGE"
            break
        }

        # Amazon.DynamoDBv2.ProjectionType
        "Add-DDBIndexSchema/ProjectionType"
        {
            $v = "ALL","INCLUDE","KEYS_ONLY"
            break
        }

        # Amazon.DynamoDBv2.ReturnConsumedCapacity
        {
            ($_ -eq "Get-DDBItemTransactionally/ReturnConsumedCapacity") -Or
            ($_ -eq "Write-DDBItemTransactionally/ReturnConsumedCapacity")
        }
        {
            $v = "INDEXES","NONE","TOTAL"
            break
        }

        # Amazon.DynamoDBv2.ReturnItemCollectionMetrics
        "Write-DDBItemTransactionally/ReturnItemCollectionMetrics"
        {
            $v = "NONE","SIZE"
            break
        }

        # Amazon.DynamoDBv2.ScalarAttributeType
        {
            ($_ -eq "Add-DDBIndexSchema/HashKeyDataType") -Or
            ($_ -eq "Add-DDBKeySchema/KeyDataType") -Or
            ($_ -eq "Add-DDBIndexSchema/RangeKeyDataType")
        }
        {
            $v = "B","N","S"
            break
        }

        # Amazon.DynamoDBv2.SSEType
        "Update-DDBTable/SSESpecification_SSEType"
        {
            $v = "AES256","KMS"
            break
        }

        # Amazon.DynamoDBv2.StreamViewType
        "Update-DDBTable/StreamSpecification_StreamViewType"
        {
            $v = "KEYS_ONLY","NEW_AND_OLD_IMAGES","NEW_IMAGE","OLD_IMAGE"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DDB_map = @{
    "BackupType"=@("Get-DDBBackupList")
    "BillingMode"=@("Update-DDBTable")
    "BillingModeOverride"=@("Restore-DDBTableFromBackup","Restore-DDBTableToPointInTime")
    "ContributorInsightsAction"=@("Update-DDBContributorInsight")
    "GlobalTableBillingMode"=@("Update-DDBGlobalTableSetting")
    "HashKeyDataType"=@("Add-DDBIndexSchema")
    "KeyDataType"=@("Add-DDBKeySchema")
    "KeyType"=@("Add-DDBKeySchema")
    "ProjectionType"=@("Add-DDBIndexSchema")
    "RangeKeyDataType"=@("Add-DDBIndexSchema")
    "ReturnConsumedCapacity"=@("Get-DDBItemTransactionally","Write-DDBItemTransactionally")
    "ReturnItemCollectionMetrics"=@("Write-DDBItemTransactionally")
    "SSESpecification_SSEType"=@("Update-DDBTable")
    "StreamSpecification_StreamViewType"=@("Update-DDBTable")
}

_awsArgumentCompleterRegistration $DDB_Completers $DDB_map

$DDB_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.DDB.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DDB_SelectMap = @{
    "Select"=@("New-DDBBackup",
               "New-DDBGlobalTable",
               "Remove-DDBBackup",
               "Remove-DDBTable",
               "Get-DDBBackup",
               "Get-DDBContinuousBackup",
               "Get-DDBContributorInsight",
               "Get-DDBEndpoint",
               "Get-DDBGlobalTable",
               "Get-DDBGlobalTableSetting",
               "Get-DDBProvisionLimit",
               "Get-DDBTable",
               "Get-DDBTableReplicaAutoScaling",
               "Get-DDBTimeToLive",
               "Get-DDBBackupList",
               "Get-DDBContributorInsightList",
               "Get-DDBGlobalTableList",
               "Get-DDBTableList",
               "Get-DDBResourceTag",
               "Restore-DDBTableFromBackup",
               "Restore-DDBTableToPointInTime",
               "Add-DDBResourceTag",
               "Get-DDBItemTransactionally",
               "Write-DDBItemTransactionally",
               "Remove-DDBResourceTag",
               "Update-DDBContinuousBackup",
               "Update-DDBContributorInsight",
               "Update-DDBGlobalTable",
               "Update-DDBGlobalTableSetting",
               "Update-DDBTable",
               "Update-DDBTableReplicaAutoScaling",
               "Update-DDBTimeToLive",
               "Add-DDBIndexSchema",
               "Add-DDBKeySchema",
               "New-DDBTable",
               "New-DDBTableSchema")
}

_awsArgumentCompleterRegistration $DDB_SelectCompleters $DDB_SelectMap
# Argument completions for service Amazon DynamoDB


$DDB_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.DynamoDBv2.KeyType
        "Add-DDBKeySchema/KeyType"
        {
            $v = "HASH","RANGE"
            break
        }

        # Amazon.DynamoDBv2.ProjectionType
        "Add-DDBIndexSchema/ProjectionType"
        {
            $v = "ALL","INCLUDE","KEYS_ONLY"
            break
        }

        # Amazon.DynamoDBv2.ScalarAttributeType
        {
            ($_ -eq "Add-DDBIndexSchema/HashKeyDataType") -Or
            ($_ -eq "Add-DDBKeySchema/KeyDataType") -Or
            ($_ -eq "Add-DDBIndexSchema/RangeKeyDataType")
        }
        {
            $v = "B","N","S"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DDB_map = @{
    "HashKeyDataType"=@("Add-DDBIndexSchema")
    "KeyDataType"=@("Add-DDBKeySchema")
    "KeyType"=@("Add-DDBKeySchema")
    "ProjectionType"=@("Add-DDBIndexSchema")
    "RangeKeyDataType"=@("Add-DDBIndexSchema")
}

_awsArgumentCompleterRegistration $DDB_Completers $DDB_map

$DDB_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.DDB.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$DDB_SelectMap = @{
    "Select"=@("Get-DDBStream",
               "Get-DDBStreamList",
               "Add-DDBIndexSchema",
               "Add-DDBKeySchema",
               "New-DDBTable",
               "New-DDBTableSchema")
}

_awsArgumentCompleterRegistration $DDB_SelectCompleters $DDB_SelectMap
# Argument completions for service Amazon EBS


$EBS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EBS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EBS_SelectMap = @{
    "Select"=@("Get-EBSSnapshotBlock",
               "Get-EBSChangedBlockList",
               "Get-EBSSnapshotBlockList")
}

_awsArgumentCompleterRegistration $EBS_SelectCompleters $EBS_SelectMap
# Argument completions for service Amazon Elastic Compute Cloud (EC2)


$EC2_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.EC2.Affinity
        "Edit-EC2InstancePlacement/Affinity"
        {
            $v = "default","host"
            break
        }

        # Amazon.EC2.AllocationStrategy
        "Request-EC2SpotFleet/SpotFleetRequestConfig_AllocationStrategy"
        {
            $v = "capacityOptimized","diversified","lowestPrice"
            break
        }

        # Amazon.EC2.ArchitectureValues
        "Register-EC2Image/Architecture"
        {
            $v = "arm64","i386","x86_64"
            break
        }

        # Amazon.EC2.AutoAcceptSharedAttachmentsValue
        "New-EC2TransitGateway/Options_AutoAcceptSharedAttachments"
        {
            $v = "disable","enable"
            break
        }

        # Amazon.EC2.AutoPlacement
        {
            ($_ -eq "Edit-EC2Host/AutoPlacement") -Or
            ($_ -eq "New-EC2Host/AutoPlacement")
        }
        {
            $v = "off","on"
            break
        }

        # Amazon.EC2.CapacityReservationInstancePlatform
        "Add-EC2CapacityReservation/InstancePlatform"
        {
            $v = "Linux with SQL Server Enterprise","Linux with SQL Server Standard","Linux with SQL Server Web","Linux/UNIX","Red Hat Enterprise Linux","SUSE Linux","Windows","Windows with SQL Server","Windows with SQL Server Enterprise","Windows with SQL Server Standard","Windows with SQL Server Web"
            break
        }

        # Amazon.EC2.CapacityReservationPreference
        {
            ($_ -eq "Edit-EC2InstanceCapacityReservationAttribute/CapacityReservationSpecification_CapacityReservationPreference") -Or
            ($_ -eq "New-EC2Instance/CapacityReservationSpecification_CapacityReservationPreference")
        }
        {
            $v = "none","open"
            break
        }

        # Amazon.EC2.CapacityReservationTenancy
        "Add-EC2CapacityReservation/Tenancy"
        {
            $v = "dedicated","default"
            break
        }

        # Amazon.EC2.ContainerFormat
        "New-EC2InstanceExportTask/ExportToS3Task_ContainerFormat"
        {
            $v = "ova"
            break
        }

        # Amazon.EC2.CopyTagsFromSource
        "New-EC2SnapshotBatch/CopyTagsFromSource"
        {
            $v = "volume"
            break
        }

        # Amazon.EC2.CurrencyCodeValues
        {
            ($_ -eq "New-EC2HostReservation/CurrencyCode") -Or
            ($_ -eq "New-EC2ReservedInstance/LimitPrice_CurrencyCode")
        }
        {
            $v = "USD"
            break
        }

        # Amazon.EC2.DefaultRouteTableAssociationValue
        "New-EC2TransitGateway/Options_DefaultRouteTableAssociation"
        {
            $v = "disable","enable"
            break
        }

        # Amazon.EC2.DefaultRouteTablePropagationValue
        "New-EC2TransitGateway/Options_DefaultRouteTablePropagation"
        {
            $v = "disable","enable"
            break
        }

        # Amazon.EC2.DefaultTargetCapacityType
        {
            ($_ -eq "Edit-EC2Fleet/TargetCapacitySpecification_DefaultTargetCapacityType") -Or
            ($_ -eq "New-EC2Fleet/TargetCapacitySpecification_DefaultTargetCapacityType")
        }
        {
            $v = "on-demand","spot"
            break
        }

        # Amazon.EC2.DiskImageFormat
        {
            ($_ -eq "Export-EC2Image/DiskImageFormat") -Or
            ($_ -eq "New-EC2InstanceExportTask/ExportToS3Task_DiskImageFormat")
        }
        {
            $v = "RAW","VHD","VMDK"
            break
        }

        # Amazon.EC2.DnsSupportValue
        {
            ($_ -eq "Edit-EC2TransitGatewayVpcAttachment/Options_DnsSupport") -Or
            ($_ -eq "New-EC2TransitGateway/Options_DnsSupport") -Or
            ($_ -eq "New-EC2TransitGatewayVpcAttachment/Options_DnsSupport")
        }
        {
            $v = "disable","enable"
            break
        }

        # Amazon.EC2.DomainType
        "New-EC2Address/Domain"
        {
            $v = "standard","vpc"
            break
        }

        # Amazon.EC2.EndDateType
        {
            ($_ -eq "Add-EC2CapacityReservation/EndDateType") -Or
            ($_ -eq "Edit-EC2CapacityReservation/EndDateType")
        }
        {
            $v = "limited","unlimited"
            break
        }

        # Amazon.EC2.EventType
        "Get-EC2SpotFleetRequestHistory/EventType"
        {
            $v = "error","fleetRequestChange","information","instanceChange"
            break
        }

        # Amazon.EC2.ExcessCapacityTerminationPolicy
        {
            ($_ -eq "Edit-EC2SpotFleetRequest/ExcessCapacityTerminationPolicy") -Or
            ($_ -eq "Request-EC2SpotFleet/SpotFleetRequestConfig_ExcessCapacityTerminationPolicy")
        }
        {
            $v = "default","noTermination"
            break
        }

        # Amazon.EC2.ExportEnvironment
        "New-EC2InstanceExportTask/TargetEnvironment"
        {
            $v = "citrix","microsoft","vmware"
            break
        }

        # Amazon.EC2.FleetEventType
        "Get-EC2FleetHistory/EventType"
        {
            $v = "fleet-change","instance-change","service-error"
            break
        }

        # Amazon.EC2.FleetExcessCapacityTerminationPolicy
        {
            ($_ -eq "Edit-EC2Fleet/ExcessCapacityTerminationPolicy") -Or
            ($_ -eq "New-EC2Fleet/ExcessCapacityTerminationPolicy")
        }
        {
            $v = "no-termination","termination"
            break
        }

        # Amazon.EC2.FleetOnDemandAllocationStrategy
        "New-EC2Fleet/OnDemandOptions_AllocationStrategy"
        {
            $v = "lowest-price","prioritized"
            break
        }

        # Amazon.EC2.FleetType
        {
            ($_ -eq "Request-EC2SpotFleet/SpotFleetRequestConfig_Type") -Or
            ($_ -eq "New-EC2Fleet/Type")
        }
        {
            $v = "instant","maintain","request"
            break
        }

        # Amazon.EC2.FlowLogsResourceType
        "New-EC2FlowLog/ResourceType"
        {
            $v = "NetworkInterface","Subnet","VPC"
            break
        }

        # Amazon.EC2.FpgaImageAttributeName
        {
            ($_ -eq "Edit-EC2FpgaImageAttribute/Attribute") -Or
            ($_ -eq "Get-EC2FpgaImageAttribute/Attribute")
        }
        {
            $v = "description","loadPermission","name","productCodes"
            break
        }

        # Amazon.EC2.GatewayType
        {
            ($_ -eq "New-EC2CustomerGateway/Type") -Or
            ($_ -eq "New-EC2VpnGateway/Type")
        }
        {
            $v = "ipsec.1"
            break
        }

        # Amazon.EC2.HostRecovery
        {
            ($_ -eq "Edit-EC2Host/HostRecovery") -Or
            ($_ -eq "New-EC2Host/HostRecovery")
        }
        {
            $v = "off","on"
            break
        }

        # Amazon.EC2.HostTenancy
        "Edit-EC2InstancePlacement/Tenancy"
        {
            $v = "dedicated","host"
            break
        }

        # Amazon.EC2.HttpTokensState
        {
            ($_ -eq "Edit-EC2InstanceMetadataOption/HttpTokens") -Or
            ($_ -eq "New-EC2Instance/MetadataOptions_HttpTokens")
        }
        {
            $v = "optional","required"
            break
        }

        # Amazon.EC2.ImageAttributeName
        "Get-EC2ImageAttribute/Attribute"
        {
            $v = "blockDeviceMapping","description","kernel","launchPermission","productCodes","ramdisk","sriovNetSupport"
            break
        }

        # Amazon.EC2.InstanceAttributeName
        {
            ($_ -eq "Edit-EC2InstanceAttribute/Attribute") -Or
            ($_ -eq "Get-EC2InstanceAttribute/Attribute") -Or
            ($_ -eq "Reset-EC2InstanceAttribute/Attribute")
        }
        {
            $v = "blockDeviceMapping","disableApiTermination","ebsOptimized","enaSupport","groupSet","instanceInitiatedShutdownBehavior","instanceType","kernel","productCodes","ramdisk","rootDeviceName","sourceDestCheck","sriovNetSupport","userData"
            break
        }

        # Amazon.EC2.InstanceInterruptionBehavior
        {
            ($_ -eq "Request-EC2SpotInstance/InstanceInterruptionBehavior") -Or
            ($_ -eq "Request-EC2SpotFleet/SpotFleetRequestConfig_InstanceInterruptionBehavior")
        }
        {
            $v = "hibernate","stop","terminate"
            break
        }

        # Amazon.EC2.InstanceMatchCriteria
        "Add-EC2CapacityReservation/InstanceMatchCriteria"
        {
            $v = "open","targeted"
            break
        }

        # Amazon.EC2.InstanceMetadataEndpointState
        {
            ($_ -eq "Edit-EC2InstanceMetadataOption/HttpEndpoint") -Or
            ($_ -eq "New-EC2Instance/MetadataOptions_HttpEndpoint")
        }
        {
            $v = "disabled","enabled"
            break
        }

        # Amazon.EC2.InstanceType
        {
            ($_ -eq "Get-EC2ReservedInstancesOffering/InstanceType") -Or
            ($_ -eq "New-EC2Instance/InstanceType") -Or
            ($_ -eq "Request-EC2SpotInstance/LaunchSpecification_InstanceType")
        }
        {
            $v = "a1.2xlarge","a1.4xlarge","a1.large","a1.medium","a1.metal","a1.xlarge","c1.medium","c1.xlarge","c3.2xlarge","c3.4xlarge","c3.8xlarge","c3.large","c3.xlarge","c4.2xlarge","c4.4xlarge","c4.8xlarge","c4.large","c4.xlarge","c5.12xlarge","c5.18xlarge","c5.24xlarge","c5.2xlarge","c5.4xlarge","c5.9xlarge","c5.large","c5.metal","c5.xlarge","c5d.12xlarge","c5d.18xlarge","c5d.24xlarge","c5d.2xlarge","c5d.4xlarge","c5d.9xlarge","c5d.large","c5d.metal","c5d.xlarge","c5n.18xlarge","c5n.2xlarge","c5n.4xlarge","c5n.9xlarge","c5n.large","c5n.xlarge","cc1.4xlarge","cc2.8xlarge","cg1.4xlarge","cr1.8xlarge","d2.2xlarge","d2.4xlarge","d2.8xlarge","d2.xlarge","f1.16xlarge","f1.2xlarge","f1.4xlarge","g2.2xlarge","g2.8xlarge","g3.16xlarge","g3.4xlarge","g3.8xlarge","g3s.xlarge","g4dn.12xlarge","g4dn.16xlarge","g4dn.2xlarge","g4dn.4xlarge","g4dn.8xlarge","g4dn.xlarge","h1.16xlarge","h1.2xlarge","h1.4xlarge","h1.8xlarge","hi1.4xlarge","hs1.8xlarge","i2.2xlarge","i2.4xlarge","i2.8xlarge","i2.xlarge","i3.16xlarge","i3.2xlarge","i3.4xlarge","i3.8xlarge","i3.large","i3.metal","i3.xlarge","i3en.12xlarge","i3en.24xlarge","i3en.2xlarge","i3en.3xlarge","i3en.6xlarge","i3en.large","i3en.metal","i3en.xlarge","inf1.24xlarge","inf1.2xlarge","inf1.6xlarge","inf1.xlarge","m1.large","m1.medium","m1.small","m1.xlarge","m2.2xlarge","m2.4xlarge","m2.xlarge","m3.2xlarge","m3.large","m3.medium","m3.xlarge","m4.10xlarge","m4.16xlarge","m4.2xlarge","m4.4xlarge","m4.large","m4.xlarge","m5.12xlarge","m5.16xlarge","m5.24xlarge","m5.2xlarge","m5.4xlarge","m5.8xlarge","m5.large","m5.metal","m5.xlarge","m5a.12xlarge","m5a.16xlarge","m5a.24xlarge","m5a.2xlarge","m5a.4xlarge","m5a.8xlarge","m5a.large","m5a.xlarge","m5ad.12xlarge","m5ad.16xlarge","m5ad.24xlarge","m5ad.2xlarge","m5ad.4xlarge","m5ad.8xlarge","m5ad.large","m5ad.xlarge","m5d.12xlarge","m5d.16xlarge","m5d.24xlarge","m5d.2xlarge","m5d.4xlarge","m5d.8xlarge","m5d.large","m5d.metal","m5d.xlarge","m5dn.12xlarge","m5dn.16xlarge","m5dn.24xlarge","m5dn.2xlarge","m5dn.4xlarge","m5dn.8xlarge","m5dn.large","m5dn.xlarge","m5n.12xlarge","m5n.16xlarge","m5n.24xlarge","m5n.2xlarge","m5n.4xlarge","m5n.8xlarge","m5n.large","m5n.xlarge","p2.16xlarge","p2.8xlarge","p2.xlarge","p3.16xlarge","p3.2xlarge","p3.8xlarge","p3dn.24xlarge","r3.2xlarge","r3.4xlarge","r3.8xlarge","r3.large","r3.xlarge","r4.16xlarge","r4.2xlarge","r4.4xlarge","r4.8xlarge","r4.large","r4.xlarge","r5.12xlarge","r5.16xlarge","r5.24xlarge","r5.2xlarge","r5.4xlarge","r5.8xlarge","r5.large","r5.metal","r5.xlarge","r5a.12xlarge","r5a.16xlarge","r5a.24xlarge","r5a.2xlarge","r5a.4xlarge","r5a.8xlarge","r5a.large","r5a.xlarge","r5ad.12xlarge","r5ad.16xlarge","r5ad.24xlarge","r5ad.2xlarge","r5ad.4xlarge","r5ad.8xlarge","r5ad.large","r5ad.xlarge","r5d.12xlarge","r5d.16xlarge","r5d.24xlarge","r5d.2xlarge","r5d.4xlarge","r5d.8xlarge","r5d.large","r5d.metal","r5d.xlarge","r5dn.12xlarge","r5dn.16xlarge","r5dn.24xlarge","r5dn.2xlarge","r5dn.4xlarge","r5dn.8xlarge","r5dn.large","r5dn.xlarge","r5n.12xlarge","r5n.16xlarge","r5n.24xlarge","r5n.2xlarge","r5n.4xlarge","r5n.8xlarge","r5n.large","r5n.xlarge","t1.micro","t2.2xlarge","t2.large","t2.medium","t2.micro","t2.nano","t2.small","t2.xlarge","t3.2xlarge","t3.large","t3.medium","t3.micro","t3.nano","t3.small","t3.xlarge","t3a.2xlarge","t3a.large","t3a.medium","t3a.micro","t3a.nano","t3a.small","t3a.xlarge","u-12tb1.metal","u-18tb1.metal","u-24tb1.metal","u-6tb1.metal","u-9tb1.metal","x1.16xlarge","x1.32xlarge","x1e.16xlarge","x1e.2xlarge","x1e.32xlarge","x1e.4xlarge","x1e.8xlarge","x1e.xlarge","z1d.12xlarge","z1d.2xlarge","z1d.3xlarge","z1d.6xlarge","z1d.large","z1d.metal","z1d.xlarge"
            break
        }

        # Amazon.EC2.InterfacePermissionType
        "New-EC2NetworkInterfacePermission/Permission"
        {
            $v = "EIP-ASSOCIATE","INSTANCE-ATTACH"
            break
        }

        # Amazon.EC2.Ipv6SupportValue
        {
            ($_ -eq "Edit-EC2TransitGatewayVpcAttachment/Options_Ipv6Support") -Or
            ($_ -eq "New-EC2TransitGatewayVpcAttachment/Options_Ipv6Support")
        }
        {
            $v = "disable","enable"
            break
        }

        # Amazon.EC2.LocationType
        "Get-EC2InstanceTypeOffering/LocationType"
        {
            $v = "availability-zone","availability-zone-id","region"
            break
        }

        # Amazon.EC2.LogDestinationType
        "New-EC2FlowLog/LogDestinationType"
        {
            $v = "cloud-watch-logs","s3"
            break
        }

        # Amazon.EC2.MulticastSupportValue
        "New-EC2TransitGateway/Options_MulticastSupport"
        {
            $v = "disable","enable"
            break
        }

        # Amazon.EC2.NetworkInterfaceAttribute
        "Get-EC2NetworkInterfaceAttribute/Attribute"
        {
            $v = "attachment","description","groupSet","sourceDestCheck"
            break
        }

        # Amazon.EC2.NetworkInterfaceCreationType
        "New-EC2NetworkInterface/InterfaceType"
        {
            $v = "efa"
            break
        }

        # Amazon.EC2.OfferingClassType
        {
            ($_ -eq "Get-EC2ReservedInstance/OfferingClass") -Or
            ($_ -eq "Get-EC2ReservedInstancesOffering/OfferingClass")
        }
        {
            $v = "convertible","standard"
            break
        }

        # Amazon.EC2.OfferingTypeValues
        {
            ($_ -eq "Get-EC2ReservedInstance/OfferingType") -Or
            ($_ -eq "Get-EC2ReservedInstancesOffering/OfferingType")
        }
        {
            $v = "All Upfront","Heavy Utilization","Light Utilization","Medium Utilization","No Upfront","Partial Upfront"
            break
        }

        # Amazon.EC2.OnDemandAllocationStrategy
        "Request-EC2SpotFleet/SpotFleetRequestConfig_OnDemandAllocationStrategy"
        {
            $v = "lowestPrice","prioritized"
            break
        }

        # Amazon.EC2.OperationType
        {
            ($_ -eq "Edit-EC2FpgaImageAttribute/OperationType") -Or
            ($_ -eq "Edit-EC2ImageAttribute/OperationType") -Or
            ($_ -eq "Edit-EC2SnapshotAttribute/OperationType")
        }
        {
            $v = "add","remove"
            break
        }

        # Amazon.EC2.PlacementStrategy
        "New-EC2PlacementGroup/Strategy"
        {
            $v = "cluster","partition","spread"
            break
        }

        # Amazon.EC2.ReportStatusType
        "Send-EC2InstanceStatus/Status"
        {
            $v = "impaired","ok"
            break
        }

        # Amazon.EC2.ResetFpgaImageAttributeName
        "Reset-EC2FpgaImageAttribute/Attribute"
        {
            $v = "loadPermission"
            break
        }

        # Amazon.EC2.ResetImageAttributeName
        "Reset-EC2ImageAttribute/Attribute"
        {
            $v = "launchPermission"
            break
        }

        # Amazon.EC2.RIProductDescription
        "Get-EC2ReservedInstancesOffering/ProductDescription"
        {
            $v = "Linux/UNIX","Linux/UNIX (Amazon VPC)","Windows","Windows (Amazon VPC)"
            break
        }

        # Amazon.EC2.RuleAction
        {
            ($_ -eq "New-EC2NetworkAclEntry/RuleAction") -Or
            ($_ -eq "Set-EC2NetworkAclEntry/RuleAction")
        }
        {
            $v = "allow","deny"
            break
        }

        # Amazon.EC2.ShutdownBehavior
        "New-EC2Instance/InstanceInitiatedShutdownBehavior"
        {
            $v = "stop","terminate"
            break
        }

        # Amazon.EC2.SnapshotAttributeName
        {
            ($_ -eq "Edit-EC2SnapshotAttribute/Attribute") -Or
            ($_ -eq "Get-EC2SnapshotAttribute/Attribute") -Or
            ($_ -eq "Reset-EC2SnapshotAttribute/Attribute")
        }
        {
            $v = "createVolumePermission","productCodes"
            break
        }

        # Amazon.EC2.SpotAllocationStrategy
        "New-EC2Fleet/SpotOptions_AllocationStrategy"
        {
            $v = "capacity-optimized","diversified","lowest-price"
            break
        }

        # Amazon.EC2.SpotInstanceInterruptionBehavior
        "New-EC2Fleet/SpotOptions_InstanceInterruptionBehavior"
        {
            $v = "hibernate","stop","terminate"
            break
        }

        # Amazon.EC2.SpotInstanceType
        "Request-EC2SpotInstance/Type"
        {
            $v = "one-time","persistent"
            break
        }

        # Amazon.EC2.Tenancy
        {
            ($_ -eq "Get-EC2ReservedInstancesOffering/InstanceTenancy") -Or
            ($_ -eq "New-EC2Vpc/InstanceTenancy") -Or
            ($_ -eq "Request-EC2SpotInstance/LaunchSpecification_Placement_Tenancy") -Or
            ($_ -eq "New-EC2Instance/Placement_Tenancy")
        }
        {
            $v = "dedicated","default","host"
            break
        }

        # Amazon.EC2.TrafficDirection
        {
            ($_ -eq "Edit-EC2TrafficMirrorFilterRule/TrafficDirection") -Or
            ($_ -eq "New-EC2TrafficMirrorFilterRule/TrafficDirection")
        }
        {
            $v = "egress","ingress"
            break
        }

        # Amazon.EC2.TrafficMirrorRuleAction
        {
            ($_ -eq "Edit-EC2TrafficMirrorFilterRule/RuleAction") -Or
            ($_ -eq "New-EC2TrafficMirrorFilterRule/RuleAction")
        }
        {
            $v = "accept","reject"
            break
        }

        # Amazon.EC2.TrafficType
        "New-EC2FlowLog/TrafficType"
        {
            $v = "ACCEPT","ALL","REJECT"
            break
        }

        # Amazon.EC2.TransportProtocol
        "New-EC2ClientVpnEndpoint/TransportProtocol"
        {
            $v = "tcp","udp"
            break
        }

        # Amazon.EC2.UnlimitedSupportedInstanceFamily
        {
            ($_ -eq "Edit-EC2DefaultCreditSpecification/InstanceFamily") -Or
            ($_ -eq "Get-EC2DefaultCreditSpecification/InstanceFamily")
        }
        {
            $v = "t2","t3","t3a"
            break
        }

        # Amazon.EC2.VolumeAttributeName
        "Get-EC2VolumeAttribute/Attribute"
        {
            $v = "autoEnableIO","productCodes"
            break
        }

        # Amazon.EC2.VolumeType
        {
            ($_ -eq "Edit-EC2Volume/VolumeType") -Or
            ($_ -eq "New-EC2Volume/VolumeType")
        }
        {
            $v = "gp2","io1","sc1","st1","standard"
            break
        }

        # Amazon.EC2.VpcAttributeName
        "Get-EC2VpcAttribute/Attribute"
        {
            $v = "enableDnsHostnames","enableDnsSupport"
            break
        }

        # Amazon.EC2.VpcEndpointType
        "New-EC2VpcEndpoint/VpcEndpointType"
        {
            $v = "Gateway","Interface"
            break
        }

        # Amazon.EC2.VpcTenancy
        "Edit-EC2VpcTenancy/InstanceTenancy"
        {
            $v = "default"
            break
        }

        # Amazon.EC2.VpnEcmpSupportValue
        "New-EC2TransitGateway/Options_VpnEcmpSupport"
        {
            $v = "disable","enable"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EC2_map = @{
    "Affinity"=@("Edit-EC2InstancePlacement")
    "Architecture"=@("Register-EC2Image")
    "Attribute"=@("Edit-EC2FpgaImageAttribute","Edit-EC2InstanceAttribute","Edit-EC2SnapshotAttribute","Get-EC2FpgaImageAttribute","Get-EC2ImageAttribute","Get-EC2InstanceAttribute","Get-EC2NetworkInterfaceAttribute","Get-EC2SnapshotAttribute","Get-EC2VolumeAttribute","Get-EC2VpcAttribute","Reset-EC2FpgaImageAttribute","Reset-EC2ImageAttribute","Reset-EC2InstanceAttribute","Reset-EC2SnapshotAttribute")
    "AutoPlacement"=@("Edit-EC2Host","New-EC2Host")
    "CapacityReservationSpecification_CapacityReservationPreference"=@("Edit-EC2InstanceCapacityReservationAttribute","New-EC2Instance")
    "CopyTagsFromSource"=@("New-EC2SnapshotBatch")
    "CurrencyCode"=@("New-EC2HostReservation")
    "DiskImageFormat"=@("Export-EC2Image")
    "Domain"=@("New-EC2Address")
    "EndDateType"=@("Add-EC2CapacityReservation","Edit-EC2CapacityReservation")
    "EventType"=@("Get-EC2FleetHistory","Get-EC2SpotFleetRequestHistory")
    "ExcessCapacityTerminationPolicy"=@("Edit-EC2Fleet","Edit-EC2SpotFleetRequest","New-EC2Fleet")
    "ExportToS3Task_ContainerFormat"=@("New-EC2InstanceExportTask")
    "ExportToS3Task_DiskImageFormat"=@("New-EC2InstanceExportTask")
    "HostRecovery"=@("Edit-EC2Host","New-EC2Host")
    "HttpEndpoint"=@("Edit-EC2InstanceMetadataOption")
    "HttpTokens"=@("Edit-EC2InstanceMetadataOption")
    "InstanceFamily"=@("Edit-EC2DefaultCreditSpecification","Get-EC2DefaultCreditSpecification")
    "InstanceInitiatedShutdownBehavior"=@("New-EC2Instance")
    "InstanceInterruptionBehavior"=@("Request-EC2SpotInstance")
    "InstanceMatchCriteria"=@("Add-EC2CapacityReservation")
    "InstancePlatform"=@("Add-EC2CapacityReservation")
    "InstanceTenancy"=@("Edit-EC2VpcTenancy","Get-EC2ReservedInstancesOffering","New-EC2Vpc")
    "InstanceType"=@("Get-EC2ReservedInstancesOffering","New-EC2Instance")
    "InterfaceType"=@("New-EC2NetworkInterface")
    "LaunchSpecification_InstanceType"=@("Request-EC2SpotInstance")
    "LaunchSpecification_Placement_Tenancy"=@("Request-EC2SpotInstance")
    "LimitPrice_CurrencyCode"=@("New-EC2ReservedInstance")
    "LocationType"=@("Get-EC2InstanceTypeOffering")
    "LogDestinationType"=@("New-EC2FlowLog")
    "MetadataOptions_HttpEndpoint"=@("New-EC2Instance")
    "MetadataOptions_HttpTokens"=@("New-EC2Instance")
    "OfferingClass"=@("Get-EC2ReservedInstance","Get-EC2ReservedInstancesOffering")
    "OfferingType"=@("Get-EC2ReservedInstance","Get-EC2ReservedInstancesOffering")
    "OnDemandOptions_AllocationStrategy"=@("New-EC2Fleet")
    "OperationType"=@("Edit-EC2FpgaImageAttribute","Edit-EC2ImageAttribute","Edit-EC2SnapshotAttribute")
    "Options_AutoAcceptSharedAttachments"=@("New-EC2TransitGateway")
    "Options_DefaultRouteTableAssociation"=@("New-EC2TransitGateway")
    "Options_DefaultRouteTablePropagation"=@("New-EC2TransitGateway")
    "Options_DnsSupport"=@("Edit-EC2TransitGatewayVpcAttachment","New-EC2TransitGateway","New-EC2TransitGatewayVpcAttachment")
    "Options_Ipv6Support"=@("Edit-EC2TransitGatewayVpcAttachment","New-EC2TransitGatewayVpcAttachment")
    "Options_MulticastSupport"=@("New-EC2TransitGateway")
    "Options_VpnEcmpSupport"=@("New-EC2TransitGateway")
    "Permission"=@("New-EC2NetworkInterfacePermission")
    "Placement_Tenancy"=@("New-EC2Instance")
    "ProductDescription"=@("Get-EC2ReservedInstancesOffering")
    "ResourceType"=@("New-EC2FlowLog")
    "RuleAction"=@("Edit-EC2TrafficMirrorFilterRule","New-EC2NetworkAclEntry","New-EC2TrafficMirrorFilterRule","Set-EC2NetworkAclEntry")
    "SpotFleetRequestConfig_AllocationStrategy"=@("Request-EC2SpotFleet")
    "SpotFleetRequestConfig_ExcessCapacityTerminationPolicy"=@("Request-EC2SpotFleet")
    "SpotFleetRequestConfig_InstanceInterruptionBehavior"=@("Request-EC2SpotFleet")
    "SpotFleetRequestConfig_OnDemandAllocationStrategy"=@("Request-EC2SpotFleet")
    "SpotFleetRequestConfig_Type"=@("Request-EC2SpotFleet")
    "SpotOptions_AllocationStrategy"=@("New-EC2Fleet")
    "SpotOptions_InstanceInterruptionBehavior"=@("New-EC2Fleet")
    "Status"=@("Send-EC2InstanceStatus")
    "Strategy"=@("New-EC2PlacementGroup")
    "TargetCapacitySpecification_DefaultTargetCapacityType"=@("Edit-EC2Fleet","New-EC2Fleet")
    "TargetEnvironment"=@("New-EC2InstanceExportTask")
    "Tenancy"=@("Add-EC2CapacityReservation","Edit-EC2InstancePlacement")
    "TrafficDirection"=@("Edit-EC2TrafficMirrorFilterRule","New-EC2TrafficMirrorFilterRule")
    "TrafficType"=@("New-EC2FlowLog")
    "TransportProtocol"=@("New-EC2ClientVpnEndpoint")
    "Type"=@("New-EC2CustomerGateway","New-EC2Fleet","New-EC2VpnGateway","Request-EC2SpotInstance")
    "VolumeType"=@("Edit-EC2Volume","New-EC2Volume")
    "VpcEndpointType"=@("New-EC2VpcEndpoint")
}

_awsArgumentCompleterRegistration $EC2_Completers $EC2_map

$EC2_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EC2.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EC2_SelectMap = @{
    "Select"=@("Approve-EC2ReservedInstancesExchangeQuote",
               "Approve-EC2TransitGatewayPeeringAttachment",
               "Approve-EC2TransitGatewayVpcAttachment",
               "Approve-EC2EndpointConnection",
               "Approve-EC2VpcPeeringConnection",
               "Start-EC2ByoipCidrAdvertisement",
               "New-EC2Address",
               "New-EC2Host",
               "Add-EC2SecurityGroupToClientVpnTargetNetwork",
               "Register-EC2Ipv6AddressList",
               "Register-EC2PrivateIpAddress",
               "Register-EC2Address",
               "Register-EC2ClientVpnTargetNetwork",
               "Register-EC2DhcpOption",
               "Register-EC2IamInstanceProfile",
               "Register-EC2RouteTable",
               "Register-EC2SubnetCidrBlock",
               "Register-EC2TransitGatewayMulticastDomain",
               "Register-EC2TransitGatewayRouteTable",
               "Register-EC2VpcCidrBlock",
               "Add-EC2ClassicLinkVpc",
               "Add-EC2InternetGateway",
               "Add-EC2NetworkInterface",
               "Add-EC2Volume",
               "Add-EC2VpnGateway",
               "Grant-EC2ClientVpnIngress",
               "Grant-EC2SecurityGroupEgress",
               "Grant-EC2SecurityGroupIngress",
               "New-EC2InstanceBundle",
               "Stop-EC2BundleTask",
               "Remove-EC2CapacityReservation",
               "Stop-EC2ExportTask",
               "Stop-EC2ImportTask",
               "Stop-EC2ReservedInstancesListing",
               "Stop-EC2SpotFleetRequest",
               "Stop-EC2SpotInstanceRequest",
               "Confirm-EC2ProductInstance",
               "Copy-EC2FpgaImage",
               "Copy-EC2Image",
               "Copy-EC2Snapshot",
               "Add-EC2CapacityReservation",
               "New-EC2ClientVpnEndpoint",
               "New-EC2ClientVpnRoute",
               "New-EC2CustomerGateway",
               "New-EC2DefaultSubnet",
               "New-EC2DefaultVpc",
               "New-EC2DhcpOption",
               "New-EC2EgressOnlyInternetGateway",
               "New-EC2Fleet",
               "New-EC2FlowLog",
               "New-EC2FpgaImage",
               "New-EC2Image",
               "New-EC2InstanceExportTask",
               "New-EC2InternetGateway",
               "New-EC2KeyPair",
               "New-EC2LaunchTemplate",
               "New-EC2LaunchTemplateVersion",
               "New-EC2LocalGatewayRoute",
               "New-EC2LocalGatewayRouteTableVpcAssociation",
               "New-EC2NatGateway",
               "New-EC2NetworkAcl",
               "New-EC2NetworkAclEntry",
               "New-EC2NetworkInterface",
               "New-EC2NetworkInterfacePermission",
               "New-EC2PlacementGroup",
               "New-EC2ReservedInstancesListing",
               "New-EC2Route",
               "New-EC2RouteTable",
               "New-EC2SecurityGroup",
               "New-EC2Snapshot",
               "New-EC2SnapshotBatch",
               "New-EC2SpotDatafeedSubscription",
               "New-EC2Subnet",
               "New-EC2Tag",
               "New-EC2TrafficMirrorFilter",
               "New-EC2TrafficMirrorFilterRule",
               "New-EC2TrafficMirrorSession",
               "New-EC2TrafficMirrorTarget",
               "New-EC2TransitGateway",
               "New-EC2TransitGatewayMulticastDomain",
               "New-EC2TransitGatewayPeeringAttachment",
               "New-EC2TransitGatewayRoute",
               "New-EC2TransitGatewayRouteTable",
               "New-EC2TransitGatewayVpcAttachment",
               "New-EC2Volume",
               "New-EC2Vpc",
               "New-EC2VpcEndpoint",
               "New-EC2VpcEndpointConnectionNotification",
               "New-EC2VpcEndpointServiceConfiguration",
               "New-EC2VpcPeeringConnection",
               "New-EC2VpnConnection",
               "New-EC2VpnConnectionRoute",
               "New-EC2VpnGateway",
               "Remove-EC2ClientVpnEndpoint",
               "Remove-EC2ClientVpnRoute",
               "Remove-EC2CustomerGateway",
               "Remove-EC2DhcpOption",
               "Remove-EC2EgressOnlyInternetGateway",
               "Remove-EC2Fleet",
               "Remove-EC2FlowLog",
               "Remove-EC2FpgaImage",
               "Remove-EC2InternetGateway",
               "Remove-EC2KeyPair",
               "Remove-EC2LaunchTemplate",
               "Remove-EC2TemplateVersion",
               "Remove-EC2LocalGatewayRoute",
               "Remove-EC2LocalGatewayRouteTableVpcAssociation",
               "Remove-EC2NatGateway",
               "Remove-EC2NetworkAcl",
               "Remove-EC2NetworkAclEntry",
               "Remove-EC2NetworkInterface",
               "Remove-EC2NetworkInterfacePermission",
               "Remove-EC2PlacementGroup",
               "Remove-EC2QueuedReservedInstance",
               "Remove-EC2Route",
               "Remove-EC2RouteTable",
               "Remove-EC2SecurityGroup",
               "Remove-EC2Snapshot",
               "Remove-EC2SpotDatafeedSubscription",
               "Remove-EC2Subnet",
               "Remove-EC2Tag",
               "Remove-EC2TrafficMirrorFilter",
               "Remove-EC2TrafficMirrorFilterRule",
               "Remove-EC2TrafficMirrorSession",
               "Remove-EC2TrafficMirrorTarget",
               "Remove-EC2TransitGateway",
               "Remove-EC2TransitGatewayMulticastDomain",
               "Remove-EC2TransitGatewayPeeringAttachment",
               "Remove-EC2TransitGatewayRoute",
               "Remove-EC2TransitGatewayRouteTable",
               "Remove-EC2TransitGatewayVpcAttachment",
               "Remove-EC2Volume",
               "Remove-EC2Vpc",
               "Remove-EC2EndpointConnectionNotification",
               "Remove-EC2VpcEndpoint",
               "Remove-EC2EndpointServiceConfiguration",
               "Remove-EC2VpcPeeringConnection",
               "Remove-EC2VpnConnection",
               "Remove-EC2VpnConnectionRoute",
               "Remove-EC2VpnGateway",
               "Unregister-EC2ByoipCidr",
               "Unregister-EC2Image",
               "Unregister-EC2TransitGatewayMulticastGroupMember",
               "Unregister-EC2TransitGatewayMulticastGroupSource",
               "Get-EC2AccountAttribute",
               "Get-EC2Address",
               "Get-EC2AggregateIdFormat",
               "Get-EC2AvailabilityZone",
               "Get-EC2BundleTask",
               "Get-EC2ByoipCidr",
               "Get-EC2CapacityReservation",
               "Get-EC2ClassicLinkInstance",
               "Get-EC2ClientVpnAuthorizationRule",
               "Get-EC2ClientVpnConnection",
               "Get-EC2ClientVpnEndpoint",
               "Get-EC2ClientVpnRoute",
               "Get-EC2ClientVpnTargetNetwork",
               "Get-EC2CoipPool",
               "Get-EC2CustomerGateway",
               "Get-EC2DhcpOption",
               "Get-EC2EgressOnlyInternetGatewayList",
               "Get-EC2ElasticGpu",
               "Get-EC2ExportImageTask",
               "Get-EC2ExportTask",
               "Get-EC2FastSnapshotRestore",
               "Get-EC2FleetHistory",
               "Get-EC2FleetInstanceList",
               "Get-EC2FleetList",
               "Get-EC2FlowLog",
               "Get-EC2FpgaImageAttribute",
               "Get-EC2FpgaImage",
               "Get-EC2HostReservationOffering",
               "Get-EC2HostReservation",
               "Get-EC2Host",
               "Get-EC2IamInstanceProfileAssociation",
               "Get-EC2IdentityIdFormat",
               "Get-EC2IdFormat",
               "Get-EC2ImageAttribute",
               "Get-EC2Image",
               "Get-EC2ImportImageTask",
               "Get-EC2ImportSnapshotTask",
               "Get-EC2InstanceAttribute",
               "Get-EC2CreditSpecification",
               "Get-EC2Instance",
               "Get-EC2InstanceStatus",
               "Get-EC2InstanceTypeOffering",
               "Get-EC2InstanceType",
               "Get-EC2InternetGateway",
               "Get-EC2KeyPair",
               "Get-EC2Template",
               "Get-EC2TemplateVersion",
               "Get-EC2LocalGatewayRouteTable",
               "Get-EC2LocalGatewayRouteTableVirtualInterfaceGroupAssociation",
               "Get-EC2LocalGatewayRouteTableVpcAssociation",
               "Get-EC2LocalGateway",
               "Get-EC2LocalGatewayVirtualInterfaceGroup",
               "Get-EC2LocalGatewayVirtualInterface",
               "Get-EC2MovingAddress",
               "Get-EC2NatGateway",
               "Get-EC2NetworkAcl",
               "Get-EC2NetworkInterfaceAttribute",
               "Get-EC2NetworkInterfacePermission",
               "Get-EC2NetworkInterface",
               "Get-EC2PlacementGroup",
               "Get-EC2PrefixList",
               "Get-EC2PrincipalIdFormat",
               "Get-EC2PublicIpv4Pool",
               "Get-EC2Region",
               "Get-EC2ReservedInstance",
               "Get-EC2ReservedInstancesListing",
               "Get-EC2ReservedInstancesModification",
               "Get-EC2ReservedInstancesOffering",
               "Get-EC2RouteTable",
               "Get-EC2ScheduledInstanceAvailability",
               "Get-EC2ScheduledInstance",
               "Get-EC2SecurityGroupReference",
               "Get-EC2SecurityGroup",
               "Get-EC2SnapshotAttribute",
               "Get-EC2Snapshot",
               "Get-EC2SpotDatafeedSubscription",
               "Get-EC2SpotFleetInstance",
               "Get-EC2SpotFleetRequestHistory",
               "Get-EC2SpotFleetRequest",
               "Get-EC2SpotInstanceRequest",
               "Get-EC2SpotPriceHistory",
               "Get-EC2StaleSecurityGroup",
               "Get-EC2Subnet",
               "Get-EC2Tag",
               "Get-EC2TrafficMirrorFilter",
               "Get-EC2TrafficMirrorSession",
               "Get-EC2TrafficMirrorTarget",
               "Get-EC2TransitGatewayAttachment",
               "Get-EC2TransitGatewayMulticastDomain",
               "Get-EC2TransitGatewayPeeringAttachment",
               "Get-EC2TransitGatewayRouteTable",
               "Get-EC2TransitGateway",
               "Get-EC2TransitGatewayVpcAttachment",
               "Get-EC2VolumeAttribute",
               "Get-EC2Volume",
               "Get-EC2VolumeModification",
               "Get-EC2VolumeStatus",
               "Get-EC2VpcAttribute",
               "Get-EC2VpcClassicLink",
               "Get-EC2VpcClassicLinkDnsSupport",
               "Get-EC2EndpointConnectionNotification",
               "Get-EC2EndpointConnection",
               "Get-EC2VpcEndpoint",
               "Get-EC2EndpointServiceConfiguration",
               "Get-EC2EndpointServicePermission",
               "Get-EC2VpcEndpointService",
               "Get-EC2VpcPeeringConnection",
               "Get-EC2Vpc",
               "Get-EC2VpnConnection",
               "Get-EC2VpnGateway",
               "Dismount-EC2ClassicLinkVpc",
               "Dismount-EC2InternetGateway",
               "Dismount-EC2NetworkInterface",
               "Dismount-EC2Volume",
               "Dismount-EC2VpnGateway",
               "Disable-EC2EbsEncryptionByDefault",
               "Disable-EC2FastSnapshotRestore",
               "Disable-EC2TransitGatewayRouteTablePropagation",
               "Disable-EC2VgwRoutePropagation",
               "Disable-EC2VpcClassicLink",
               "Disable-EC2VpcClassicLinkDnsSupport",
               "Unregister-EC2Address",
               "Unregister-EC2ClientVpnTargetNetwork",
               "Unregister-EC2IamInstanceProfile",
               "Unregister-EC2RouteTable",
               "Unregister-EC2SubnetCidrBlock",
               "Unregister-EC2TransitGatewayMulticastDomain",
               "Unregister-EC2TransitGatewayRouteTable",
               "Unregister-EC2VpcCidrBlock",
               "Enable-EC2EbsEncryptionByDefault",
               "Enable-EC2FastSnapshotRestore",
               "Enable-EC2TransitGatewayRouteTablePropagation",
               "Enable-EC2VgwRoutePropagation",
               "Enable-EC2VolumeIO",
               "Enable-EC2VpcClassicLink",
               "Enable-EC2VpcClassicLinkDnsSupport",
               "Export-EC2ClientVpnClientCertificateRevocationList",
               "Export-EC2ClientVpnClientConfiguration",
               "Export-EC2Image",
               "Export-EC2TransitGatewayRoute",
               "Get-EC2CapacityReservationUsage",
               "Get-EC2CoipPoolUsage",
               "Get-EC2ConsoleOutput",
               "Get-EC2ConsoleScreenshot",
               "Get-EC2DefaultCreditSpecification",
               "Get-EC2EbsDefaultKmsKeyId",
               "Get-EC2EbsEncryptionByDefault",
               "Get-EC2HostReservationPurchasePreview",
               "Get-EC2LaunchTemplateData",
               "Get-EC2ReservedInstancesExchangeQuote",
               "Get-EC2TransitGatewayAttachmentPropagation",
               "Get-EC2TransitGatewayMulticastDomainAssociation",
               "Get-EC2TransitGatewayRouteTableAssociation",
               "Get-EC2TransitGatewayRouteTablePropagation",
               "Import-EC2ClientVpnClientCertificateRevocationList",
               "Import-EC2Image",
               "Import-EC2KeyPair",
               "Import-EC2Snapshot",
               "Edit-EC2CapacityReservation",
               "Edit-EC2ClientVpnEndpoint",
               "Edit-EC2DefaultCreditSpecification",
               "Edit-EC2EbsDefaultKmsKeyId",
               "Edit-EC2Fleet",
               "Edit-EC2FpgaImageAttribute",
               "Edit-EC2Host",
               "Edit-EC2IdentityIdFormat",
               "Edit-EC2IdFormat",
               "Edit-EC2ImageAttribute",
               "Edit-EC2InstanceAttribute",
               "Edit-EC2InstanceCapacityReservationAttribute",
               "Edit-EC2InstanceCreditSpecification",
               "Edit-EC2InstanceEventStartTime",
               "Edit-EC2InstanceMetadataOption",
               "Edit-EC2InstancePlacement",
               "Edit-EC2LaunchTemplate",
               "Edit-EC2NetworkInterfaceAttribute",
               "Edit-EC2ReservedInstance",
               "Edit-EC2SnapshotAttribute",
               "Edit-EC2SpotFleetRequest",
               "Edit-EC2SubnetAttribute",
               "Edit-EC2TrafficMirrorFilterNetworkService",
               "Edit-EC2TrafficMirrorFilterRule",
               "Edit-EC2TrafficMirrorSession",
               "Edit-EC2TransitGatewayVpcAttachment",
               "Edit-EC2Volume",
               "Edit-EC2VolumeAttribute",
               "Edit-EC2VpcAttribute",
               "Edit-EC2VpcEndpoint",
               "Edit-EC2VpcEndpointConnectionNotification",
               "Edit-EC2VpcEndpointServiceConfiguration",
               "Edit-EC2EndpointServicePermission",
               "Edit-EC2VpcPeeringConnectionOption",
               "Edit-EC2VpcTenancy",
               "Edit-EC2VpnConnection",
               "Edit-EC2VpnTunnelCertificate",
               "Edit-EC2VpnTunnelOption",
               "Start-EC2InstanceMonitoring",
               "Move-EC2AddressToVpc",
               "Register-EC2ByoipCidr",
               "New-EC2HostReservation",
               "New-EC2ReservedInstance",
               "New-EC2ScheduledInstancePurchase",
               "Restart-EC2Instance",
               "Register-EC2Image",
               "Register-EC2TransitGatewayMulticastGroupMember",
               "Register-EC2TransitGatewayMulticastGroupSource",
               "Deny-EC2TransitGatewayPeeringAttachment",
               "Deny-EC2TransitGatewayVpcAttachment",
               "Deny-EC2EndpointConnection",
               "Deny-EC2VpcPeeringConnection",
               "Remove-EC2Address",
               "Remove-EC2Host",
               "Set-EC2IamInstanceProfileAssociation",
               "Set-EC2NetworkAclAssociation",
               "Set-EC2NetworkAclEntry",
               "Set-EC2Route",
               "Set-EC2RouteTableAssociation",
               "Set-EC2TransitGatewayRoute",
               "Send-EC2InstanceStatus",
               "Request-EC2SpotFleet",
               "Request-EC2SpotInstance",
               "Reset-EC2EbsDefaultKmsKeyId",
               "Reset-EC2FpgaImageAttribute",
               "Reset-EC2ImageAttribute",
               "Reset-EC2InstanceAttribute",
               "Reset-EC2NetworkInterfaceAttribute",
               "Reset-EC2SnapshotAttribute",
               "Restore-EC2AddressToClassic",
               "Revoke-EC2ClientVpnIngress",
               "Revoke-EC2SecurityGroupEgress",
               "Revoke-EC2SecurityGroupIngress",
               "New-EC2Instance",
               "New-EC2ScheduledInstance",
               "Search-EC2LocalGatewayRoute",
               "Search-EC2TransitGatewayMulticastGroup",
               "Search-EC2TransitGatewayRoute",
               "Send-EC2DiagnosticInterrupt",
               "Start-EC2Instance",
               "Stop-EC2Instance",
               "Stop-EC2ClientVpnConnection",
               "Remove-EC2Instance",
               "Unregister-EC2Ipv6AddressList",
               "Unregister-EC2PrivateIpAddress",
               "Stop-EC2InstanceMonitoring",
               "Update-EC2SecurityGroupRuleEgressDescription",
               "Update-EC2SecurityGroupRuleIngressDescription",
               "Stop-EC2ByoipCidrAdvertisement",
               "Get-EC2ImageByName",
               "Get-EC2InstanceMetadata",
               "Get-EC2PasswordData")
}

_awsArgumentCompleterRegistration $EC2_SelectCompleters $EC2_SelectMap
# Argument completions for service Amazon EC2 Container Registry


$ECR_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ECR.ImageTagMutability
        {
            ($_ -eq "New-ECRRepository/ImageTagMutability") -Or
            ($_ -eq "Write-ECRImageTagMutability/ImageTagMutability")
        }
        {
            $v = "IMMUTABLE","MUTABLE"
            break
        }

        # Amazon.ECR.TagStatus
        {
            ($_ -eq "Get-ECRImage/Filter_TagStatus") -Or
            ($_ -eq "Get-ECRImageMetadata/Filter_TagStatus") -Or
            ($_ -eq "Get-ECRLifecyclePolicyPreview/Filter_TagStatus")
        }
        {
            $v = "ANY","TAGGED","UNTAGGED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ECR_map = @{
    "Filter_TagStatus"=@("Get-ECRImage","Get-ECRImageMetadata","Get-ECRLifecyclePolicyPreview")
    "ImageTagMutability"=@("New-ECRRepository","Write-ECRImageTagMutability")
}

_awsArgumentCompleterRegistration $ECR_Completers $ECR_map

$ECR_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ECR.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ECR_SelectMap = @{
    "Select"=@("Get-ECRLayerAvailabilityBatch",
               "Remove-ECRImageBatch",
               "Get-ECRImageBatch",
               "Complete-ECRLayerUpload",
               "New-ECRRepository",
               "Remove-ECRLifecyclePolicy",
               "Remove-ECRRepository",
               "Remove-ECRRepositoryPolicy",
               "Get-ECRImageMetadata",
               "Get-ECRImageScanFinding",
               "Get-ECRRepository",
               "Get-ECRAuthorizationToken",
               "Get-ECRDownloadUrlForLayer",
               "Get-ECRLifecyclePolicy",
               "Get-ECRLifecyclePolicyPreview",
               "Get-ECRRepositoryPolicy",
               "Start-ECRLayerUpload",
               "Get-ECRImage",
               "Get-ECRResourceTag",
               "Write-ECRImage",
               "Write-ECRImageScanningConfiguration",
               "Write-ECRImageTagMutability",
               "Write-ECRLifecyclePolicy",
               "Set-ECRRepositoryPolicy",
               "Start-ECRImageScan",
               "Start-ECRLifecyclePolicyPreview",
               "Add-ECRResourceTag",
               "Remove-ECRResourceTag",
               "Send-ECRLayerPart",
               "Get-ECRLoginCommand")
}

_awsArgumentCompleterRegistration $ECR_SelectCompleters $ECR_SelectMap
# Argument completions for service Amazon EC2 Container Service


$ECS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ECS.AssignPublicIp
        {
            ($_ -eq "New-ECSService/NetworkConfiguration_AwsvpcConfiguration_AssignPublicIp") -Or
            ($_ -eq "New-ECSTask/NetworkConfiguration_AwsvpcConfiguration_AssignPublicIp") -Or
            ($_ -eq "New-ECSTaskSet/NetworkConfiguration_AwsvpcConfiguration_AssignPublicIp") -Or
            ($_ -eq "Start-ECSTask/NetworkConfiguration_AwsvpcConfiguration_AssignPublicIp") -Or
            ($_ -eq "Update-ECSService/NetworkConfiguration_AwsvpcConfiguration_AssignPublicIp")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.ECS.ContainerInstanceStatus
        {
            ($_ -eq "Get-ECSContainerInstanceList/Status") -Or
            ($_ -eq "Update-ECSContainerInstancesState/Status")
        }
        {
            $v = "ACTIVE","DEREGISTERING","DRAINING","REGISTERING","REGISTRATION_FAILED"
            break
        }

        # Amazon.ECS.DeploymentControllerType
        "New-ECSService/DeploymentController_Type"
        {
            $v = "CODE_DEPLOY","ECS","EXTERNAL"
            break
        }

        # Amazon.ECS.DesiredStatus
        "Get-ECSTaskList/DesiredStatus"
        {
            $v = "PENDING","RUNNING","STOPPED"
            break
        }

        # Amazon.ECS.IpcMode
        "Register-ECSTaskDefinition/IpcMode"
        {
            $v = "host","none","task"
            break
        }

        # Amazon.ECS.LaunchType
        {
            ($_ -eq "Get-ECSClusterService/LaunchType") -Or
            ($_ -eq "Get-ECSTaskList/LaunchType") -Or
            ($_ -eq "New-ECSService/LaunchType") -Or
            ($_ -eq "New-ECSTask/LaunchType") -Or
            ($_ -eq "New-ECSTaskSet/LaunchType")
        }
        {
            $v = "EC2","FARGATE"
            break
        }

        # Amazon.ECS.ManagedScalingStatus
        "New-ECSCapacityProvider/AutoScalingGroupProvider_ManagedScaling_Status"
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.ECS.ManagedTerminationProtection
        "New-ECSCapacityProvider/AutoScalingGroupProvider_ManagedTerminationProtection"
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.ECS.NetworkMode
        "Register-ECSTaskDefinition/NetworkMode"
        {
            $v = "awsvpc","bridge","host","none"
            break
        }

        # Amazon.ECS.PidMode
        "Register-ECSTaskDefinition/PidMode"
        {
            $v = "host","task"
            break
        }

        # Amazon.ECS.PropagateTags
        {
            ($_ -eq "New-ECSService/PropagateTags") -Or
            ($_ -eq "New-ECSTask/PropagateTags") -Or
            ($_ -eq "Start-ECSTask/PropagateTags")
        }
        {
            $v = "SERVICE","TASK_DEFINITION"
            break
        }

        # Amazon.ECS.ProxyConfigurationType
        "Register-ECSTaskDefinition/ProxyConfiguration_Type"
        {
            $v = "APPMESH"
            break
        }

        # Amazon.ECS.ScaleUnit
        {
            ($_ -eq "New-ECSTaskSet/Scale_Unit") -Or
            ($_ -eq "Update-ECSTaskSet/Scale_Unit")
        }
        {
            $v = "PERCENT"
            break
        }

        # Amazon.ECS.SchedulingStrategy
        {
            ($_ -eq "Get-ECSClusterService/SchedulingStrategy") -Or
            ($_ -eq "New-ECSService/SchedulingStrategy")
        }
        {
            $v = "DAEMON","REPLICA"
            break
        }

        # Amazon.ECS.SettingName
        {
            ($_ -eq "Get-ECSAccountSetting/Name") -Or
            ($_ -eq "Remove-ECSAccountSetting/Name") -Or
            ($_ -eq "Write-ECSAccountSetting/Name") -Or
            ($_ -eq "Write-ECSAccountSettingDefault/Name")
        }
        {
            $v = "awsvpcTrunking","containerInsights","containerInstanceLongArnFormat","serviceLongArnFormat","taskLongArnFormat"
            break
        }

        # Amazon.ECS.SortOrder
        "Get-ECSTaskDefinitionList/Sort"
        {
            $v = "ASC","DESC"
            break
        }

        # Amazon.ECS.TargetType
        "Get-ECSAttributeList/TargetType"
        {
            $v = "container-instance"
            break
        }

        # Amazon.ECS.TaskDefinitionFamilyStatus
        "Get-ECSTaskDefinitionFamilyList/Status"
        {
            $v = "ACTIVE","ALL","INACTIVE"
            break
        }

        # Amazon.ECS.TaskDefinitionStatus
        "Get-ECSTaskDefinitionList/Status"
        {
            $v = "ACTIVE","INACTIVE"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ECS_map = @{
    "AutoScalingGroupProvider_ManagedScaling_Status"=@("New-ECSCapacityProvider")
    "AutoScalingGroupProvider_ManagedTerminationProtection"=@("New-ECSCapacityProvider")
    "DeploymentController_Type"=@("New-ECSService")
    "DesiredStatus"=@("Get-ECSTaskList")
    "IpcMode"=@("Register-ECSTaskDefinition")
    "LaunchType"=@("Get-ECSClusterService","Get-ECSTaskList","New-ECSService","New-ECSTask","New-ECSTaskSet")
    "Name"=@("Get-ECSAccountSetting","Remove-ECSAccountSetting","Write-ECSAccountSetting","Write-ECSAccountSettingDefault")
    "NetworkConfiguration_AwsvpcConfiguration_AssignPublicIp"=@("New-ECSService","New-ECSTask","New-ECSTaskSet","Start-ECSTask","Update-ECSService")
    "NetworkMode"=@("Register-ECSTaskDefinition")
    "PidMode"=@("Register-ECSTaskDefinition")
    "PropagateTags"=@("New-ECSService","New-ECSTask","Start-ECSTask")
    "ProxyConfiguration_Type"=@("Register-ECSTaskDefinition")
    "Scale_Unit"=@("New-ECSTaskSet","Update-ECSTaskSet")
    "SchedulingStrategy"=@("Get-ECSClusterService","New-ECSService")
    "Sort"=@("Get-ECSTaskDefinitionList")
    "Status"=@("Get-ECSContainerInstanceList","Get-ECSTaskDefinitionFamilyList","Get-ECSTaskDefinitionList","Update-ECSContainerInstancesState")
    "TargetType"=@("Get-ECSAttributeList")
}

_awsArgumentCompleterRegistration $ECS_Completers $ECS_map

$ECS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ECS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ECS_SelectMap = @{
    "Select"=@("New-ECSCapacityProvider",
               "New-ECSCluster",
               "New-ECSService",
               "New-ECSTaskSet",
               "Remove-ECSAccountSetting",
               "Remove-ECSAttribute",
               "Remove-ECSCluster",
               "Remove-ECSService",
               "Remove-ECSTaskSet",
               "Unregister-ECSContainerInstance",
               "Unregister-ECSTaskDefinition",
               "Get-ECSCapacityProvider",
               "Get-ECSClusterDetail",
               "Get-ECSContainerInstanceDetail",
               "Get-ECSService",
               "Get-ECSTaskDefinitionDetail",
               "Get-ECSTaskDetail",
               "Get-ECSTaskSet",
               "Get-ECSAccountSetting",
               "Get-ECSAttributeList",
               "Get-ECSClusterList",
               "Get-ECSContainerInstanceList",
               "Get-ECSClusterService",
               "Get-ECSTagsForResource",
               "Get-ECSTaskDefinitionFamilyList",
               "Get-ECSTaskDefinitionList",
               "Get-ECSTaskList",
               "Write-ECSAccountSetting",
               "Write-ECSAccountSettingDefault",
               "Write-ECSAttribute",
               "Write-ECSClusterCapacityProvider",
               "Register-ECSTaskDefinition",
               "New-ECSTask",
               "Start-ECSTask",
               "Stop-ECSTask",
               "Submit-ECSAttachmentStateChange",
               "Add-ECSResourceTag",
               "Remove-ECSResourceTag",
               "Update-ECSClusterSetting",
               "Update-ECSContainerAgent",
               "Update-ECSContainerInstancesState",
               "Update-ECSService",
               "Update-ECSServicePrimaryTaskSet",
               "Update-ECSTaskSet")
}

_awsArgumentCompleterRegistration $ECS_SelectCompleters $ECS_SelectMap
# Argument completions for service Amazon Elastic File System


$EFS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ElasticFileSystem.PerformanceMode
        "New-EFSFileSystem/PerformanceMode"
        {
            $v = "generalPurpose","maxIO"
            break
        }

        # Amazon.ElasticFileSystem.ThroughputMode
        {
            ($_ -eq "New-EFSFileSystem/ThroughputMode") -Or
            ($_ -eq "Update-EFSFileSystem/ThroughputMode")
        }
        {
            $v = "bursting","provisioned"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EFS_map = @{
    "PerformanceMode"=@("New-EFSFileSystem")
    "ThroughputMode"=@("New-EFSFileSystem","Update-EFSFileSystem")
}

_awsArgumentCompleterRegistration $EFS_Completers $EFS_map

$EFS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EFS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EFS_SelectMap = @{
    "Select"=@("New-EFSFileSystem",
               "New-EFSMountTarget",
               "New-EFSTag",
               "Remove-EFSFileSystem",
               "Remove-EFSMountTarget",
               "Remove-EFSTag",
               "Get-EFSFileSystem",
               "Get-EFSLifecycleConfiguration",
               "Get-EFSMountTarget",
               "Get-EFSMountTargetSecurityGroup",
               "Get-EFSTag",
               "Edit-EFSMountTargetSecurityGroup",
               "Write-EFSLifecycleConfiguration",
               "Update-EFSFileSystem")
}

_awsArgumentCompleterRegistration $EFS_SelectCompleters $EFS_SelectMap
# Argument completions for service Amazon Elastic Container Service for Kubernetes


$EKS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.EKS.AMITypes
        "New-EKSNodegroup/AmiType"
        {
            $v = "AL2_x86_64","AL2_x86_64_GPU"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EKS_map = @{
    "AmiType"=@("New-EKSNodegroup")
}

_awsArgumentCompleterRegistration $EKS_Completers $EKS_map

$EKS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EKS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EKS_SelectMap = @{
    "Select"=@("New-EKSCluster",
               "New-EKSFargateProfile",
               "New-EKSNodegroup",
               "Remove-EKSCluster",
               "Remove-EKSFargateProfile",
               "Remove-EKSNodegroup",
               "Get-EKSCluster",
               "Get-EKSFargateProfile",
               "Get-EKSNodegroup",
               "Get-EKSUpdate",
               "Get-EKSClusterList",
               "Get-EKSFargateProfileList",
               "Get-EKSNodegroupList",
               "Get-EKSResourceTag",
               "Get-EKSUpdateList",
               "Add-EKSResourceTag",
               "Remove-EKSResourceTag",
               "Update-EKSClusterConfig",
               "Update-EKSClusterVersion",
               "Update-EKSNodegroupConfig",
               "Update-EKSNodegroupVersion")
}

_awsArgumentCompleterRegistration $EKS_SelectCompleters $EKS_SelectMap
# Argument completions for service Amazon ElastiCache


$EC_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ElastiCache.AuthTokenUpdateStrategyType
        {
            ($_ -eq "Edit-ECCacheCluster/AuthTokenUpdateStrategy") -Or
            ($_ -eq "Edit-ECReplicationGroup/AuthTokenUpdateStrategy")
        }
        {
            $v = "ROTATE","SET"
            break
        }

        # Amazon.ElastiCache.AZMode
        {
            ($_ -eq "Edit-ECCacheCluster/AZMode") -Or
            ($_ -eq "New-ECCacheCluster/AZMode")
        }
        {
            $v = "cross-az","single-az"
            break
        }

        # Amazon.ElastiCache.SourceType
        "Get-ECEvent/SourceType"
        {
            $v = "cache-cluster","cache-parameter-group","cache-security-group","cache-subnet-group","replication-group"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EC_map = @{
    "AuthTokenUpdateStrategy"=@("Edit-ECCacheCluster","Edit-ECReplicationGroup")
    "AZMode"=@("Edit-ECCacheCluster","New-ECCacheCluster")
    "SourceType"=@("Get-ECEvent")
}

_awsArgumentCompleterRegistration $EC_Completers $EC_map

$EC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EC_SelectMap = @{
    "Select"=@("Add-ECTag",
               "Approve-ECCacheSecurityGroupIngress",
               "Start-ECUpdateActionBatch",
               "Stop-ECUpdateActionBatch",
               "Complete-ECMigration",
               "Copy-ECSnapshot",
               "New-ECCacheCluster",
               "New-ECCacheParameterGroup",
               "New-ECCacheSecurityGroup",
               "New-ECCacheSubnetGroup",
               "New-ECReplicationGroup",
               "New-ECSnapshot",
               "Request-ECReplicaCountDecrease",
               "Remove-ECCacheCluster",
               "Remove-ECCacheParameterGroup",
               "Remove-ECCacheSecurityGroup",
               "Remove-ECCacheSubnetGroup",
               "Remove-ECReplicationGroup",
               "Remove-ECSnapshot",
               "Get-ECCacheCluster",
               "Get-ECCacheEngineVersion",
               "Get-ECCacheParameterGroup",
               "Get-ECCacheParameter",
               "Get-ECCacheSecurityGroup",
               "Get-ECCacheSubnetGroup",
               "Get-ECEngineDefaultParameter",
               "Get-ECEvent",
               "Get-ECReplicationGroup",
               "Get-ECReservedCacheNode",
               "Get-ECReservedCacheNodesOffering",
               "Get-ECServiceUpdate",
               "Get-ECSnapshot",
               "Get-ECUpdateAction",
               "Request-ECReplicaCountIncrease",
               "Get-ECAllowedNodeTypeModification",
               "Get-ECTag",
               "Edit-ECCacheCluster",
               "Edit-ECCacheParameterGroup",
               "Edit-ECCacheSubnetGroup",
               "Edit-ECReplicationGroup",
               "Edit-ECReplicationGroupShardConfiguration",
               "Request-ECReservedCacheNodesOffering",
               "Restart-ECCacheCluster",
               "Remove-ECTag",
               "Reset-ECCacheParameterGroup",
               "Revoke-ECCacheSecurityGroupIngress",
               "Start-ECMigration",
               "Test-ECFailover")
}

_awsArgumentCompleterRegistration $EC_SelectCompleters $EC_SelectMap
# Argument completions for service AWS Elastic Beanstalk


$EB_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ElasticBeanstalk.ActionStatus
        "Get-EBEnvironmentManagedAction/Status"
        {
            $v = "Pending","Running","Scheduled","Unknown"
            break
        }

        # Amazon.ElasticBeanstalk.ComputeType
        "New-EBApplicationVersion/BuildConfiguration_ComputeType"
        {
            $v = "BUILD_GENERAL1_LARGE","BUILD_GENERAL1_MEDIUM","BUILD_GENERAL1_SMALL"
            break
        }

        # Amazon.ElasticBeanstalk.EnvironmentInfoType
        {
            ($_ -eq "Get-EBEnvironmentInfo/InfoType") -Or
            ($_ -eq "Request-EBEnvironmentInfo/InfoType")
        }
        {
            $v = "bundle","tail"
            break
        }

        # Amazon.ElasticBeanstalk.EventSeverity
        "Get-EBEvent/Severity"
        {
            $v = "DEBUG","ERROR","FATAL","INFO","TRACE","WARN"
            break
        }

        # Amazon.ElasticBeanstalk.SourceRepository
        "New-EBApplicationVersion/SourceBuildInformation_SourceRepository"
        {
            $v = "CodeCommit","S3"
            break
        }

        # Amazon.ElasticBeanstalk.SourceType
        "New-EBApplicationVersion/SourceBuildInformation_SourceType"
        {
            $v = "Git","Zip"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EB_map = @{
    "BuildConfiguration_ComputeType"=@("New-EBApplicationVersion")
    "InfoType"=@("Get-EBEnvironmentInfo","Request-EBEnvironmentInfo")
    "Severity"=@("Get-EBEvent")
    "SourceBuildInformation_SourceRepository"=@("New-EBApplicationVersion")
    "SourceBuildInformation_SourceType"=@("New-EBApplicationVersion")
    "Status"=@("Get-EBEnvironmentManagedAction")
}

_awsArgumentCompleterRegistration $EB_Completers $EB_map

$EB_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EB.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EB_SelectMap = @{
    "Select"=@("Stop-EBEnvironmentUpdate",
               "Submit-EBEnvironmentManagedAction",
               "Get-EBDNSAvailability",
               "Group-EBEnvironment",
               "New-EBApplication",
               "New-EBApplicationVersion",
               "New-EBConfigurationTemplate",
               "New-EBEnvironment",
               "New-EBPlatformVersion",
               "New-EBStorageLocation",
               "Remove-EBApplication",
               "Remove-EBApplicationVersion",
               "Remove-EBConfigurationTemplate",
               "Remove-EBEnvironmentConfiguration",
               "Remove-EBPlatformVersion",
               "Get-EBAccountAttribute",
               "Get-EBApplication",
               "Get-EBApplicationVersion",
               "Get-EBConfigurationOption",
               "Get-EBConfigurationSetting",
               "Get-EBEnvironmentHealth",
               "Get-EBEnvironmentManagedActionHistory",
               "Get-EBEnvironmentManagedAction",
               "Get-EBEnvironmentResource",
               "Get-EBEnvironment",
               "Get-EBEvent",
               "Get-EBInstanceHealth",
               "Get-EBPlatformVersionDetail",
               "Get-EBAvailableSolutionStackList",
               "Get-EBPlatformVersion",
               "Get-EBResourceTag",
               "Start-EBEnvironmentRebuild",
               "Request-EBEnvironmentInfo",
               "Restart-EBAppServer",
               "Get-EBEnvironmentInfo",
               "Set-EBEnvironmentCNAME",
               "Stop-EBEnvironment",
               "Update-EBApplication",
               "Update-EBApplicationResourceLifecycle",
               "Update-EBApplicationVersion",
               "Update-EBConfigurationTemplate",
               "Update-EBEnvironment",
               "Update-EBResourceTag",
               "Test-EBConfigurationSetting")
}

_awsArgumentCompleterRegistration $EB_SelectCompleters $EB_SelectMap
# Argument completions for service Amazon Elastic Inference


$EI_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EI.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EI_SelectMap = @{
    "Select"=@("Get-EIResourceTag",
               "Add-EIResourceTag",
               "Remove-EIResourceTag")
}

_awsArgumentCompleterRegistration $EI_SelectCompleters $EI_SelectMap
# Argument completions for service Elastic Load Balancing


$ELB_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ELB.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ELB_SelectMap = @{
    "Select"=@("Add-ELBResourceTag",
               "Join-ELBSecurityGroupToLoadBalancer",
               "Add-ELBLoadBalancerToSubnet",
               "Set-ELBHealthCheck",
               "New-ELBAppCookieStickinessPolicy",
               "New-ELBLBCookieStickinessPolicy",
               "New-ELBLoadBalancer",
               "New-ELBLoadBalancerListener",
               "New-ELBLoadBalancerPolicy",
               "Remove-ELBLoadBalancer",
               "Remove-ELBLoadBalancerListener",
               "Remove-ELBLoadBalancerPolicy",
               "Remove-ELBInstanceFromLoadBalancer",
               "Get-ELBAccountLimit",
               "Get-ELBInstanceHealth",
               "Get-ELBLoadBalancerAttribute",
               "Get-ELBLoadBalancerPolicy",
               "Get-ELBLoadBalancerPolicyType",
               "Get-ELBLoadBalancer",
               "Get-ELBResourceTag",
               "Dismount-ELBLoadBalancerFromSubnet",
               "Disable-ELBAvailabilityZoneForLoadBalancer",
               "Enable-ELBAvailabilityZoneForLoadBalancer",
               "Edit-ELBLoadBalancerAttribute",
               "Register-ELBInstanceWithLoadBalancer",
               "Remove-ELBResourceTag",
               "Set-ELBLoadBalancerListenerSSLCertificate",
               "Set-ELBLoadBalancerPolicyForBackendServer",
               "Set-ELBLoadBalancerPolicyOfListener")
}

_awsArgumentCompleterRegistration $ELB_SelectCompleters $ELB_SelectMap
# Argument completions for service Elastic Load Balancing V2


$ELB2_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ElasticLoadBalancingV2.IpAddressType
        {
            ($_ -eq "New-ELB2LoadBalancer/IpAddressType") -Or
            ($_ -eq "Set-ELB2IpAddressType/IpAddressType")
        }
        {
            $v = "dualstack","ipv4"
            break
        }

        # Amazon.ElasticLoadBalancingV2.LoadBalancerSchemeEnum
        "New-ELB2LoadBalancer/Scheme"
        {
            $v = "internal","internet-facing"
            break
        }

        # Amazon.ElasticLoadBalancingV2.LoadBalancerTypeEnum
        "New-ELB2LoadBalancer/Type"
        {
            $v = "application","network"
            break
        }

        # Amazon.ElasticLoadBalancingV2.ProtocolEnum
        {
            ($_ -eq "Edit-ELB2TargetGroup/HealthCheckProtocol") -Or
            ($_ -eq "New-ELB2TargetGroup/HealthCheckProtocol") -Or
            ($_ -eq "Edit-ELB2Listener/Protocol") -Or
            ($_ -eq "New-ELB2Listener/Protocol") -Or
            ($_ -eq "New-ELB2TargetGroup/Protocol")
        }
        {
            $v = "HTTP","HTTPS","TCP","TCP_UDP","TLS","UDP"
            break
        }

        # Amazon.ElasticLoadBalancingV2.TargetTypeEnum
        "New-ELB2TargetGroup/TargetType"
        {
            $v = "instance","ip","lambda"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ELB2_map = @{
    "HealthCheckProtocol"=@("Edit-ELB2TargetGroup","New-ELB2TargetGroup")
    "IpAddressType"=@("New-ELB2LoadBalancer","Set-ELB2IpAddressType")
    "Protocol"=@("Edit-ELB2Listener","New-ELB2Listener","New-ELB2TargetGroup")
    "Scheme"=@("New-ELB2LoadBalancer")
    "TargetType"=@("New-ELB2TargetGroup")
    "Type"=@("New-ELB2LoadBalancer")
}

_awsArgumentCompleterRegistration $ELB2_Completers $ELB2_map

$ELB2_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ELB2.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ELB2_SelectMap = @{
    "Select"=@("Add-ELB2ListenerCertificate",
               "Add-ELB2Tag",
               "New-ELB2Listener",
               "New-ELB2LoadBalancer",
               "New-ELB2Rule",
               "New-ELB2TargetGroup",
               "Remove-ELB2Listener",
               "Remove-ELB2LoadBalancer",
               "Remove-ELB2Rule",
               "Remove-ELB2TargetGroup",
               "Unregister-ELB2Target",
               "Get-ELB2AccountLimit",
               "Get-ELB2ListenerCertificate",
               "Get-ELB2Listener",
               "Get-ELB2LoadBalancerAttribute",
               "Get-ELB2LoadBalancer",
               "Get-ELB2Rule",
               "Get-ELB2SSLPolicy",
               "Get-ELB2Tag",
               "Get-ELB2TargetGroupAttribute",
               "Get-ELB2TargetGroup",
               "Get-ELB2TargetHealth",
               "Edit-ELB2Listener",
               "Edit-ELB2LoadBalancerAttribute",
               "Edit-ELB2Rule",
               "Edit-ELB2TargetGroup",
               "Edit-ELB2TargetGroupAttribute",
               "Register-ELB2Target",
               "Remove-ELB2ListenerCertificate",
               "Remove-ELB2Tag",
               "Set-ELB2IpAddressType",
               "Set-ELB2RulePriority",
               "Set-ELB2SecurityGroup",
               "Set-ELB2Subnet")
}

_awsArgumentCompleterRegistration $ELB2_SelectCompleters $ELB2_SelectMap
# Argument completions for service Amazon Elastic MapReduce


$EMR_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ElasticMapReduce.InstanceFleetType
        {
            ($_ -eq "Add-EMRInstanceFleet/InstanceFleet_InstanceFleetType") -Or
            ($_ -eq "Get-EMRInstanceList/InstanceFleetType")
        }
        {
            $v = "CORE","MASTER","TASK"
            break
        }

        # Amazon.ElasticMapReduce.RepoUpgradeOnBoot
        "Start-EMRJobFlow/RepoUpgradeOnBoot"
        {
            $v = "NONE","SECURITY"
            break
        }

        # Amazon.ElasticMapReduce.ScaleDownBehavior
        "Start-EMRJobFlow/ScaleDownBehavior"
        {
            $v = "TERMINATE_AT_INSTANCE_HOUR","TERMINATE_AT_TASK_COMPLETION"
            break
        }

        # Amazon.ElasticMapReduce.SpotProvisioningTimeoutAction
        "Add-EMRInstanceFleet/InstanceFleet_LaunchSpecifications_SpotSpecification_TimeoutAction"
        {
            $v = "SWITCH_TO_ON_DEMAND","TERMINATE_CLUSTER"
            break
        }

        # Amazon.ElasticMapReduce.StepCancellationOption
        "Stop-EMRStep/StepCancellationOption"
        {
            $v = "SEND_INTERRUPT","TERMINATE_PROCESS"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EMR_map = @{
    "InstanceFleet_InstanceFleetType"=@("Add-EMRInstanceFleet")
    "InstanceFleet_LaunchSpecifications_SpotSpecification_TimeoutAction"=@("Add-EMRInstanceFleet")
    "InstanceFleetType"=@("Get-EMRInstanceList")
    "RepoUpgradeOnBoot"=@("Start-EMRJobFlow")
    "ScaleDownBehavior"=@("Start-EMRJobFlow")
    "StepCancellationOption"=@("Stop-EMRStep")
}

_awsArgumentCompleterRegistration $EMR_Completers $EMR_map

$EMR_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EMR.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EMR_SelectMap = @{
    "Select"=@("Add-EMRInstanceFleet",
               "Add-EMRInstanceGroup",
               "Add-EMRJobFlowStep",
               "Add-EMRResourceTag",
               "Stop-EMRStep",
               "New-EMRSecurityConfiguration",
               "Remove-EMRSecurityConfiguration",
               "Get-EMRCluster",
               "Get-EMRJobFlow",
               "Get-EMRSecurityConfiguration",
               "Get-EMRStep",
               "Get-EMRBlockPublicAccessConfiguration",
               "Get-EMRBootstrapActionList",
               "Get-EMRClusterList",
               "Get-EMRInstanceFleetList",
               "Get-EMRInstanceGroupList",
               "Get-EMRInstanceList",
               "Get-EMRSecurityConfigurationList",
               "Get-EMRStepList",
               "Edit-EMRCluster",
               "Edit-EMRInstanceFleet",
               "Edit-EMRInstanceGroup",
               "Write-EMRAutoScalingPolicy",
               "Write-EMRBlockPublicAccessConfiguration",
               "Remove-EMRAutoScalingPolicy",
               "Remove-EMRResourceTag",
               "Start-EMRJobFlow",
               "Set-EMRTerminationProtection",
               "Set-EMRVisibleToAllUser",
               "Stop-EMRJobFlow")
}

_awsArgumentCompleterRegistration $EMR_SelectCompleters $EMR_SelectMap
# Argument completions for service Amazon Elastic Transcoder


$ETS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ETS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ETS_SelectMap = @{
    "Select"=@("Stop-ETSJob",
               "New-ETSJob",
               "New-ETSPipeline",
               "New-ETSPreset",
               "Remove-ETSPipeline",
               "Remove-ETSPreset",
               "Get-ETSJobsByPipeline",
               "Get-ETSJobsByStatus",
               "Get-ETSPipeline",
               "Get-ETSPreset",
               "Read-ETSJob",
               "Read-ETSPipeline",
               "Read-ETSPreset",
               "Test-ETSRole",
               "Update-ETSPipeline",
               "Update-ETSPipelineNotification",
               "Update-ETSPipelineStatus")
}

_awsArgumentCompleterRegistration $ETS_SelectCompleters $ETS_SelectMap
# Argument completions for service Amazon Simple Email Service (SES)


$SES_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.SimpleEmail.BehaviorOnMXFailure
        "Set-SESIdentityMailFromDomain/BehaviorOnMXFailure"
        {
            $v = "RejectMessage","UseDefaultValue"
            break
        }

        # Amazon.SimpleEmail.IdentityType
        "Get-SESIdentity/IdentityType"
        {
            $v = "Domain","EmailAddress"
            break
        }

        # Amazon.SimpleEmail.NotificationType
        {
            ($_ -eq "Set-SESIdentityHeadersInNotificationsEnabled/NotificationType") -Or
            ($_ -eq "Set-SESIdentityNotificationTopic/NotificationType")
        }
        {
            $v = "Bounce","Complaint","Delivery"
            break
        }

        # Amazon.SimpleEmail.ReceiptFilterPolicy
        "New-SESReceiptFilter/Filter_IpFilter_Policy"
        {
            $v = "Allow","Block"
            break
        }

        # Amazon.SimpleEmail.TlsPolicy
        {
            ($_ -eq "Write-SESConfigurationSetDeliveryOption/DeliveryOptions_TlsPolicy") -Or
            ($_ -eq "New-SESReceiptRule/Rule_TlsPolicy") -Or
            ($_ -eq "Update-SESReceiptRule/Rule_TlsPolicy")
        }
        {
            $v = "Optional","Require"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SES_map = @{
    "BehaviorOnMXFailure"=@("Set-SESIdentityMailFromDomain")
    "DeliveryOptions_TlsPolicy"=@("Write-SESConfigurationSetDeliveryOption")
    "Filter_IpFilter_Policy"=@("New-SESReceiptFilter")
    "IdentityType"=@("Get-SESIdentity")
    "NotificationType"=@("Set-SESIdentityHeadersInNotificationsEnabled","Set-SESIdentityNotificationTopic")
    "Rule_TlsPolicy"=@("New-SESReceiptRule","Update-SESReceiptRule")
}

_awsArgumentCompleterRegistration $SES_Completers $SES_map

$SES_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SES.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SES_SelectMap = @{
    "Select"=@("Copy-SESReceiptRuleSet",
               "New-SESConfigurationSet",
               "New-SESConfigurationSetEventDestination",
               "New-SESConfigurationSetTrackingOption",
               "New-SESCustomVerificationEmailTemplate",
               "New-SESReceiptFilter",
               "New-SESReceiptRule",
               "New-SESReceiptRuleSet",
               "New-SESTemplate",
               "Remove-SESConfigurationSet",
               "Remove-SESConfigurationSetEventDestination",
               "Remove-SESConfigurationSetTrackingOption",
               "Remove-SESCustomVerificationEmailTemplate",
               "Remove-SESIdentity",
               "Remove-SESIdentityPolicy",
               "Remove-SESReceiptFilter",
               "Remove-SESReceiptRule",
               "Remove-SESReceiptRuleSet",
               "Remove-SESTemplate",
               "Remove-SESVerifiedEmailAddress",
               "Get-SESActiveReceiptRuleSet",
               "Get-SESConfigurationSet",
               "Get-SESReceiptRule",
               "Get-SESReceiptRuleSet",
               "Get-SESAccountSendingEnabled",
               "Get-SESCustomVerificationEmailTemplate",
               "Get-SESIdentityDkimAttribute",
               "Get-SESIdentityMailFromDomainAttribute",
               "Get-SESIdentityNotificationAttribute",
               "Get-SESIdentityPolicy",
               "Get-SESIdentityVerificationAttribute",
               "Get-SESSendQuota",
               "Get-SESSendStatistic",
               "Get-SESTemplate",
               "Get-SESConfigurationSetList",
               "Get-SESCustomVerificationEmailTemplateList",
               "Get-SESIdentity",
               "Get-SESIdentityPolicyList",
               "Get-SESReceiptFilterList",
               "Get-SESReceiptRuleSetList",
               "Get-SESTemplateList",
               "Get-SESVerifiedEmailAddress",
               "Write-SESConfigurationSetDeliveryOption",
               "Write-SESIdentityPolicy",
               "Set-SESReceiptRuleSetOrder",
               "Send-SESBounce",
               "Send-SESBulkTemplatedEmail",
               "Send-SESCustomVerificationEmail",
               "Send-SESEmail",
               "Send-SESRawEmail",
               "Send-SESTemplatedEmail",
               "Set-SESActiveReceiptRuleSet",
               "Set-SESIdentityDkimEnabled",
               "Set-SESIdentityFeedbackForwardingEnabled",
               "Set-SESIdentityHeadersInNotificationsEnabled",
               "Set-SESIdentityMailFromDomain",
               "Set-SESIdentityNotificationTopic",
               "Set-SESReceiptRulePosition",
               "Test-SESRenderTemplate",
               "Update-SESAccountSendingEnabled",
               "Update-SESConfigurationSetEventDestination",
               "Update-SESConfigurationSetReputationMetricsEnabled",
               "Update-SESConfigurationSetSendingEnabled",
               "Update-SESConfigurationSetTrackingOption",
               "Update-SESCustomVerificationEmailTemplate",
               "Update-SESReceiptRule",
               "Update-SESTemplate",
               "Confirm-SESDomainDkim",
               "Confirm-SESDomainIdentity",
               "Confirm-SESEmailAddress",
               "Confirm-SESEmailIdentity")
}

_awsArgumentCompleterRegistration $SES_SelectCompleters $SES_SelectMap
# Argument completions for service AWS Marketplace Entitlement Service


$MES_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.MES.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MES_SelectMap = @{
    "Select"=@("Get-MESEntitlementList")
}

_awsArgumentCompleterRegistration $MES_SelectCompleters $MES_SelectMap
# Argument completions for service Amazon Elasticsearch


$ES_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Elasticsearch.ESPartitionInstanceType
        {
            ($_ -eq "New-ESDomain/ElasticsearchClusterConfig_DedicatedMasterType") -Or
            ($_ -eq "Update-ESDomainConfig/ElasticsearchClusterConfig_DedicatedMasterType") -Or
            ($_ -eq "New-ESDomain/ElasticsearchClusterConfig_InstanceType") -Or
            ($_ -eq "Update-ESDomainConfig/ElasticsearchClusterConfig_InstanceType") -Or
            ($_ -eq "Get-ESInstanceTypeLimit/InstanceType")
        }
        {
            $v = "c4.2xlarge.elasticsearch","c4.4xlarge.elasticsearch","c4.8xlarge.elasticsearch","c4.large.elasticsearch","c4.xlarge.elasticsearch","c5.18xlarge.elasticsearch","c5.2xlarge.elasticsearch","c5.4xlarge.elasticsearch","c5.9xlarge.elasticsearch","c5.large.elasticsearch","c5.xlarge.elasticsearch","d2.2xlarge.elasticsearch","d2.4xlarge.elasticsearch","d2.8xlarge.elasticsearch","d2.xlarge.elasticsearch","i2.2xlarge.elasticsearch","i2.xlarge.elasticsearch","i3.16xlarge.elasticsearch","i3.2xlarge.elasticsearch","i3.4xlarge.elasticsearch","i3.8xlarge.elasticsearch","i3.large.elasticsearch","i3.xlarge.elasticsearch","m3.2xlarge.elasticsearch","m3.large.elasticsearch","m3.medium.elasticsearch","m3.xlarge.elasticsearch","m4.10xlarge.elasticsearch","m4.2xlarge.elasticsearch","m4.4xlarge.elasticsearch","m4.large.elasticsearch","m4.xlarge.elasticsearch","m5.12xlarge.elasticsearch","m5.2xlarge.elasticsearch","m5.4xlarge.elasticsearch","m5.large.elasticsearch","m5.xlarge.elasticsearch","r3.2xlarge.elasticsearch","r3.4xlarge.elasticsearch","r3.8xlarge.elasticsearch","r3.large.elasticsearch","r3.xlarge.elasticsearch","r4.16xlarge.elasticsearch","r4.2xlarge.elasticsearch","r4.4xlarge.elasticsearch","r4.8xlarge.elasticsearch","r4.large.elasticsearch","r4.xlarge.elasticsearch","r5.12xlarge.elasticsearch","r5.2xlarge.elasticsearch","r5.4xlarge.elasticsearch","r5.large.elasticsearch","r5.xlarge.elasticsearch","t2.medium.elasticsearch","t2.micro.elasticsearch","t2.small.elasticsearch","ultrawarm1.large.elasticsearch","ultrawarm1.medium.elasticsearch"
            break
        }

        # Amazon.Elasticsearch.ESWarmPartitionInstanceType
        {
            ($_ -eq "New-ESDomain/ElasticsearchClusterConfig_WarmType") -Or
            ($_ -eq "Update-ESDomainConfig/ElasticsearchClusterConfig_WarmType")
        }
        {
            $v = "ultrawarm1.large.elasticsearch","ultrawarm1.medium.elasticsearch"
            break
        }

        # Amazon.Elasticsearch.TLSSecurityPolicy
        {
            ($_ -eq "New-ESDomain/DomainEndpointOptions_TLSSecurityPolicy") -Or
            ($_ -eq "Update-ESDomainConfig/DomainEndpointOptions_TLSSecurityPolicy")
        }
        {
            $v = "Policy-Min-TLS-1-0-2019-07","Policy-Min-TLS-1-2-2019-07"
            break
        }

        # Amazon.Elasticsearch.VolumeType
        {
            ($_ -eq "New-ESDomain/EBSOptions_VolumeType") -Or
            ($_ -eq "Update-ESDomainConfig/EBSOptions_VolumeType")
        }
        {
            $v = "gp2","io1","standard"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ES_map = @{
    "DomainEndpointOptions_TLSSecurityPolicy"=@("New-ESDomain","Update-ESDomainConfig")
    "EBSOptions_VolumeType"=@("New-ESDomain","Update-ESDomainConfig")
    "ElasticsearchClusterConfig_DedicatedMasterType"=@("New-ESDomain","Update-ESDomainConfig")
    "ElasticsearchClusterConfig_InstanceType"=@("New-ESDomain","Update-ESDomainConfig")
    "ElasticsearchClusterConfig_WarmType"=@("New-ESDomain","Update-ESDomainConfig")
    "InstanceType"=@("Get-ESInstanceTypeLimit")
}

_awsArgumentCompleterRegistration $ES_Completers $ES_map

$ES_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ES.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ES_SelectMap = @{
    "Select"=@("Add-ESResourceTag",
               "Stop-ESElasticsearchServiceSoftwareUpdate",
               "New-ESDomain",
               "Remove-ESDomain",
               "Remove-ESElasticsearchServiceRole",
               "Get-ESDomain",
               "Get-ESDomainConfig",
               "Get-ESDomainList",
               "Get-ESInstanceTypeLimit",
               "Get-ESReservedElasticsearchInstanceOfferingList",
               "Get-ESReservedElasticsearchInstanceList",
               "Get-ESCompatibleElasticsearchVersion",
               "Get-ESUpgradeHistory",
               "Get-ESUpgradeStatus",
               "Get-ESDomainNameList",
               "Get-ESInstanceTypeList",
               "Get-ESVersionList",
               "Get-ESResourceTag",
               "New-ESReservedElasticsearchInstanceOffering",
               "Remove-ESResourceTag",
               "Start-ESElasticsearchServiceSoftwareUpdate",
               "Update-ESDomainConfig",
               "Update-ESElasticsearchDomain")
}

_awsArgumentCompleterRegistration $ES_SelectCompleters $ES_SelectMap
# Argument completions for service Amazon EventBridge


$EVB_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.EventBridge.RuleState
        "Write-EVBRule/State"
        {
            $v = "DISABLED","ENABLED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EVB_map = @{
    "State"=@("Write-EVBRule")
}

_awsArgumentCompleterRegistration $EVB_Completers $EVB_map

$EVB_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EVB.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EVB_SelectMap = @{
    "Select"=@("Enable-EVBEventSource",
               "New-EVBEventBus",
               "New-EVBPartnerEventSource",
               "Disable-EVBEventSource",
               "Remove-EVBEventBus",
               "Remove-EVBPartnerEventSource",
               "Remove-EVBRule",
               "Get-EVBEventBus",
               "Get-EVBEventSource",
               "Get-EVBPartnerEventSource",
               "Get-EVBRuleDetail",
               "Disable-EVBRule",
               "Enable-EVBRule",
               "Get-EVBEventBusList",
               "Get-EVBEventSourceList",
               "Get-EVBPartnerEventSourceAccountList",
               "Get-EVBPartnerEventSourceList",
               "Get-EVBRuleNamesByTarget",
               "Get-EVBRule",
               "Get-EVBResourceTag",
               "Get-EVBTargetsByRule",
               "Write-EVBEvent",
               "Write-EVBPartnerEvent",
               "Write-EVBPermission",
               "Write-EVBRule",
               "Write-EVBTarget",
               "Remove-EVBPermission",
               "Remove-EVBTarget",
               "Add-EVBResourceTag",
               "Test-EVBEventPattern",
               "Remove-EVBResourceTag")
}

_awsArgumentCompleterRegistration $EVB_SelectCompleters $EVB_SelectMap
# Argument completions for service Amazon CloudWatch Events


$CWE_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CloudWatchEvents.RuleState
        "Write-CWERule/State"
        {
            $v = "DISABLED","ENABLED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CWE_map = @{
    "State"=@("Write-CWERule")
}

_awsArgumentCompleterRegistration $CWE_Completers $CWE_map

$CWE_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CWE.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CWE_SelectMap = @{
    "Select"=@("Enable-CWEEventSource",
               "New-CWEEventBus",
               "New-CWEPartnerEventSource",
               "Disable-CWEEventSource",
               "Remove-CWEEventBus",
               "Remove-CWEPartnerEventSource",
               "Remove-CWERule",
               "Get-CWEEventBus",
               "Get-CWEEventSource",
               "Get-CWEPartnerEventSource",
               "Get-CWERuleDetail",
               "Disable-CWERule",
               "Enable-CWERule",
               "Get-CWEEventBusList",
               "Get-CWEEventSourceList",
               "Get-CWEPartnerEventSourceAccountList",
               "Get-CWEPartnerEventSourceList",
               "Get-CWERuleNamesByTarget",
               "Get-CWERule",
               "Get-CWEResourceTag",
               "Get-CWETargetsByRule",
               "Write-CWEEvent",
               "Write-CWEPartnerEvent",
               "Write-CWEPermission",
               "Write-CWERule",
               "Write-CWETarget",
               "Remove-CWEPermission",
               "Remove-CWETarget",
               "Add-CWEResourceTag",
               "Test-CWEEventPattern",
               "Remove-CWEResourceTag")
}

_awsArgumentCompleterRegistration $CWE_SelectCompleters $CWE_SelectMap
# Argument completions for service Amazon Kinesis Firehose


$KINF_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.KinesisFirehose.DeliveryStreamType
        {
            ($_ -eq "Get-KINFDeliveryStreamList/DeliveryStreamType") -Or
            ($_ -eq "New-KINFDeliveryStream/DeliveryStreamType")
        }
        {
            $v = "DirectPut","KinesisStreamAsSource"
            break
        }

        # Amazon.KinesisFirehose.ElasticsearchIndexRotationPeriod
        {
            ($_ -eq "New-KINFDeliveryStream/ElasticsearchDestinationConfiguration_IndexRotationPeriod") -Or
            ($_ -eq "Update-KINFDestination/ElasticsearchDestinationUpdate_IndexRotationPeriod")
        }
        {
            $v = "NoRotation","OneDay","OneHour","OneMonth","OneWeek"
            break
        }

        # Amazon.KinesisFirehose.ElasticsearchS3BackupMode
        "New-KINFDeliveryStream/ElasticsearchDestinationConfiguration_S3BackupMode"
        {
            $v = "AllDocuments","FailedDocumentsOnly"
            break
        }

        # Amazon.KinesisFirehose.KeyType
        {
            ($_ -eq "New-KINFDeliveryStream/DeliveryStreamEncryptionConfigurationInput_KeyType") -Or
            ($_ -eq "Start-KINFDeliveryStreamEncryption/DeliveryStreamEncryptionConfigurationInput_KeyType")
        }
        {
            $v = "AWS_OWNED_CMK","CUSTOMER_MANAGED_CMK"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$KINF_map = @{
    "DeliveryStreamEncryptionConfigurationInput_KeyType"=@("New-KINFDeliveryStream","Start-KINFDeliveryStreamEncryption")
    "DeliveryStreamType"=@("Get-KINFDeliveryStreamList","New-KINFDeliveryStream")
    "ElasticsearchDestinationConfiguration_IndexRotationPeriod"=@("New-KINFDeliveryStream")
    "ElasticsearchDestinationConfiguration_S3BackupMode"=@("New-KINFDeliveryStream")
    "ElasticsearchDestinationUpdate_IndexRotationPeriod"=@("Update-KINFDestination")
}

_awsArgumentCompleterRegistration $KINF_Completers $KINF_map

$KINF_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.KINF.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$KINF_SelectMap = @{
    "Select"=@("New-KINFDeliveryStream",
               "Remove-KINFDeliveryStream",
               "Get-KINFDeliveryStream",
               "Get-KINFDeliveryStreamList",
               "Get-KINFTagsForDeliveryStream",
               "Write-KINFRecord",
               "Write-KINFRecordBatch",
               "Start-KINFDeliveryStreamEncryption",
               "Stop-KINFDeliveryStreamEncryption",
               "Add-KINFDeliveryStreamTag",
               "Remove-KINFDeliveryStreamTag",
               "Update-KINFDestination")
}

_awsArgumentCompleterRegistration $KINF_SelectCompleters $KINF_SelectMap
# Argument completions for service Firewall Management Service


$FMS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.FMS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$FMS_SelectMap = @{
    "Select"=@("Add-FMSAdminAccountAssociation",
               "Remove-FMSNotificationChannel",
               "Remove-FMSPolicy",
               "Remove-FMSAdminAccountAssociation",
               "Get-FMSAdminAccount",
               "Get-FMSComplianceDetail",
               "Get-FMSNotificationChannel",
               "Get-FMSPolicy",
               "Get-FMSProtectionStatus",
               "Get-FMSComplianceStatusList",
               "Get-FMSMemberAccountList",
               "Get-FMSPolicyList",
               "Write-FMSNotificationChannel",
               "Set-FMSPolicy")
}

_awsArgumentCompleterRegistration $FMS_SelectCompleters $FMS_SelectMap
# Argument completions for service Amazon Forecast Service


$FRC_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ForecastService.DatasetType
        "New-FRCDataset/DatasetType"
        {
            $v = "ITEM_METADATA","RELATED_TIME_SERIES","TARGET_TIME_SERIES"
            break
        }

        # Amazon.ForecastService.Domain
        {
            ($_ -eq "New-FRCDataset/Domain") -Or
            ($_ -eq "New-FRCDatasetGroup/Domain")
        }
        {
            $v = "CUSTOM","EC2_CAPACITY","INVENTORY_PLANNING","METRICS","RETAIL","WEB_TRAFFIC","WORK_FORCE"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$FRC_map = @{
    "DatasetType"=@("New-FRCDataset")
    "Domain"=@("New-FRCDataset","New-FRCDatasetGroup")
}

_awsArgumentCompleterRegistration $FRC_Completers $FRC_map

$FRC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.FRC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$FRC_SelectMap = @{
    "Select"=@("New-FRCDataset",
               "New-FRCDatasetGroup",
               "New-FRCDatasetImportJob",
               "New-FRCForecast",
               "New-FRCForecastExportJob",
               "New-FRCPredictor",
               "Remove-FRCDataset",
               "Remove-FRCDatasetGroup",
               "Remove-FRCDatasetImportJob",
               "Remove-FRCForecast",
               "Remove-FRCForecastExportJob",
               "Remove-FRCPredictor",
               "Get-FRCDataset",
               "Get-FRCDatasetGroup",
               "Get-FRCDatasetImportJob",
               "Get-FRCForecast",
               "Get-FRCForecastExportJob",
               "Get-FRCPredictor",
               "Get-FRCAccuracyMetric",
               "Get-FRCDatasetGroupList",
               "Get-FRCDatasetImportJobList",
               "Get-FRCDatasetList",
               "Get-FRCForecastExportJobList",
               "Get-FRCForecastList",
               "Get-FRCPredictorList",
               "Update-FRCDatasetGroup")
}

_awsArgumentCompleterRegistration $FRC_SelectCompleters $FRC_SelectMap
# Argument completions for service Amazon Forecast Query Service


$FRCQ_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.FRCQ.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$FRCQ_SelectMap = @{
    "Select"=@("Select-FRCQForecast")
}

_awsArgumentCompleterRegistration $FRCQ_SelectCompleters $FRCQ_SelectMap
# Argument completions for service Amazon Fraud Detector


$FD_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.FraudDetector.DataSource
        "New-FDVariable/DataSource"
        {
            $v = "EVENT","EXTERNAL_MODEL_SCORE","MODEL_SCORE"
            break
        }

        # Amazon.FraudDetector.DataType
        "New-FDVariable/DataType"
        {
            $v = "BOOLEAN","FLOAT","INTEGER","STRING"
            break
        }

        # Amazon.FraudDetector.DetectorVersionStatus
        "Update-FDDetectorVersionStatus/Status"
        {
            $v = "ACTIVE","DRAFT","INACTIVE"
            break
        }

        # Amazon.FraudDetector.Language
        {
            ($_ -eq "New-FDRule/Language") -Or
            ($_ -eq "Update-FDRuleVersion/Language")
        }
        {
            $v = "DETECTORPL"
            break
        }

        # Amazon.FraudDetector.ModelEndpointStatus
        "Write-FDExternalModel/ModelEndpointStatus"
        {
            $v = "ASSOCIATED","DISSOCIATED"
            break
        }

        # Amazon.FraudDetector.ModelInputDataFormat
        "Write-FDExternalModel/InputConfiguration_Format"
        {
            $v = "APPLICATION_JSON","TEXT_CSV"
            break
        }

        # Amazon.FraudDetector.ModelOutputDataFormat
        "Write-FDExternalModel/OutputConfiguration_Format"
        {
            $v = "APPLICATION_JSONLINES","TEXT_CSV"
            break
        }

        # Amazon.FraudDetector.ModelSource
        "Write-FDExternalModel/ModelSource"
        {
            $v = "SAGEMAKER"
            break
        }

        # Amazon.FraudDetector.ModelTypeEnum
        {
            ($_ -eq "Get-FDModel/ModelType") -Or
            ($_ -eq "Get-FDModelVersion/ModelType") -Or
            ($_ -eq "Get-FDModelVersionList/ModelType") -Or
            ($_ -eq "New-FDModelVersion/ModelType") -Or
            ($_ -eq "Update-FDModelVersion/ModelType") -Or
            ($_ -eq "Write-FDModel/ModelType")
        }
        {
            $v = "ONLINE_FRAUD_INSIGHTS"
            break
        }

        # Amazon.FraudDetector.ModelVersionStatus
        "Update-FDModelVersion/Status"
        {
            $v = "ACTIVATE_IN_PROGRESS","ACTIVATE_REQUESTED","ACTIVE","ERROR","INACTIVATE_IN_PROGRESS","INACTIVE","TRAINING_COMPLETE","TRAINING_IN_PROGRESS"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$FD_map = @{
    "DataSource"=@("New-FDVariable")
    "DataType"=@("New-FDVariable")
    "InputConfiguration_Format"=@("Write-FDExternalModel")
    "Language"=@("New-FDRule","Update-FDRuleVersion")
    "ModelEndpointStatus"=@("Write-FDExternalModel")
    "ModelSource"=@("Write-FDExternalModel")
    "ModelType"=@("Get-FDModel","Get-FDModelVersion","Get-FDModelVersionList","New-FDModelVersion","Update-FDModelVersion","Write-FDModel")
    "OutputConfiguration_Format"=@("Write-FDExternalModel")
    "Status"=@("Update-FDDetectorVersionStatus","Update-FDModelVersion")
}

_awsArgumentCompleterRegistration $FD_Completers $FD_map

$FD_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.FD.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$FD_SelectMap = @{
    "Select"=@("New-FDVariableBatch",
               "Get-FDVariableBatch",
               "New-FDDetectorVersion",
               "New-FDModelVersion",
               "New-FDRule",
               "New-FDVariable",
               "Remove-FDDetectorVersion",
               "Remove-FDEvent",
               "Get-FDDetectorVersionList",
               "Get-FDModelVersionList",
               "Get-FDDetector",
               "Get-FDDetectorVersion",
               "Get-FDExternalModel",
               "Get-FDModel",
               "Get-FDModelVersion",
               "Get-FDOutcome",
               "Get-FDPrediction",
               "Get-FDRule",
               "Get-FDVariable",
               "Write-FDDetector",
               "Write-FDExternalModel",
               "Write-FDModel",
               "Write-FDOutcome",
               "Update-FDDetectorVersion",
               "Update-FDDetectorVersionMetadata",
               "Update-FDDetectorVersionStatus",
               "Update-FDModelVersion",
               "Update-FDRuleMetadata",
               "Update-FDRuleVersion",
               "Update-FDVariable")
}

_awsArgumentCompleterRegistration $FD_SelectCompleters $FD_SelectMap
# Argument completions for service Amazon FSx


$FSX_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.FSx.FileSystemType
        "New-FSXFileSystem/FileSystemType"
        {
            $v = "LUSTRE","WINDOWS"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$FSX_map = @{
    "FileSystemType"=@("New-FSXFileSystem")
}

_awsArgumentCompleterRegistration $FSX_Completers $FSX_map

$FSX_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.FSX.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$FSX_SelectMap = @{
    "Select"=@("New-FSXBackup",
               "New-FSXFileSystem",
               "New-FSXFileSystemFromBackup",
               "Remove-FSXBackup",
               "Remove-FSXFileSystem",
               "Get-FSXBackup",
               "Get-FSXFileSystem",
               "Get-FSXResourceTagList",
               "Add-FSXResourceTag",
               "Remove-FSXResourceTag",
               "Update-FSXFileSystem")
}

_awsArgumentCompleterRegistration $FSX_SelectCompleters $FSX_SelectMap
# Argument completions for service Amazon GameLift Service


$GML_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.GameLift.AcceptanceType
        "Confirm-GMLMatch/AcceptanceType"
        {
            $v = "ACCEPT","REJECT"
            break
        }

        # Amazon.GameLift.BackfillMode
        {
            ($_ -eq "New-GMLMatchmakingConfiguration/BackfillMode") -Or
            ($_ -eq "Update-GMLMatchmakingConfiguration/BackfillMode")
        }
        {
            $v = "AUTOMATIC","MANUAL"
            break
        }

        # Amazon.GameLift.BuildStatus
        "Get-GMLBuild/Status"
        {
            $v = "FAILED","INITIALIZED","READY"
            break
        }

        # Amazon.GameLift.CertificateType
        "New-GMLFleet/CertificateConfiguration_CertificateType"
        {
            $v = "DISABLED","GENERATED"
            break
        }

        # Amazon.GameLift.ComparisonOperatorType
        "Write-GMLScalingPolicy/ComparisonOperator"
        {
            $v = "GreaterThanOrEqualToThreshold","GreaterThanThreshold","LessThanOrEqualToThreshold","LessThanThreshold"
            break
        }

        # Amazon.GameLift.EC2InstanceType
        {
            ($_ -eq "Get-GMLEC2InstanceLimit/EC2InstanceType") -Or
            ($_ -eq "New-GMLFleet/EC2InstanceType")
        }
        {
            $v = "c3.2xlarge","c3.4xlarge","c3.8xlarge","c3.large","c3.xlarge","c4.2xlarge","c4.4xlarge","c4.8xlarge","c4.large","c4.xlarge","c5.12xlarge","c5.18xlarge","c5.24xlarge","c5.2xlarge","c5.4xlarge","c5.9xlarge","c5.large","c5.xlarge","m3.2xlarge","m3.large","m3.medium","m3.xlarge","m4.10xlarge","m4.2xlarge","m4.4xlarge","m4.large","m4.xlarge","m5.12xlarge","m5.16xlarge","m5.24xlarge","m5.2xlarge","m5.4xlarge","m5.8xlarge","m5.large","m5.xlarge","r3.2xlarge","r3.4xlarge","r3.8xlarge","r3.large","r3.xlarge","r4.16xlarge","r4.2xlarge","r4.4xlarge","r4.8xlarge","r4.large","r4.xlarge","r5.12xlarge","r5.16xlarge","r5.24xlarge","r5.2xlarge","r5.4xlarge","r5.8xlarge","r5.large","r5.xlarge","t2.large","t2.medium","t2.micro","t2.small"
            break
        }

        # Amazon.GameLift.FleetType
        "New-GMLFleet/FleetType"
        {
            $v = "ON_DEMAND","SPOT"
            break
        }

        # Amazon.GameLift.MetricName
        "Write-GMLScalingPolicy/MetricName"
        {
            $v = "ActivatingGameSessions","ActiveGameSessions","ActiveInstances","AvailableGameSessions","AvailablePlayerSessions","CurrentPlayerSessions","IdleInstances","PercentAvailableGameSessions","PercentIdleInstances","QueueDepth","WaitTime"
            break
        }

        # Amazon.GameLift.OperatingSystem
        "New-GMLBuild/OperatingSystem"
        {
            $v = "AMAZON_LINUX","AMAZON_LINUX_2","WINDOWS_2012"
            break
        }

        # Amazon.GameLift.PlayerSessionCreationPolicy
        "Update-GMLGameSession/PlayerSessionCreationPolicy"
        {
            $v = "ACCEPT_ALL","DENY_ALL"
            break
        }

        # Amazon.GameLift.PolicyType
        "Write-GMLScalingPolicy/PolicyType"
        {
            $v = "RuleBased","TargetBased"
            break
        }

        # Amazon.GameLift.ProtectionPolicy
        {
            ($_ -eq "New-GMLFleet/NewGameSessionProtectionPolicy") -Or
            ($_ -eq "Update-GMLFleetAttribute/NewGameSessionProtectionPolicy") -Or
            ($_ -eq "Update-GMLGameSession/ProtectionPolicy")
        }
        {
            $v = "FullProtection","NoProtection"
            break
        }

        # Amazon.GameLift.RoutingStrategyType
        {
            ($_ -eq "New-GMLAlias/RoutingStrategy_Type") -Or
            ($_ -eq "Update-GMLAlias/RoutingStrategy_Type") -Or
            ($_ -eq "Get-GMLAlias/RoutingStrategyType")
        }
        {
            $v = "SIMPLE","TERMINAL"
            break
        }

        # Amazon.GameLift.ScalingAdjustmentType
        "Write-GMLScalingPolicy/ScalingAdjustmentType"
        {
            $v = "ChangeInCapacity","ExactCapacity","PercentChangeInCapacity"
            break
        }

        # Amazon.GameLift.ScalingStatusType
        "Get-GMLScalingPolicy/StatusFilter"
        {
            $v = "ACTIVE","DELETED","DELETE_REQUESTED","DELETING","ERROR","UPDATE_REQUESTED","UPDATING"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$GML_map = @{
    "AcceptanceType"=@("Confirm-GMLMatch")
    "BackfillMode"=@("New-GMLMatchmakingConfiguration","Update-GMLMatchmakingConfiguration")
    "CertificateConfiguration_CertificateType"=@("New-GMLFleet")
    "ComparisonOperator"=@("Write-GMLScalingPolicy")
    "EC2InstanceType"=@("Get-GMLEC2InstanceLimit","New-GMLFleet")
    "FleetType"=@("New-GMLFleet")
    "MetricName"=@("Write-GMLScalingPolicy")
    "NewGameSessionProtectionPolicy"=@("New-GMLFleet","Update-GMLFleetAttribute")
    "OperatingSystem"=@("New-GMLBuild")
    "PlayerSessionCreationPolicy"=@("Update-GMLGameSession")
    "PolicyType"=@("Write-GMLScalingPolicy")
    "ProtectionPolicy"=@("Update-GMLGameSession")
    "RoutingStrategy_Type"=@("New-GMLAlias","Update-GMLAlias")
    "RoutingStrategyType"=@("Get-GMLAlias")
    "ScalingAdjustmentType"=@("Write-GMLScalingPolicy")
    "Status"=@("Get-GMLBuild")
    "StatusFilter"=@("Get-GMLScalingPolicy")
}

_awsArgumentCompleterRegistration $GML_Completers $GML_map

$GML_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.GML.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$GML_SelectMap = @{
    "Select"=@("Confirm-GMLMatch",
               "New-GMLAlias",
               "New-GMLBuild",
               "New-GMLFleet",
               "New-GMLGameSession",
               "New-GMLGameSessionQueue",
               "New-GMLMatchmakingConfiguration",
               "New-GMLMatchmakingRuleSet",
               "New-GMLPlayerSession",
               "New-GMLScript",
               "New-GMLVpcPeeringAuthorization",
               "New-GMLVpcPeeringConnection",
               "Remove-GMLAlias",
               "Remove-GMLBuild",
               "Remove-GMLFleet",
               "Remove-GMLGameSessionQueue",
               "Remove-GMLMatchmakingConfiguration",
               "Remove-GMLMatchmakingRuleSet",
               "Remove-GMLScalingPolicy",
               "Remove-GMLScript",
               "Remove-GMLVpcPeeringAuthorization",
               "Remove-GMLVpcPeeringConnection",
               "Get-GMLAliasDetail",
               "Get-GMLBuildDetail",
               "Get-GMLEC2InstanceLimit",
               "Get-GMLFleetAttribute",
               "Get-GMLFleetCapacity",
               "Get-GMLFleetEvent",
               "Get-GMLFleetPortSetting",
               "Get-GMLFleetUtilization",
               "Get-GMLGameSessionDetail",
               "Get-GMLGameSessionPlacement",
               "Get-GMLGameSessionQueue",
               "Get-GMLGameSession",
               "Get-GMLInstance",
               "Get-GMLMatchmaking",
               "Get-GMLMatchmakingConfiguration",
               "Get-GMLMatchmakingRuleSet",
               "Get-GMLPlayerSession",
               "Get-GMLRuntimeConfiguration",
               "Get-GMLScalingPolicy",
               "Get-GMLScript",
               "Get-GMLVpcPeeringAuthorization",
               "Get-GMLVpcPeeringConnection",
               "Get-GMLGameSessionLogUrl",
               "Get-GMLInstanceAccess",
               "Get-GMLAlias",
               "Get-GMLBuild",
               "Get-GMLFleet",
               "Get-GMLScriptList",
               "Write-GMLScalingPolicy",
               "Request-GMLUploadCredential",
               "Resolve-GMLAlias",
               "Find-GMLGameSession",
               "Start-GMLFleetAction",
               "Start-GMLGameSessionPlacement",
               "Start-GMLMatchBackfill",
               "Start-GMLMatchmaking",
               "Stop-GMLFleetAction",
               "Stop-GMLGameSessionPlacement",
               "Stop-GMLMatchmaking",
               "Update-GMLAlias",
               "Update-GMLBuild",
               "Update-GMLFleetAttribute",
               "Update-GMLFleetCapacity",
               "Update-GMLFleetPortSetting",
               "Update-GMLGameSession",
               "Update-GMLGameSessionQueue",
               "Update-GMLMatchmakingConfiguration",
               "Update-GMLRuntimeConfiguration",
               "Update-GMLScript",
               "Test-GMLMatchmakingRuleSetValidity")
}

_awsArgumentCompleterRegistration $GML_SelectCompleters $GML_SelectMap
# Argument completions for service Amazon Glacier


$GLC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.GLC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$GLC_SelectMap = @{
    "Select"=@("Remove-GLCMultipartUpload",
               "Stop-GLCVaultLock",
               "Add-GLCTagsToVault",
               "Complete-GLCVaultLock",
               "New-GLCVault",
               "Remove-GLCArchive",
               "Remove-GLCVault",
               "Remove-GLCVaultAccessPolicy",
               "Remove-GLCVaultNotification",
               "Get-GLCJob",
               "Get-GLCVault",
               "Get-GLCDataRetrievalPolicy",
               "Get-GLCVaultAccessPolicy",
               "Get-GLCVaultLock",
               "Get-GLCVaultNotification",
               "Start-GLCJob",
               "Start-GLCVaultLock",
               "Get-GLCJobList",
               "Get-GLCMultipartUploadList",
               "Get-GLCProvisionedCapacityList",
               "Get-GLCVaultTagList",
               "Get-GLCVaultList",
               "New-GLCProvisionedCapacityPurchase",
               "Remove-GLCTagsFromVault",
               "Set-GLCDataRetrievalPolicy",
               "Set-GLCVaultAccessPolicy",
               "Set-GLCVaultNotification",
               "Read-GLCJobOutput",
               "Write-GLCArchive")
}

_awsArgumentCompleterRegistration $GLC_SelectCompleters $GLC_SelectMap
# Argument completions for service AWS Global Accelerator


$GACL_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.GlobalAccelerator.ClientAffinity
        {
            ($_ -eq "New-GACLListener/ClientAffinity") -Or
            ($_ -eq "Update-GACLListener/ClientAffinity")
        }
        {
            $v = "NONE","SOURCE_IP"
            break
        }

        # Amazon.GlobalAccelerator.HealthCheckProtocol
        {
            ($_ -eq "New-GACLEndpointGroup/HealthCheckProtocol") -Or
            ($_ -eq "Update-GACLEndpointGroup/HealthCheckProtocol")
        }
        {
            $v = "HTTP","HTTPS","TCP"
            break
        }

        # Amazon.GlobalAccelerator.IpAddressType
        {
            ($_ -eq "New-GACLAccelerator/IpAddressType") -Or
            ($_ -eq "Update-GACLAccelerator/IpAddressType")
        }
        {
            $v = "IPV4"
            break
        }

        # Amazon.GlobalAccelerator.Protocol
        {
            ($_ -eq "New-GACLListener/Protocol") -Or
            ($_ -eq "Update-GACLListener/Protocol")
        }
        {
            $v = "TCP","UDP"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$GACL_map = @{
    "ClientAffinity"=@("New-GACLListener","Update-GACLListener")
    "HealthCheckProtocol"=@("New-GACLEndpointGroup","Update-GACLEndpointGroup")
    "IpAddressType"=@("New-GACLAccelerator","Update-GACLAccelerator")
    "Protocol"=@("New-GACLListener","Update-GACLListener")
}

_awsArgumentCompleterRegistration $GACL_Completers $GACL_map

$GACL_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.GACL.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$GACL_SelectMap = @{
    "Select"=@("New-GACLAccelerator",
               "New-GACLEndpointGroup",
               "New-GACLListener",
               "Remove-GACLAccelerator",
               "Remove-GACLEndpointGroup",
               "Remove-GACLListener",
               "Get-GACLAccelerator",
               "Get-GACLAcceleratorAttribute",
               "Get-GACLEndpointGroup",
               "Get-GACLListener",
               "Get-GACLAcceleratorList",
               "Get-GACLEndpointGroupList",
               "Get-GACLListenerList",
               "Update-GACLAccelerator",
               "Update-GACLAcceleratorAttribute",
               "Update-GACLEndpointGroup",
               "Update-GACLListener")
}

_awsArgumentCompleterRegistration $GACL_SelectCompleters $GACL_SelectMap
# Argument completions for service AWS Glue


$GLUE_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Glue.CatalogEncryptionMode
        "Set-GLUEDataCatalogEncryptionSetting/DataCatalogEncryptionSettings_EncryptionAtRest_CatalogEncryptionMode"
        {
            $v = "DISABLED","SSE-KMS"
            break
        }

        # Amazon.Glue.CloudWatchEncryptionMode
        "New-GLUESecurityConfiguration/EncryptionConfiguration_CloudWatchEncryption_CloudWatchEncryptionMode"
        {
            $v = "DISABLED","SSE-KMS"
            break
        }

        # Amazon.Glue.CsvHeaderOption
        {
            ($_ -eq "New-GLUEClassifier/CsvClassifier_ContainsHeader") -Or
            ($_ -eq "Update-GLUEClassifier/CsvClassifier_ContainsHeader")
        }
        {
            $v = "ABSENT","PRESENT","UNKNOWN"
            break
        }

        # Amazon.Glue.ExistCondition
        "Set-GLUEResourcePolicy/PolicyExistsCondition"
        {
            $v = "MUST_EXIST","NONE","NOT_EXIST"
            break
        }

        # Amazon.Glue.JobBookmarksEncryptionMode
        "New-GLUESecurityConfiguration/EncryptionConfiguration_JobBookmarksEncryption_JobBookmarksEncryptionMode"
        {
            $v = "CSE-KMS","DISABLED"
            break
        }

        # Amazon.Glue.Language
        {
            ($_ -eq "Get-GLUEPlan/Language") -Or
            ($_ -eq "New-GLUEScript/Language")
        }
        {
            $v = "PYTHON","SCALA"
            break
        }

        # Amazon.Glue.SortDirectionType
        {
            ($_ -eq "Get-GLUEMLTaskRunList/Sort_SortDirection") -Or
            ($_ -eq "Get-GLUEMLTransformList/Sort_SortDirection")
        }
        {
            $v = "ASCENDING","DESCENDING"
            break
        }

        # Amazon.Glue.TaskRunSortColumnType
        "Get-GLUEMLTaskRunList/Sort_Column"
        {
            $v = "STARTED","STATUS","TASK_RUN_TYPE"
            break
        }

        # Amazon.Glue.TaskStatusType
        "Get-GLUEMLTaskRunList/Filter_Status"
        {
            $v = "FAILED","RUNNING","STARTING","STOPPED","STOPPING","SUCCEEDED","TIMEOUT"
            break
        }

        # Amazon.Glue.TaskType
        "Get-GLUEMLTaskRunList/Filter_TaskRunType"
        {
            $v = "EVALUATION","EXPORT_LABELS","FIND_MATCHES","IMPORT_LABELS","LABELING_SET_GENERATION"
            break
        }

        # Amazon.Glue.TransformSortColumnType
        "Get-GLUEMLTransformList/Sort_Column"
        {
            $v = "CREATED","LAST_MODIFIED","NAME","STATUS","TRANSFORM_TYPE"
            break
        }

        # Amazon.Glue.TransformStatusType
        "Get-GLUEMLTransformList/Filter_Status"
        {
            $v = "DELETING","NOT_READY","READY"
            break
        }

        # Amazon.Glue.TransformType
        {
            ($_ -eq "Get-GLUEMLTransformList/Filter_TransformType") -Or
            ($_ -eq "New-GLUEMLTransform/Parameters_TransformType") -Or
            ($_ -eq "Update-GLUEMLTransform/Parameters_TransformType")
        }
        {
            $v = "FIND_MATCHES"
            break
        }

        # Amazon.Glue.TriggerType
        "New-GLUETrigger/Type"
        {
            $v = "CONDITIONAL","ON_DEMAND","SCHEDULED"
            break
        }

        # Amazon.Glue.WorkerType
        {
            ($_ -eq "New-GLUEDevEndpoint/WorkerType") -Or
            ($_ -eq "New-GLUEJob/WorkerType") -Or
            ($_ -eq "New-GLUEMLTransform/WorkerType") -Or
            ($_ -eq "Start-GLUEJobRun/WorkerType") -Or
            ($_ -eq "Update-GLUEMLTransform/WorkerType")
        }
        {
            $v = "G.1X","G.2X","Standard"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$GLUE_map = @{
    "CsvClassifier_ContainsHeader"=@("New-GLUEClassifier","Update-GLUEClassifier")
    "DataCatalogEncryptionSettings_EncryptionAtRest_CatalogEncryptionMode"=@("Set-GLUEDataCatalogEncryptionSetting")
    "EncryptionConfiguration_CloudWatchEncryption_CloudWatchEncryptionMode"=@("New-GLUESecurityConfiguration")
    "EncryptionConfiguration_JobBookmarksEncryption_JobBookmarksEncryptionMode"=@("New-GLUESecurityConfiguration")
    "Filter_Status"=@("Get-GLUEMLTaskRunList","Get-GLUEMLTransformList")
    "Filter_TaskRunType"=@("Get-GLUEMLTaskRunList")
    "Filter_TransformType"=@("Get-GLUEMLTransformList")
    "Language"=@("Get-GLUEPlan","New-GLUEScript")
    "Parameters_TransformType"=@("New-GLUEMLTransform","Update-GLUEMLTransform")
    "PolicyExistsCondition"=@("Set-GLUEResourcePolicy")
    "Sort_Column"=@("Get-GLUEMLTaskRunList","Get-GLUEMLTransformList")
    "Sort_SortDirection"=@("Get-GLUEMLTaskRunList","Get-GLUEMLTransformList")
    "Type"=@("New-GLUETrigger")
    "WorkerType"=@("New-GLUEDevEndpoint","New-GLUEJob","New-GLUEMLTransform","Start-GLUEJobRun","Update-GLUEMLTransform")
}

_awsArgumentCompleterRegistration $GLUE_Completers $GLUE_map

$GLUE_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.GLUE.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$GLUE_SelectMap = @{
    "Select"=@("New-GLUEPartitionBatch",
               "Remove-GLUEConnectionBatch",
               "Remove-GLUEPartitionBatch",
               "Remove-GLUETableBatch",
               "Remove-GLUETableVersionBatch",
               "Get-GLUECrawlerBatch",
               "Get-GLUEDevEndpointBatch",
               "Get-GLUEJobBatch",
               "Get-GLUEPartitionBatch",
               "Get-GLUETriggerBatch",
               "Get-GLUEWorkflowBatch",
               "Stop-GLUEJobRunBatch",
               "Stop-GLUEMLTaskRun",
               "New-GLUEClassifier",
               "New-GLUEConnection",
               "New-GLUECrawler",
               "New-GLUEDatabase",
               "New-GLUEDevEndpoint",
               "New-GLUEJob",
               "New-GLUEMLTransform",
               "New-GLUEPartition",
               "New-GLUEScript",
               "New-GLUESecurityConfiguration",
               "New-GLUETable",
               "New-GLUETrigger",
               "New-GLUEUserDefinedFunction",
               "New-GLUEWorkflow",
               "Remove-GLUEClassifier",
               "Remove-GLUEConnection",
               "Remove-GLUECrawler",
               "Remove-GLUEDatabase",
               "Remove-GLUEDevEndpoint",
               "Remove-GLUEJob",
               "Remove-GLUEMLTransform",
               "Remove-GLUEPartition",
               "Remove-GLUEResourcePolicy",
               "Remove-GLUESecurityConfiguration",
               "Remove-GLUETable",
               "Remove-GLUETableVersion",
               "Remove-GLUETrigger",
               "Remove-GLUEUserDefinedFunction",
               "Remove-GLUEWorkflow",
               "Get-GLUECatalogImportStatus",
               "Get-GLUEClassifier",
               "Get-GLUEClassifierList",
               "Get-GLUEConnection",
               "Get-GLUEConnectionList",
               "Get-GLUECrawler",
               "Get-GLUECrawlerMetricList",
               "Get-GLUECrawlerList",
               "Get-GLUEDatabase",
               "Get-GLUEDatabaseList",
               "Get-GLUEDataCatalogEncryptionSetting",
               "Get-GLUEDataflowGraph",
               "Get-GLUEDevEndpoint",
               "Get-GLUEDevEndpointList",
               "Get-GLUEJob",
               "Get-GLUEJobBookmark",
               "Get-GLUEJobRun",
               "Get-GLUEJobRunList",
               "Get-GLUEJobList",
               "Get-GLUEMapping",
               "Get-GLUEMLTaskRun",
               "Get-GLUEMLTaskRunList",
               "Get-GLUEMLTransform",
               "Get-GLUEMLTransformList",
               "Get-GLUEPartition",
               "Get-GLUEPartitionList",
               "Get-GLUEPlan",
               "Get-GLUEResourcePolicy",
               "Get-GLUESecurityConfiguration",
               "Get-GLUESecurityConfigurationList",
               "Get-GLUETable",
               "Get-GLUETableList",
               "Get-GLUETableVersion",
               "Get-GLUETableVersionList",
               "Get-GLUETag",
               "Get-GLUETrigger",
               "Get-GLUETriggerList",
               "Get-GLUEUserDefinedFunction",
               "Get-GLUEUserDefinedFunctionList",
               "Get-GLUEWorkflow",
               "Get-GLUEWorkflowRun",
               "Get-GLUEWorkflowRunProperty",
               "Get-GLUEWorkflowRunList",
               "Import-GLUECatalog",
               "Get-GLUECrawlerNameList",
               "Get-GLUEDevEndpointNameList",
               "Get-GLUEJobNameList",
               "Get-GLUETriggerNameList",
               "Get-GLUEWorkflowList",
               "Set-GLUEDataCatalogEncryptionSetting",
               "Set-GLUEResourcePolicy",
               "Write-GLUEWorkflowRunProperty",
               "Reset-GLUEJobBookmark",
               "Find-GLUETable",
               "Start-GLUECrawler",
               "Start-GLUECrawlerSchedule",
               "Start-GLUEExportLabelsTaskRun",
               "Start-GLUEImportLabelsTaskRun",
               "Start-GLUEJobRun",
               "Start-GLUEMLEvaluationTaskRun",
               "Start-GLUEMLLabelingSetGenerationTaskRun",
               "Start-GLUETrigger",
               "Start-GLUEWorkflowRun",
               "Stop-GLUECrawler",
               "Stop-GLUECrawlerSchedule",
               "Stop-GLUETrigger",
               "Add-GLUEResourceTag",
               "Remove-GLUEResourceTag",
               "Update-GLUEClassifier",
               "Update-GLUEConnection",
               "Update-GLUECrawler",
               "Update-GLUECrawlerSchedule",
               "Update-GLUEDatabase",
               "Update-GLUEDevEndpoint",
               "Update-GLUEJob",
               "Update-GLUEMLTransform",
               "Update-GLUEPartition",
               "Update-GLUETable",
               "Update-GLUETrigger",
               "Update-GLUEUserDefinedFunction",
               "Update-GLUEWorkflow")
}

_awsArgumentCompleterRegistration $GLUE_SelectCompleters $GLUE_SelectMap
# Argument completions for service AWS Greengrass


$GG_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Greengrass.DeploymentType
        "New-GGDeployment/DeploymentType"
        {
            $v = "ForceResetDeployment","NewDeployment","Redeployment","ResetDeployment"
            break
        }

        # Amazon.Greengrass.FunctionIsolationMode
        {
            ($_ -eq "New-GGFunctionDefinitionVersion/DefaultConfig_Execution_IsolationMode") -Or
            ($_ -eq "New-GGFunctionDefinition/InitialVersion_DefaultConfig_Execution_IsolationMode")
        }
        {
            $v = "GreengrassContainer","NoContainer"
            break
        }

        # Amazon.Greengrass.SoftwareToUpdate
        "New-GGSoftwareUpdateJob/SoftwareToUpdate"
        {
            $v = "core","ota_agent"
            break
        }

        # Amazon.Greengrass.UpdateAgentLogLevel
        "New-GGSoftwareUpdateJob/UpdateAgentLogLevel"
        {
            $v = "DEBUG","ERROR","FATAL","INFO","NONE","TRACE","VERBOSE","WARN"
            break
        }

        # Amazon.Greengrass.UpdateTargetsArchitecture
        "New-GGSoftwareUpdateJob/UpdateTargetsArchitecture"
        {
            $v = "aarch64","armv6l","armv7l","x86_64"
            break
        }

        # Amazon.Greengrass.UpdateTargetsOperatingSystem
        "New-GGSoftwareUpdateJob/UpdateTargetsOperatingSystem"
        {
            $v = "amazon_linux","openwrt","raspbian","ubuntu"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$GG_map = @{
    "DefaultConfig_Execution_IsolationMode"=@("New-GGFunctionDefinitionVersion")
    "DeploymentType"=@("New-GGDeployment")
    "InitialVersion_DefaultConfig_Execution_IsolationMode"=@("New-GGFunctionDefinition")
    "SoftwareToUpdate"=@("New-GGSoftwareUpdateJob")
    "UpdateAgentLogLevel"=@("New-GGSoftwareUpdateJob")
    "UpdateTargetsArchitecture"=@("New-GGSoftwareUpdateJob")
    "UpdateTargetsOperatingSystem"=@("New-GGSoftwareUpdateJob")
}

_awsArgumentCompleterRegistration $GG_Completers $GG_map

$GG_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.GG.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$GG_SelectMap = @{
    "Select"=@("Add-GGRoleToGroup",
               "Add-GGServiceRoleToAccount",
               "New-GGConnectorDefinition",
               "New-GGConnectorDefinitionVersion",
               "New-GGCoreDefinition",
               "New-GGCoreDefinitionVersion",
               "New-GGDeployment",
               "New-GGDeviceDefinition",
               "New-GGDeviceDefinitionVersion",
               "New-GGFunctionDefinition",
               "New-GGFunctionDefinitionVersion",
               "New-GGGroup",
               "New-GGGroupCertificateAuthority",
               "New-GGGroupVersion",
               "New-GGLoggerDefinition",
               "New-GGLoggerDefinitionVersion",
               "New-GGResourceDefinition",
               "New-GGResourceDefinitionVersion",
               "New-GGSoftwareUpdateJob",
               "New-GGSubscriptionDefinition",
               "New-GGSubscriptionDefinitionVersion",
               "Remove-GGConnectorDefinition",
               "Remove-GGCoreDefinition",
               "Remove-GGDeviceDefinition",
               "Remove-GGFunctionDefinition",
               "Remove-GGGroup",
               "Remove-GGLoggerDefinition",
               "Remove-GGResourceDefinition",
               "Remove-GGSubscriptionDefinition",
               "Remove-GGRoleFromGroup",
               "Remove-GGServiceRoleFromAccount",
               "Get-GGAssociatedRole",
               "Get-GGBulkDeploymentStatus",
               "Get-GGConnectivityInfo",
               "Get-GGConnectorDefinition",
               "Get-GGConnectorDefinitionVersion",
               "Get-GGCoreDefinition",
               "Get-GGCoreDefinitionVersion",
               "Get-GGDeploymentStatus",
               "Get-GGDeviceDefinition",
               "Get-GGDeviceDefinitionVersion",
               "Get-GGFunctionDefinition",
               "Get-GGFunctionDefinitionVersion",
               "Get-GGGroup",
               "Get-GGGroupCertificateAuthority",
               "Get-GGGroupCertificateConfiguration",
               "Get-GGGroupVersion",
               "Get-GGLoggerDefinition",
               "Get-GGLoggerDefinitionVersion",
               "Get-GGResourceDefinition",
               "Get-GGResourceDefinitionVersion",
               "Get-GGServiceRoleForAccount",
               "Get-GGSubscriptionDefinition",
               "Get-GGSubscriptionDefinitionVersion",
               "Get-GGBulkDeploymentDetailedReportList",
               "Get-GGBulkDeploymentList",
               "Get-GGConnectorDefinitionList",
               "Get-GGConnectorDefinitionVersionList",
               "Get-GGCoreDefinitionList",
               "Get-GGCoreDefinitionVersionList",
               "Get-GGDeploymentList",
               "Get-GGDeviceDefinitionList",
               "Get-GGDeviceDefinitionVersionList",
               "Get-GGFunctionDefinitionList",
               "Get-GGFunctionDefinitionVersionList",
               "Get-GGGroupCertificateAuthorityList",
               "Get-GGGroupList",
               "Get-GGGroupVersionList",
               "Get-GGLoggerDefinitionList",
               "Get-GGLoggerDefinitionVersionList",
               "Get-GGResourceDefinitionList",
               "Get-GGResourceDefinitionVersionList",
               "Get-GGSubscriptionDefinitionList",
               "Get-GGSubscriptionDefinitionVersionList",
               "Get-GGResourceTag",
               "Reset-GGDeployment",
               "Start-GGBulkDeployment",
               "Stop-GGBulkDeployment",
               "Add-GGResourceTag",
               "Remove-GGResourceTag",
               "Update-GGConnectivityInfo",
               "Update-GGConnectorDefinition",
               "Update-GGCoreDefinition",
               "Update-GGDeviceDefinition",
               "Update-GGFunctionDefinition",
               "Update-GGGroup",
               "Update-GGGroupCertificateConfiguration",
               "Update-GGLoggerDefinition",
               "Update-GGResourceDefinition",
               "Update-GGSubscriptionDefinition")
}

_awsArgumentCompleterRegistration $GG_SelectCompleters $GG_SelectMap
# Argument completions for service AWS Ground Station


$GS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.GroundStation.ConfigCapabilityType
        {
            ($_ -eq "Get-GSConfig/ConfigType") -Or
            ($_ -eq "Remove-GSConfig/ConfigType") -Or
            ($_ -eq "Update-GSConfig/ConfigType")
        }
        {
            $v = "antenna-downlink","antenna-downlink-demod-decode","antenna-uplink","dataflow-endpoint","tracking","uplink-echo"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$GS_map = @{
    "ConfigType"=@("Get-GSConfig","Remove-GSConfig","Update-GSConfig")
}

_awsArgumentCompleterRegistration $GS_Completers $GS_map

$GS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.GS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$GS_SelectMap = @{
    "Select"=@("Stop-GSContact",
               "New-GSConfig",
               "New-GSDataflowEndpointGroup",
               "New-GSMissionProfile",
               "Remove-GSConfig",
               "Remove-GSDataflowEndpointGroup",
               "Remove-GSMissionProfile",
               "Get-GSContact",
               "Get-GSConfig",
               "Get-GSDataflowEndpointGroup",
               "Get-GSMinuteUsage",
               "Get-GSMissionProfile",
               "Get-GSSatellite",
               "Get-GSConfigList",
               "Get-GSContactList",
               "Get-GSDataflowEndpointGroupList",
               "Get-GSGroundStationList",
               "Get-GSMissionProfileList",
               "Get-GSSatelliteList",
               "Get-GSResourceTag",
               "Add-GSReservedContact",
               "Add-GSResourceTag",
               "Remove-GSResourceTag",
               "Update-GSConfig",
               "Update-GSMissionProfile")
}

_awsArgumentCompleterRegistration $GS_SelectCompleters $GS_SelectMap
# Argument completions for service Amazon GuardDuty


$GD_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.GuardDuty.DestinationType
        "New-GDPublishingDestination/DestinationType"
        {
            $v = "S3"
            break
        }

        # Amazon.GuardDuty.Feedback
        "Update-GDFindingFeedback/Feedback"
        {
            $v = "NOT_USEFUL","USEFUL"
            break
        }

        # Amazon.GuardDuty.FilterAction
        {
            ($_ -eq "New-GDFilter/Action") -Or
            ($_ -eq "Update-GDFilter/Action")
        }
        {
            $v = "ARCHIVE","NOOP"
            break
        }

        # Amazon.GuardDuty.FindingPublishingFrequency
        {
            ($_ -eq "New-GDDetector/FindingPublishingFrequency") -Or
            ($_ -eq "Update-GDDetector/FindingPublishingFrequency")
        }
        {
            $v = "FIFTEEN_MINUTES","ONE_HOUR","SIX_HOURS"
            break
        }

        # Amazon.GuardDuty.IpSetFormat
        "New-GDIPSet/Format"
        {
            $v = "ALIEN_VAULT","FIRE_EYE","OTX_CSV","PROOF_POINT","STIX","TXT"
            break
        }

        # Amazon.GuardDuty.ThreatIntelSetFormat
        "New-GDThreatIntelSet/Format"
        {
            $v = "ALIEN_VAULT","FIRE_EYE","OTX_CSV","PROOF_POINT","STIX","TXT"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$GD_map = @{
    "Action"=@("New-GDFilter","Update-GDFilter")
    "DestinationType"=@("New-GDPublishingDestination")
    "Feedback"=@("Update-GDFindingFeedback")
    "FindingPublishingFrequency"=@("New-GDDetector","Update-GDDetector")
    "Format"=@("New-GDIPSet","New-GDThreatIntelSet")
}

_awsArgumentCompleterRegistration $GD_Completers $GD_map

$GD_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.GD.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$GD_SelectMap = @{
    "Select"=@("Confirm-GDInvitation",
               "Backup-GDFinding",
               "New-GDDetector",
               "New-GDFilter",
               "New-GDIPSet",
               "New-GDMember",
               "New-GDPublishingDestination",
               "New-GDSampleFinding",
               "New-GDThreatIntelSet",
               "Deny-GDInvitation",
               "Remove-GDDetector",
               "Remove-GDFilter",
               "Remove-GDInvitation",
               "Remove-GDIPSet",
               "Remove-GDMember",
               "Remove-GDPublishingDestination",
               "Remove-GDThreatIntelSet",
               "Get-GDPublishingDestination",
               "Unregister-GDFromMasterAccount",
               "Unregister-GDMember",
               "Get-GDDetector",
               "Get-GDFilter",
               "Get-GDFinding",
               "Get-GDFindingStatistic",
               "Get-GDInvitationCount",
               "Get-GDIPSet",
               "Get-GDMasterAccount",
               "Get-GDMember",
               "Get-GDThreatIntelSet",
               "Send-GDMemberInvitation",
               "Get-GDDetectorList",
               "Get-GDFilterList",
               "Get-GDFindingList",
               "Get-GDInvitationList",
               "Get-GDIPSetList",
               "Get-GDMemberList",
               "Get-GDPublishingDestinationList",
               "Get-GDResourceTag",
               "Get-GDThreatIntelSetList",
               "Start-GDMonitoringMember",
               "Stop-GDMonitoringMember",
               "Add-GDResourceTag",
               "Restore-GDFinding",
               "Remove-GDResourceTag",
               "Update-GDDetector",
               "Update-GDFilter",
               "Update-GDFindingFeedback",
               "Update-GDIPSet",
               "Update-GDPublishingDestination",
               "Update-GDThreatIntelSet")
}

_awsArgumentCompleterRegistration $GD_SelectCompleters $GD_SelectMap
# Argument completions for service AWS Health


$HLTH_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.AWSHealth.EventAggregateField
        "Get-HLTHEventAggregate/AggregateField"
        {
            $v = "eventTypeCategory"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$HLTH_map = @{
    "AggregateField"=@("Get-HLTHEventAggregate")
}

_awsArgumentCompleterRegistration $HLTH_Completers $HLTH_map

$HLTH_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.HLTH.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$HLTH_SelectMap = @{
    "Select"=@("Get-HLTHAffectedEntity",
               "Get-HLTHEntityAggregate",
               "Get-HLTHEventAggregate",
               "Get-HLTHEventDetail",
               "Get-HLTHEvent",
               "Get-HLTHEventType")
}

_awsArgumentCompleterRegistration $HLTH_SelectCompleters $HLTH_SelectMap
# Argument completions for service AWS Identity and Access Management


$IAM_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.IdentityManagement.AssignmentStatusType
        "Get-IAMVirtualMFADevice/AssignmentStatus"
        {
            $v = "Any","Assigned","Unassigned"
            break
        }

        # Amazon.IdentityManagement.EncodingType
        "Get-IAMSSHPublicKey/Encoding"
        {
            $v = "PEM","SSH"
            break
        }

        # Amazon.IdentityManagement.EntityType
        "Get-IAMEntitiesForPolicy/EntityFilter"
        {
            $v = "AWSManagedPolicy","Group","LocalManagedPolicy","Role","User"
            break
        }

        # Amazon.IdentityManagement.GlobalEndpointTokenVersion
        "Set-IAMSecurityTokenServicePreference/GlobalEndpointTokenVersion"
        {
            $v = "v1Token","v2Token"
            break
        }

        # Amazon.IdentityManagement.PolicyScopeType
        "Get-IAMPolicyList/Scope"
        {
            $v = "All","AWS","Local"
            break
        }

        # Amazon.IdentityManagement.PolicyUsageType
        {
            ($_ -eq "Get-IAMEntitiesForPolicy/PolicyUsageFilter") -Or
            ($_ -eq "Get-IAMPolicyList/PolicyUsageFilter")
        }
        {
            $v = "PermissionsBoundary","PermissionsPolicy"
            break
        }

        # Amazon.IdentityManagement.SortKeyType
        "Get-IAMOrganizationsAccessReport/SortKey"
        {
            $v = "LAST_AUTHENTICATED_TIME_ASCENDING","LAST_AUTHENTICATED_TIME_DESCENDING","SERVICE_NAMESPACE_ASCENDING","SERVICE_NAMESPACE_DESCENDING"
            break
        }

        # Amazon.IdentityManagement.StatusType
        {
            ($_ -eq "Update-IAMAccessKey/Status") -Or
            ($_ -eq "Update-IAMServiceSpecificCredential/Status") -Or
            ($_ -eq "Update-IAMSigningCertificate/Status") -Or
            ($_ -eq "Update-IAMSSHPublicKey/Status")
        }
        {
            $v = "Active","Inactive"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IAM_map = @{
    "AssignmentStatus"=@("Get-IAMVirtualMFADevice")
    "Encoding"=@("Get-IAMSSHPublicKey")
    "EntityFilter"=@("Get-IAMEntitiesForPolicy")
    "GlobalEndpointTokenVersion"=@("Set-IAMSecurityTokenServicePreference")
    "PolicyUsageFilter"=@("Get-IAMEntitiesForPolicy","Get-IAMPolicyList")
    "Scope"=@("Get-IAMPolicyList")
    "SortKey"=@("Get-IAMOrganizationsAccessReport")
    "Status"=@("Update-IAMAccessKey","Update-IAMServiceSpecificCredential","Update-IAMSigningCertificate","Update-IAMSSHPublicKey")
}

_awsArgumentCompleterRegistration $IAM_Completers $IAM_map

$IAM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.IAM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IAM_SelectMap = @{
    "Select"=@("Add-IAMClientIDToOpenIDConnectProvider",
               "Add-IAMRoleToInstanceProfile",
               "Add-IAMUserToGroup",
               "Register-IAMGroupPolicy",
               "Register-IAMRolePolicy",
               "Register-IAMUserPolicy",
               "Edit-IAMPassword",
               "New-IAMAccessKey",
               "New-IAMAccountAlias",
               "New-IAMGroup",
               "New-IAMInstanceProfile",
               "New-IAMLoginProfile",
               "New-IAMOpenIDConnectProvider",
               "New-IAMPolicy",
               "New-IAMPolicyVersion",
               "New-IAMRole",
               "New-IAMSAMLProvider",
               "New-IAMServiceLinkedRole",
               "New-IAMServiceSpecificCredential",
               "New-IAMUser",
               "New-IAMVirtualMFADevice",
               "Disable-IAMMFADevice",
               "Remove-IAMAccessKey",
               "Remove-IAMAccountAlias",
               "Remove-IAMAccountPasswordPolicy",
               "Remove-IAMGroup",
               "Remove-IAMGroupPolicy",
               "Remove-IAMInstanceProfile",
               "Remove-IAMLoginProfile",
               "Remove-IAMOpenIDConnectProvider",
               "Remove-IAMPolicy",
               "Remove-IAMPolicyVersion",
               "Remove-IAMRole",
               "Remove-IAMRolePermissionsBoundary",
               "Remove-IAMRolePolicy",
               "Remove-IAMSAMLProvider",
               "Remove-IAMServerCertificate",
               "Remove-IAMServiceLinkedRole",
               "Remove-IAMServiceSpecificCredential",
               "Remove-IAMSigningCertificate",
               "Remove-IAMSSHPublicKey",
               "Remove-IAMUser",
               "Remove-IAMUserPermissionsBoundary",
               "Remove-IAMUserPolicy",
               "Remove-IAMVirtualMFADevice",
               "Unregister-IAMGroupPolicy",
               "Unregister-IAMRolePolicy",
               "Unregister-IAMUserPolicy",
               "Enable-IAMMFADevice",
               "Request-IAMCredentialReport",
               "New-IAMOrganizationsAccessReport",
               "Request-IAMServiceLastAccessedDetail",
               "Get-IAMAccessKeyLastUsed",
               "Get-IAMAccountAuthorizationDetail",
               "Get-IAMAccountPasswordPolicy",
               "Get-IAMAccountSummary",
               "Get-IAMContextKeysForCustomPolicy",
               "Get-IAMContextKeysForPrincipalPolicy",
               "Get-IAMCredentialReport",
               "Get-IAMGroup",
               "Get-IAMGroupPolicy",
               "Get-IAMInstanceProfile",
               "Get-IAMLoginProfile",
               "Get-IAMOpenIDConnectProvider",
               "Get-IAMOrganizationsAccessReport",
               "Get-IAMPolicy",
               "Get-IAMPolicyVersion",
               "Get-IAMRole",
               "Get-IAMRolePolicy",
               "Get-IAMSAMLProvider",
               "Get-IAMServerCertificate",
               "Get-IAMServiceLastAccessedDetail",
               "Get-IAMServiceLastAccessedDetailWithEntity",
               "Get-IAMServiceLinkedRoleDeletionStatus",
               "Get-IAMSSHPublicKey",
               "Get-IAMUser",
               "Get-IAMUserPolicy",
               "Get-IAMAccessKey",
               "Get-IAMAccountAlias",
               "Get-IAMAttachedGroupPolicyList",
               "Get-IAMAttachedRolePolicyList",
               "Get-IAMAttachedUserPolicyList",
               "Get-IAMEntitiesForPolicy",
               "Get-IAMGroupPolicyList",
               "Get-IAMGroupList",
               "Get-IAMGroupForUser",
               "Get-IAMInstanceProfileList",
               "Get-IAMInstanceProfileForRole",
               "Get-IAMMFADevice",
               "Get-IAMOpenIDConnectProviderList",
               "Get-IAMPolicyList",
               "Get-IAMPolicyGrantingServiceAccessList",
               "Get-IAMPolicyVersionList",
               "Get-IAMRolePolicyList",
               "Get-IAMRoleList",
               "Get-IAMRoleTagList",
               "Get-IAMSAMLProviderList",
               "Get-IAMServerCertificateList",
               "Get-IAMServiceSpecificCredentialList",
               "Get-IAMSigningCertificate",
               "Get-IAMSSHPublicKeyList",
               "Get-IAMUserPolicyList",
               "Get-IAMUserList",
               "Get-IAMUserTagList",
               "Get-IAMVirtualMFADevice",
               "Write-IAMGroupPolicy",
               "Set-IAMRolePermissionsBoundary",
               "Write-IAMRolePolicy",
               "Set-IAMUserPermissionsBoundary",
               "Write-IAMUserPolicy",
               "Remove-IAMClientIDFromOpenIDConnectProvider",
               "Remove-IAMRoleFromInstanceProfile",
               "Remove-IAMUserFromGroup",
               "Reset-IAMServiceSpecificCredential",
               "Sync-IAMMFADevice",
               "Set-IAMDefaultPolicyVersion",
               "Set-IAMSecurityTokenServicePreference",
               "Test-IAMCustomPolicy",
               "Test-IAMPrincipalPolicy",
               "Add-IAMRoleTag",
               "Add-IAMUserTag",
               "Remove-IAMRoleTag",
               "Remove-IAMUserTag",
               "Update-IAMAccessKey",
               "Update-IAMAccountPasswordPolicy",
               "Update-IAMAssumeRolePolicy",
               "Update-IAMGroup",
               "Update-IAMLoginProfile",
               "Update-IAMOpenIDConnectProviderThumbprint",
               "Update-IAMRole",
               "Update-IAMRoleDescription",
               "Update-IAMSAMLProvider",
               "Update-IAMServerCertificate",
               "Update-IAMServiceSpecificCredential",
               "Update-IAMSigningCertificate",
               "Update-IAMSSHPublicKey",
               "Update-IAMUser",
               "Publish-IAMServerCertificate",
               "Publish-IAMSigningCertificate",
               "Publish-IAMSSHPublicKey")
}

_awsArgumentCompleterRegistration $IAM_SelectCompleters $IAM_SelectMap
# Argument completions for service EC2 Image Builder


$EC2IB_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Imagebuilder.ComponentFormat
        "Import-EC2IBComponent/Format"
        {
            $v = "SHELL"
            break
        }

        # Amazon.Imagebuilder.ComponentType
        "Import-EC2IBComponent/Type"
        {
            $v = "BUILD","TEST"
            break
        }

        # Amazon.Imagebuilder.Ownership
        {
            ($_ -eq "Get-EC2IBComponentList/Owner") -Or
            ($_ -eq "Get-EC2IBImageList/Owner") -Or
            ($_ -eq "Get-EC2IBImageRecipeList/Owner")
        }
        {
            $v = "Amazon","Self","Shared"
            break
        }

        # Amazon.Imagebuilder.PipelineExecutionStartCondition
        {
            ($_ -eq "New-EC2IBImagePipeline/Schedule_PipelineExecutionStartCondition") -Or
            ($_ -eq "Update-EC2IBImagePipeline/Schedule_PipelineExecutionStartCondition")
        }
        {
            $v = "EXPRESSION_MATCH_AND_DEPENDENCY_UPDATES_AVAILABLE","EXPRESSION_MATCH_ONLY"
            break
        }

        # Amazon.Imagebuilder.PipelineStatus
        {
            ($_ -eq "New-EC2IBImagePipeline/Status") -Or
            ($_ -eq "Update-EC2IBImagePipeline/Status")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.Imagebuilder.Platform
        {
            ($_ -eq "Import-EC2IBComponent/Platform") -Or
            ($_ -eq "New-EC2IBComponent/Platform")
        }
        {
            $v = "Linux","Windows"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EC2IB_map = @{
    "Format"=@("Import-EC2IBComponent")
    "Owner"=@("Get-EC2IBComponentList","Get-EC2IBImageList","Get-EC2IBImageRecipeList")
    "Platform"=@("Import-EC2IBComponent","New-EC2IBComponent")
    "Schedule_PipelineExecutionStartCondition"=@("New-EC2IBImagePipeline","Update-EC2IBImagePipeline")
    "Status"=@("New-EC2IBImagePipeline","Update-EC2IBImagePipeline")
    "Type"=@("Import-EC2IBComponent")
}

_awsArgumentCompleterRegistration $EC2IB_Completers $EC2IB_map

$EC2IB_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EC2IB.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EC2IB_SelectMap = @{
    "Select"=@("Stop-EC2IBImageCreation",
               "New-EC2IBComponent",
               "New-EC2IBDistributionConfiguration",
               "New-EC2IBImage",
               "New-EC2IBImagePipeline",
               "New-EC2IBImageRecipe",
               "New-EC2IBInfrastructureConfiguration",
               "Remove-EC2IBComponent",
               "Remove-EC2IBDistributionConfiguration",
               "Remove-EC2IBImage",
               "Remove-EC2IBImagePipeline",
               "Remove-EC2IBImageRecipe",
               "Remove-EC2IBInfrastructureConfiguration",
               "Get-EC2IBComponent",
               "Get-EC2IBComponentPolicy",
               "Get-EC2IBDistributionConfiguration",
               "Get-EC2IBImage",
               "Get-EC2IBImagePipeline",
               "Get-EC2IBImagePolicy",
               "Get-EC2IBImageRecipe",
               "Get-EC2IBImageRecipePolicy",
               "Get-EC2IBInfrastructureConfiguration",
               "Import-EC2IBComponent",
               "Get-EC2IBComponentBuildVersionList",
               "Get-EC2IBComponentList",
               "Get-EC2IBDistributionConfigurationList",
               "Get-EC2IBImageBuildVersionList",
               "Get-EC2IBImagePipelineImageList",
               "Get-EC2IBImagePipelineList",
               "Get-EC2IBImageRecipeList",
               "Get-EC2IBImageList",
               "Get-EC2IBInfrastructureConfigurationList",
               "Get-EC2IBResourceTag",
               "Write-EC2IBComponentPolicy",
               "Write-EC2IBImagePolicy",
               "Write-EC2IBImageRecipePolicy",
               "Start-EC2IBImagePipelineExecution",
               "Add-EC2IBResourceTag",
               "Remove-EC2IBResourceTag",
               "Update-EC2IBDistributionConfiguration",
               "Update-EC2IBImagePipeline",
               "Update-EC2IBInfrastructureConfiguration")
}

_awsArgumentCompleterRegistration $EC2IB_SelectCompleters $EC2IB_SelectMap
# Argument completions for service AWS Import/Export


$IE_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ImportExport.JobType
        {
            ($_ -eq "New-IEJob/JobType") -Or
            ($_ -eq "Update-IEJob/JobType")
        }
        {
            $v = "Export","Import"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IE_map = @{
    "JobType"=@("New-IEJob","Update-IEJob")
}

_awsArgumentCompleterRegistration $IE_Completers $IE_map

$IE_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.IE.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IE_SelectMap = @{
    "Select"=@("Stop-IEJob",
               "New-IEJob",
               "Get-IEShippingLabel",
               "Get-IEStatus",
               "Get-IEJob",
               "Update-IEJob")
}

_awsArgumentCompleterRegistration $IE_SelectCompleters $IE_SelectMap
# Argument completions for service Amazon Inspector


$INS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Inspector.InspectorEvent
        {
            ($_ -eq "Add-INSEventSubscription/Event") -Or
            ($_ -eq "Remove-INSEventSubscription/Event")
        }
        {
            $v = "ASSESSMENT_RUN_COMPLETED","ASSESSMENT_RUN_STARTED","ASSESSMENT_RUN_STATE_CHANGED","FINDING_REPORTED","OTHER"
            break
        }

        # Amazon.Inspector.Locale
        {
            ($_ -eq "Get-INSExclusion/Locale") -Or
            ($_ -eq "Get-INSExclusionsPreview/Locale") -Or
            ($_ -eq "Get-INSFinding/Locale") -Or
            ($_ -eq "Get-INSRulesPackage/Locale")
        }
        {
            $v = "EN_US"
            break
        }

        # Amazon.Inspector.ReportFileFormat
        "Get-INSAssessmentReport/ReportFileFormat"
        {
            $v = "HTML","PDF"
            break
        }

        # Amazon.Inspector.ReportType
        "Get-INSAssessmentReport/ReportType"
        {
            $v = "FINDING","FULL"
            break
        }

        # Amazon.Inspector.StopAction
        "Stop-INSAssessmentRun/StopAction"
        {
            $v = "SKIP_EVALUATION","START_EVALUATION"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$INS_map = @{
    "Event"=@("Add-INSEventSubscription","Remove-INSEventSubscription")
    "Locale"=@("Get-INSExclusion","Get-INSExclusionsPreview","Get-INSFinding","Get-INSRulesPackage")
    "ReportFileFormat"=@("Get-INSAssessmentReport")
    "ReportType"=@("Get-INSAssessmentReport")
    "StopAction"=@("Stop-INSAssessmentRun")
}

_awsArgumentCompleterRegistration $INS_Completers $INS_map

$INS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.INS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$INS_SelectMap = @{
    "Select"=@("Add-INSFindingAttribute",
               "New-INSAssessmentTarget",
               "New-INSAssessmentTemplate",
               "New-INSExclusionsPreview",
               "New-INSResourceGroup",
               "Remove-INSAssessmentRun",
               "Remove-INSAssessmentTarget",
               "Remove-INSAssessmentTemplate",
               "Get-INSAssessmentRun",
               "Get-INSAssessmentTarget",
               "Get-INSAssessmentTemplate",
               "Get-INSCrossAccountAccessRole",
               "Get-INSExclusion",
               "Get-INSFinding",
               "Get-INSResourceGroup",
               "Get-INSRulesPackage",
               "Get-INSAssessmentReport",
               "Get-INSExclusionsPreview",
               "Get-INSTelemetryMetadata",
               "Get-INSAssessmentRunAgent",
               "Get-INSAssessmentRunList",
               "Get-INSAssessmentTargetList",
               "Get-INSAssessmentTemplateList",
               "Get-INSEventSubscription",
               "Get-INSExclusionList",
               "Get-INSFindingList",
               "Get-INSRulesPackageList",
               "Get-INSResourceTagList",
               "Get-INSAgentPreview",
               "Register-INSCrossAccountAccessRole",
               "Remove-INSFindingAttribute",
               "Set-INSResourceTag",
               "Start-INSAssessmentRun",
               "Stop-INSAssessmentRun",
               "Add-INSEventSubscription",
               "Remove-INSEventSubscription",
               "Update-INSAssessmentTarget")
}

_awsArgumentCompleterRegistration $INS_SelectCompleters $INS_SelectMap
# Argument completions for service AWS IoT


$IOT_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.IoT.AuditFrequency
        {
            ($_ -eq "New-IOTScheduledAudit/Frequency") -Or
            ($_ -eq "Update-IOTScheduledAudit/Frequency")
        }
        {
            $v = "BIWEEKLY","DAILY","MONTHLY","WEEKLY"
            break
        }

        # Amazon.IoT.AuditMitigationActionsExecutionStatus
        "Get-IOTAuditMitigationActionsExecutionList/ActionStatus"
        {
            $v = "CANCELED","COMPLETED","FAILED","IN_PROGRESS","PENDING","SKIPPED"
            break
        }

        # Amazon.IoT.AuditMitigationActionsTaskStatus
        "Get-IOTAuditMitigationActionsTaskList/TaskStatus"
        {
            $v = "CANCELED","COMPLETED","FAILED","IN_PROGRESS"
            break
        }

        # Amazon.IoT.AuditTaskStatus
        "Get-IOTTaskList/TaskStatus"
        {
            $v = "CANCELED","COMPLETED","FAILED","IN_PROGRESS"
            break
        }

        # Amazon.IoT.AuditTaskType
        "Get-IOTTaskList/TaskType"
        {
            $v = "ON_DEMAND_AUDIT_TASK","SCHEDULED_AUDIT_TASK"
            break
        }

        # Amazon.IoT.AuthorizerStatus
        {
            ($_ -eq "Get-IOTAuthorizerList/Status") -Or
            ($_ -eq "New-IOTAuthorizer/Status") -Or
            ($_ -eq "Update-IOTAuthorizer/Status")
        }
        {
            $v = "ACTIVE","INACTIVE"
            break
        }

        # Amazon.IoT.AutoRegistrationStatus
        "Update-IOTCACertificate/NewAutoRegistrationStatus"
        {
            $v = "DISABLE","ENABLE"
            break
        }

        # Amazon.IoT.CACertificateStatus
        "Update-IOTCACertificate/NewStatus"
        {
            $v = "ACTIVE","INACTIVE"
            break
        }

        # Amazon.IoT.CACertificateUpdateAction
        {
            ($_ -eq "New-IOTMitigationAction/ActionParams_UpdateCACertificateParams_Action") -Or
            ($_ -eq "Update-IOTMitigationAction/ActionParams_UpdateCACertificateParams_Action")
        }
        {
            $v = "DEACTIVATE"
            break
        }

        # Amazon.IoT.CannedAccessControlList
        {
            ($_ -eq "New-IOTTopicRule/TopicRulePayload_ErrorAction_S3_CannedAcl") -Or
            ($_ -eq "Set-IOTTopicRule/TopicRulePayload_ErrorAction_S3_CannedAcl")
        }
        {
            $v = "authenticated-read","aws-exec-read","bucket-owner-full-control","bucket-owner-read","log-delivery-write","private","public-read","public-read-write"
            break
        }

        # Amazon.IoT.CertificateStatus
        {
            ($_ -eq "Update-IOTCertificate/NewStatus") -Or
            ($_ -eq "Register-IOTCertificate/Status")
        }
        {
            $v = "ACTIVE","INACTIVE","PENDING_ACTIVATION","PENDING_TRANSFER","REGISTER_INACTIVE","REVOKED"
            break
        }

        # Amazon.IoT.DayOfWeek
        {
            ($_ -eq "New-IOTScheduledAudit/DayOfWeek") -Or
            ($_ -eq "Update-IOTScheduledAudit/DayOfWeek")
        }
        {
            $v = "FRI","MON","SAT","SUN","THU","TUE","WED"
            break
        }

        # Amazon.IoT.DeviceCertificateUpdateAction
        {
            ($_ -eq "New-IOTMitigationAction/ActionParams_UpdateDeviceCertificateParams_Action") -Or
            ($_ -eq "Update-IOTMitigationAction/ActionParams_UpdateDeviceCertificateParams_Action")
        }
        {
            $v = "DEACTIVATE"
            break
        }

        # Amazon.IoT.DomainConfigurationStatus
        "Update-IOTDomainConfiguration/DomainConfigurationStatus"
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.IoT.DynamoKeyType
        {
            ($_ -eq "New-IOTTopicRule/TopicRulePayload_ErrorAction_DynamoDB_HashKeyType") -Or
            ($_ -eq "Set-IOTTopicRule/TopicRulePayload_ErrorAction_DynamoDB_HashKeyType") -Or
            ($_ -eq "New-IOTTopicRule/TopicRulePayload_ErrorAction_DynamoDB_RangeKeyType") -Or
            ($_ -eq "Set-IOTTopicRule/TopicRulePayload_ErrorAction_DynamoDB_RangeKeyType")
        }
        {
            $v = "NUMBER","STRING"
            break
        }

        # Amazon.IoT.JobExecutionStatus
        {
            ($_ -eq "Get-IOTJobExecutionsForJobList/Status") -Or
            ($_ -eq "Get-IOTJobExecutionsForThingList/Status")
        }
        {
            $v = "CANCELED","FAILED","IN_PROGRESS","QUEUED","REJECTED","REMOVED","SUCCEEDED","TIMED_OUT"
            break
        }

        # Amazon.IoT.JobStatus
        "Get-IOTJobList/Status"
        {
            $v = "CANCELED","COMPLETED","DELETION_IN_PROGRESS","IN_PROGRESS"
            break
        }

        # Amazon.IoT.LogLevel
        {
            ($_ -eq "New-IOTMitigationAction/ActionParams_EnableIoTLoggingParams_LogLevel") -Or
            ($_ -eq "Update-IOTMitigationAction/ActionParams_EnableIoTLoggingParams_LogLevel") -Or
            ($_ -eq "Set-IOTV2LoggingOption/DefaultLogLevel") -Or
            ($_ -eq "Set-IOTLoggingOption/LoggingOptionsPayload_LogLevel") -Or
            ($_ -eq "Set-IOTV2LoggingLevel/LogLevel")
        }
        {
            $v = "DEBUG","DISABLED","ERROR","INFO","WARN"
            break
        }

        # Amazon.IoT.LogTargetType
        {
            ($_ -eq "Set-IOTV2LoggingLevel/LogTarget_TargetType") -Or
            ($_ -eq "Get-IOTV2LoggingLevelList/TargetType") -Or
            ($_ -eq "Remove-IOTV2LoggingLevel/TargetType")
        }
        {
            $v = "DEFAULT","THING_GROUP"
            break
        }

        # Amazon.IoT.MessageFormat
        {
            ($_ -eq "New-IOTTopicRule/TopicRulePayload_ErrorAction_Sns_MessageFormat") -Or
            ($_ -eq "Set-IOTTopicRule/TopicRulePayload_ErrorAction_Sns_MessageFormat")
        }
        {
            $v = "JSON","RAW"
            break
        }

        # Amazon.IoT.MitigationActionType
        "Get-IOTMitigationActionList/ActionType"
        {
            $v = "ADD_THINGS_TO_THING_GROUP","ENABLE_IOT_LOGGING","PUBLISH_FINDING_TO_SNS","REPLACE_DEFAULT_POLICY_VERSION","UPDATE_CA_CERTIFICATE","UPDATE_DEVICE_CERTIFICATE"
            break
        }

        # Amazon.IoT.OTAUpdateStatus
        "Get-IOTOTAUpdateList/OtaUpdateStatus"
        {
            $v = "CREATE_COMPLETE","CREATE_FAILED","CREATE_IN_PROGRESS","CREATE_PENDING"
            break
        }

        # Amazon.IoT.PolicyTemplateName
        {
            ($_ -eq "New-IOTMitigationAction/ActionParams_ReplaceDefaultPolicyVersionParams_TemplateName") -Or
            ($_ -eq "Update-IOTMitigationAction/ActionParams_ReplaceDefaultPolicyVersionParams_TemplateName")
        }
        {
            $v = "BLANK_POLICY"
            break
        }

        # Amazon.IoT.ReportType
        "Get-IOTThingRegistrationTaskReportList/ReportType"
        {
            $v = "ERRORS","RESULTS"
            break
        }

        # Amazon.IoT.ServiceType
        {
            ($_ -eq "Get-IOTDomainConfigurationList/ServiceType") -Or
            ($_ -eq "New-IOTDomainConfiguration/ServiceType")
        }
        {
            $v = "CREDENTIAL_PROVIDER","DATA","JOBS"
            break
        }

        # Amazon.IoT.Status
        "Get-IOTThingRegistrationTaskList/Status"
        {
            $v = "Cancelled","Cancelling","Completed","Failed","InProgress"
            break
        }

        # Amazon.IoT.TargetSelection
        {
            ($_ -eq "Get-IOTJobList/TargetSelection") -Or
            ($_ -eq "New-IOTJob/TargetSelection") -Or
            ($_ -eq "New-IOTOTAUpdate/TargetSelection")
        }
        {
            $v = "CONTINUOUS","SNAPSHOT"
            break
        }

        # Amazon.IoT.ThingConnectivityIndexingMode
        "Update-IOTIndexingConfiguration/ThingIndexingConfiguration_ThingConnectivityIndexingMode"
        {
            $v = "OFF","STATUS"
            break
        }

        # Amazon.IoT.ThingGroupIndexingMode
        "Update-IOTIndexingConfiguration/ThingGroupIndexingConfiguration_ThingGroupIndexingMode"
        {
            $v = "OFF","ON"
            break
        }

        # Amazon.IoT.ThingIndexingMode
        "Update-IOTIndexingConfiguration/ThingIndexingConfiguration_ThingIndexingMode"
        {
            $v = "OFF","REGISTRY","REGISTRY_AND_SHADOW"
            break
        }

        # Amazon.IoT.TopicRuleDestinationStatus
        "Update-IOTTopicRuleDestination/Status"
        {
            $v = "DISABLED","ENABLED","ERROR","IN_PROGRESS"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IOT_map = @{
    "ActionParams_EnableIoTLoggingParams_LogLevel"=@("New-IOTMitigationAction","Update-IOTMitigationAction")
    "ActionParams_ReplaceDefaultPolicyVersionParams_TemplateName"=@("New-IOTMitigationAction","Update-IOTMitigationAction")
    "ActionParams_UpdateCACertificateParams_Action"=@("New-IOTMitigationAction","Update-IOTMitigationAction")
    "ActionParams_UpdateDeviceCertificateParams_Action"=@("New-IOTMitigationAction","Update-IOTMitigationAction")
    "ActionStatus"=@("Get-IOTAuditMitigationActionsExecutionList")
    "ActionType"=@("Get-IOTMitigationActionList")
    "DayOfWeek"=@("New-IOTScheduledAudit","Update-IOTScheduledAudit")
    "DefaultLogLevel"=@("Set-IOTV2LoggingOption")
    "DomainConfigurationStatus"=@("Update-IOTDomainConfiguration")
    "Frequency"=@("New-IOTScheduledAudit","Update-IOTScheduledAudit")
    "LoggingOptionsPayload_LogLevel"=@("Set-IOTLoggingOption")
    "LogLevel"=@("Set-IOTV2LoggingLevel")
    "LogTarget_TargetType"=@("Set-IOTV2LoggingLevel")
    "NewAutoRegistrationStatus"=@("Update-IOTCACertificate")
    "NewStatus"=@("Update-IOTCACertificate","Update-IOTCertificate")
    "OtaUpdateStatus"=@("Get-IOTOTAUpdateList")
    "ReportType"=@("Get-IOTThingRegistrationTaskReportList")
    "ServiceType"=@("Get-IOTDomainConfigurationList","New-IOTDomainConfiguration")
    "Status"=@("Get-IOTAuthorizerList","Get-IOTJobExecutionsForJobList","Get-IOTJobExecutionsForThingList","Get-IOTJobList","Get-IOTThingRegistrationTaskList","New-IOTAuthorizer","Register-IOTCertificate","Update-IOTAuthorizer","Update-IOTTopicRuleDestination")
    "TargetSelection"=@("Get-IOTJobList","New-IOTJob","New-IOTOTAUpdate")
    "TargetType"=@("Get-IOTV2LoggingLevelList","Remove-IOTV2LoggingLevel")
    "TaskStatus"=@("Get-IOTAuditMitigationActionsTaskList","Get-IOTTaskList")
    "TaskType"=@("Get-IOTTaskList")
    "ThingGroupIndexingConfiguration_ThingGroupIndexingMode"=@("Update-IOTIndexingConfiguration")
    "ThingIndexingConfiguration_ThingConnectivityIndexingMode"=@("Update-IOTIndexingConfiguration")
    "ThingIndexingConfiguration_ThingIndexingMode"=@("Update-IOTIndexingConfiguration")
    "TopicRulePayload_ErrorAction_DynamoDB_HashKeyType"=@("New-IOTTopicRule","Set-IOTTopicRule")
    "TopicRulePayload_ErrorAction_DynamoDB_RangeKeyType"=@("New-IOTTopicRule","Set-IOTTopicRule")
    "TopicRulePayload_ErrorAction_S3_CannedAcl"=@("New-IOTTopicRule","Set-IOTTopicRule")
    "TopicRulePayload_ErrorAction_Sns_MessageFormat"=@("New-IOTTopicRule","Set-IOTTopicRule")
}

_awsArgumentCompleterRegistration $IOT_Completers $IOT_map

$IOT_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.IOT.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IOT_SelectMap = @{
    "Select"=@("Confirm-IOTCertificateTransfer",
               "Add-IOTThingToBillingGroup",
               "Add-IOTThingToThingGroup",
               "Add-IOTTargetsWithJob",
               "Add-IOTPolicy",
               "Add-IOTPrincipalPolicy",
               "Mount-IOTSecurityProfile",
               "Add-IOTThingPrincipal",
               "Stop-IOTAuditMitigationActionsTask",
               "Stop-IOTAuditTask",
               "Stop-IOTCertificateTransfer",
               "Stop-IOTJob",
               "Stop-IOTJobExecution",
               "Clear-IOTDefaultAuthorizer",
               "Confirm-IOTTopicRuleDestination",
               "New-IOTAuthorizer",
               "New-IOTBillingGroup",
               "New-IOTCertificateFromCsr",
               "New-IOTDomainConfiguration",
               "New-IOTDynamicThingGroup",
               "New-IOTJob",
               "New-IOTKeysAndCertificate",
               "New-IOTMitigationAction",
               "New-IOTOTAUpdate",
               "New-IOTPolicy",
               "New-IOTPolicyVersion",
               "New-IOTProvisioningClaim",
               "New-IOTProvisioningTemplate",
               "New-IOTProvisioningTemplateVersion",
               "New-IOTRoleAlias",
               "New-IOTScheduledAudit",
               "New-IOTSecurityProfile",
               "New-IOTStream",
               "New-IOTThing",
               "New-IOTThingGroup",
               "New-IOTThingType",
               "New-IOTTopicRule",
               "New-IOTTopicRuleDestination",
               "Remove-IOTAccountAuditConfiguration",
               "Remove-IOTAuthorizer",
               "Remove-IOTBillingGroup",
               "Remove-IOTCACertificate",
               "Remove-IOTCertificate",
               "Remove-IOTDomainConfiguration",
               "Remove-IOTDynamicThingGroup",
               "Remove-IOTJob",
               "Remove-IOTJobExecution",
               "Remove-IOTMitigationAction",
               "Remove-IOTOTAUpdate",
               "Remove-IOTPolicy",
               "Remove-IOTPolicyVersion",
               "Remove-IOTProvisioningTemplate",
               "Remove-IOTProvisioningTemplateVersion",
               "Remove-IOTRegistrationCode",
               "Remove-IOTRoleAlias",
               "Remove-IOTScheduledAudit",
               "Remove-IOTSecurityProfile",
               "Remove-IOTStream",
               "Remove-IOTThing",
               "Remove-IOTThingGroup",
               "Remove-IOTThingType",
               "Remove-IOTTopicRule",
               "Remove-IOTTopicRuleDestination",
               "Remove-IOTV2LoggingLevel",
               "Set-IOTThingTypeDeprecation",
               "Get-IOTAccountAuditConfiguration",
               "Get-IOTAuditFinding",
               "Get-IOTAuditMitigationActionsTask",
               "Get-IOTAuditTask",
               "Get-IOTAuthorizer",
               "Get-IOTBillingGroup",
               "Get-IOTCACertificate",
               "Get-IOTCertificate",
               "Get-IOTDefaultAuthorizer",
               "Get-IOTDomainConfiguration",
               "Get-IOTEndpoint",
               "Get-IOTEventConfiguration",
               "Get-IOTIndex",
               "Get-IOTJob",
               "Get-IOTJobExecution",
               "Get-IOTMitigationAction",
               "Get-IOTProvisioningTemplate",
               "Get-IOTProvisioningTemplateVersion",
               "Get-IOTRoleAlias",
               "Get-IOTScheduledAudit",
               "Get-IOTSecurityProfile",
               "Get-IOTStream",
               "Get-IOTThing",
               "Get-IOTThingGroup",
               "Get-IOTThingRegistrationTask",
               "Get-IOTThingType",
               "Dismount-IOTPolicy",
               "Remove-IOTPrincipalPolicy",
               "Dismount-IOTSecurityProfile",
               "Remove-IOTThingPrincipal",
               "Disable-IOTTopicRule",
               "Enable-IOTTopicRule",
               "Get-IOTCardinality",
               "Get-IOTEffectivePolicy",
               "Get-IOTIndexingConfiguration",
               "Get-IOTJobDocument",
               "Get-IOTLoggingOption",
               "Get-IOTOTAUpdate",
               "Get-IOTPercentile",
               "Get-IOTPolicy",
               "Get-IOTPolicyVersion",
               "Get-IOTRegistrationCode",
               "Get-IOTStatistic",
               "Get-IOTTopicRule",
               "Get-IOTTopicRuleDestination",
               "Get-IOTV2LoggingOption",
               "Get-IOTActiveViolationList",
               "Get-IOTAttachedPolicyList",
               "Get-IOTAuditFindingList",
               "Get-IOTAuditMitigationActionsExecutionList",
               "Get-IOTAuditMitigationActionsTaskList",
               "Get-IOTTaskList",
               "Get-IOTAuthorizerList",
               "Get-IOTBillingGroupList",
               "Get-IOTCACertificateList",
               "Get-IOTCertificateList",
               "Get-IOTCertificateListByCA",
               "Get-IOTDomainConfigurationList",
               "Get-IOTIndexList",
               "Get-IOTJobExecutionsForJobList",
               "Get-IOTJobExecutionsForThingList",
               "Get-IOTJobList",
               "Get-IOTMitigationActionList",
               "Get-IOTOTAUpdateList",
               "Get-IOTOutgoingCertificate",
               "Get-IOTPolicyList",
               "Get-IOTPolicyPrincipalList",
               "Get-IOTPolicyVersionList",
               "Get-IOTPrincipalPolicyList",
               "Get-IOTPrincipalThingList",
               "Get-IOTProvisioningTemplateList",
               "Get-IOTProvisioningTemplateVersionList",
               "Get-IOTRoleAliasList",
               "Get-IOTScheduledAuditList",
               "Get-IOTSecurityProfileList",
               "Get-IOTSecurityProfilesForTargetList",
               "Get-IOTStreamList",
               "Get-IOTTagListForResource",
               "Get-IOTTargetsForPolicyList",
               "Get-IOTTargetsForSecurityProfileList",
               "Get-IOTThingGroupList",
               "Get-IOTThingGroupsForThingList",
               "Get-IOTThingPrincipalList",
               "Get-IOTThingRegistrationTaskReportList",
               "Get-IOTThingRegistrationTaskList",
               "Get-IOTThingList",
               "Get-IOTThingsInBillingGroupList",
               "Get-IOTThingsInThingGroupList",
               "Get-IOTThingTypeList",
               "Get-IOTTopicRuleDestinationList",
               "Get-IOTTopicRuleList",
               "Get-IOTV2LoggingLevelList",
               "Get-IOTViolationEventList",
               "Register-IOTCACertificate",
               "Register-IOTCertificate",
               "Register-IOTThing",
               "Deny-IOTCertificateTransfer",
               "Remove-IOTThingFromBillingGroup",
               "Remove-IOTThingFromThingGroup",
               "Set-IOTTopicRule",
               "Search-IOTIndex",
               "Set-IOTDefaultAuthorizer",
               "Set-IOTDefaultPolicyVersion",
               "Set-IOTLoggingOption",
               "Set-IOTV2LoggingLevel",
               "Set-IOTV2LoggingOption",
               "Start-IOTAuditMitigationActionsTask",
               "Start-IOTOnDemandAuditTask",
               "Start-IOTThingRegistrationTask",
               "Stop-IOTThingRegistrationTask",
               "Add-IOTResourceTag",
               "Test-IOTAuthorization",
               "Test-IOTInvokeAuthorizer",
               "Request-IOTCertificateTransfer",
               "Remove-IOTResourceTag",
               "Update-IOTAccountAuditConfiguration",
               "Update-IOTAuthorizer",
               "Update-IOTBillingGroup",
               "Update-IOTCACertificate",
               "Update-IOTCertificate",
               "Update-IOTDomainConfiguration",
               "Update-IOTDynamicThingGroup",
               "Update-IOTEventConfiguration",
               "Update-IOTIndexingConfiguration",
               "Update-IOTJob",
               "Update-IOTMitigationAction",
               "Update-IOTProvisioningTemplate",
               "Update-IOTRoleAlias",
               "Update-IOTScheduledAudit",
               "Update-IOTSecurityProfile",
               "Update-IOTStream",
               "Update-IOTThing",
               "Update-IOTThingGroup",
               "Update-IOTThingGroupsForThing",
               "Update-IOTTopicRuleDestination",
               "Test-IOTValidSecurityProfileBehavior")
}

_awsArgumentCompleterRegistration $IOT_SelectCompleters $IOT_SelectMap
# Argument completions for service AWS IoT Events


$IOTE_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.IoTEvents.EvaluationMethod
        {
            ($_ -eq "New-IOTEDetectorModel/EvaluationMethod") -Or
            ($_ -eq "Update-IOTEDetectorModel/EvaluationMethod")
        }
        {
            $v = "BATCH","SERIAL"
            break
        }

        # Amazon.IoTEvents.LoggingLevel
        "Write-IOTELoggingOption/LoggingOptions_Level"
        {
            $v = "DEBUG","ERROR","INFO"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IOTE_map = @{
    "EvaluationMethod"=@("New-IOTEDetectorModel","Update-IOTEDetectorModel")
    "LoggingOptions_Level"=@("Write-IOTELoggingOption")
}

_awsArgumentCompleterRegistration $IOTE_Completers $IOTE_map

$IOTE_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.IOTE.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IOTE_SelectMap = @{
    "Select"=@("New-IOTEDetectorModel",
               "New-IOTEInput",
               "Remove-IOTEDetectorModel",
               "Remove-IOTEInput",
               "Get-IOTEDetectorModel",
               "Get-IOTEInput",
               "Get-IOTELoggingOption",
               "Get-IOTEDetectorModelList",
               "Get-IOTEDetectorModelVersionList",
               "Get-IOTEInputList",
               "Get-IOTEResourceTag",
               "Write-IOTELoggingOption",
               "Add-IOTEResourceTag",
               "Remove-IOTEResourceTag",
               "Update-IOTEDetectorModel",
               "Update-IOTEInput")
}

_awsArgumentCompleterRegistration $IOTE_SelectCompleters $IOTE_SelectMap
# Argument completions for service AWS IoT Events Data


$IOTED_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.IOTED.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IOTED_SelectMap = @{
    "Select"=@("Send-IOTEDMessageBatch",
               "Update-IOTEDDetectorBatch",
               "Get-IOTEDDetector",
               "Get-IOTEDDetectorList")
}

_awsArgumentCompleterRegistration $IOTED_SelectCompleters $IOTED_SelectMap
# Argument completions for service AWS IoT Jobs Data Plane


$IOTJ_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.IoTJobsDataPlane.JobExecutionStatus
        "Update-IOTJJobExecution/Status"
        {
            $v = "CANCELED","FAILED","IN_PROGRESS","QUEUED","REJECTED","REMOVED","SUCCEEDED","TIMED_OUT"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IOTJ_map = @{
    "Status"=@("Update-IOTJJobExecution")
}

_awsArgumentCompleterRegistration $IOTJ_Completers $IOTJ_map

$IOTJ_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.IOTJ.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IOTJ_SelectMap = @{
    "Select"=@("Get-IOTJJobExecution",
               "Get-IOTJPendingJobExecution",
               "Start-IOTJNextPendingJobExecution",
               "Update-IOTJJobExecution")
}

_awsArgumentCompleterRegistration $IOTJ_SelectCompleters $IOTJ_SelectMap
# Argument completions for service AWS IoT Secure Tunneling


$IOTST_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.IOTST.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IOTST_SelectMap = @{
    "Select"=@("Close-IOTSTTunnel",
               "Get-IOTSTTunnel",
               "Get-IOTSTResourceTag",
               "Get-IOTSTTunnelList",
               "Open-IOTSTTunnel",
               "Add-IOTSTResourceTag",
               "Remove-IOTSTResourceTag")
}

_awsArgumentCompleterRegistration $IOTST_SelectCompleters $IOTST_SelectMap
# Argument completions for service AWS IoT Things Graph


$IOTTG_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.IoTThingsGraph.DefinitionLanguage
        {
            ($_ -eq "New-IOTTGFlowTemplate/Definition_Language") -Or
            ($_ -eq "New-IOTTGSystemInstance/Definition_Language") -Or
            ($_ -eq "New-IOTTGSystemTemplate/Definition_Language") -Or
            ($_ -eq "Update-IOTTGFlowTemplate/Definition_Language") -Or
            ($_ -eq "Update-IOTTGSystemTemplate/Definition_Language") -Or
            ($_ -eq "Set-IOTTGEntityDefinition/Document_Language")
        }
        {
            $v = "GRAPHQL"
            break
        }

        # Amazon.IoTThingsGraph.DeploymentTarget
        "New-IOTTGSystemInstance/Target"
        {
            $v = "CLOUD","GREENGRASS"
            break
        }

        # Amazon.IoTThingsGraph.EntityType
        "Remove-IOTTGEntityFromThing/EntityType"
        {
            $v = "ACTION","CAPABILITY","DEVICE","DEVICE_MODEL","ENUM","EVENT","MAPPING","PROPERTY","SERVICE","STATE"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IOTTG_map = @{
    "Definition_Language"=@("New-IOTTGFlowTemplate","New-IOTTGSystemInstance","New-IOTTGSystemTemplate","Update-IOTTGFlowTemplate","Update-IOTTGSystemTemplate")
    "Document_Language"=@("Set-IOTTGEntityDefinition")
    "EntityType"=@("Remove-IOTTGEntityFromThing")
    "Target"=@("New-IOTTGSystemInstance")
}

_awsArgumentCompleterRegistration $IOTTG_Completers $IOTTG_map

$IOTTG_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.IOTTG.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$IOTTG_SelectMap = @{
    "Select"=@("Add-IOTTGEntityToThing",
               "New-IOTTGFlowTemplate",
               "New-IOTTGSystemInstance",
               "New-IOTTGSystemTemplate",
               "Remove-IOTTGFlowTemplate",
               "Remove-IOTTGNamespace",
               "Remove-IOTTGSystemInstance",
               "Remove-IOTTGSystemTemplate",
               "Add-IOTTGSystemInstanceDeployment",
               "Set-IOTTGFlowTemplateDeprecation",
               "Set-IOTTGSystemTemplateDeprecation",
               "Get-IOTTGNamespace",
               "Remove-IOTTGEntityFromThing",
               "Get-IOTTGEntity",
               "Get-IOTTGFlowTemplate",
               "Get-IOTTGFlowTemplateRevision",
               "Get-IOTTGNamespaceDeletionStatus",
               "Get-IOTTGSystemInstance",
               "Get-IOTTGSystemTemplate",
               "Get-IOTTGSystemTemplateRevision",
               "Get-IOTTGUploadStatus",
               "Get-IOTTGFlowExecutionMessageList",
               "Get-IOTTGResourceTag",
               "Search-IOTTGEntity",
               "Search-IOTTGFlowExecution",
               "Search-IOTTGFlowTemplate",
               "Search-IOTTGSystemInstance",
               "Search-IOTTGSystemTemplate",
               "Search-IOTTGThing",
               "Add-IOTTGResourceTag",
               "Remove-IOTTGSystemInstanceDeployment",
               "Remove-IOTTGResourceTag",
               "Update-IOTTGFlowTemplate",
               "Update-IOTTGSystemTemplate",
               "Set-IOTTGEntityDefinition")
}

_awsArgumentCompleterRegistration $IOTTG_SelectCompleters $IOTTG_SelectMap
# Argument completions for service Amazon Managed Streaming for Apache Kafka (MSK)


$MSK_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Kafka.ClientBroker
        "New-MSKCluster/EncryptionInfo_EncryptionInTransit_ClientBroker"
        {
            $v = "PLAINTEXT","TLS","TLS_PLAINTEXT"
            break
        }

        # Amazon.Kafka.EnhancedMonitoring
        {
            ($_ -eq "New-MSKCluster/EnhancedMonitoring") -Or
            ($_ -eq "Update-MSKMonitoring/EnhancedMonitoring")
        }
        {
            $v = "DEFAULT","PER_BROKER","PER_TOPIC_PER_BROKER"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MSK_map = @{
    "EncryptionInfo_EncryptionInTransit_ClientBroker"=@("New-MSKCluster")
    "EnhancedMonitoring"=@("New-MSKCluster","Update-MSKMonitoring")
}

_awsArgumentCompleterRegistration $MSK_Completers $MSK_map

$MSK_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.MSK.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MSK_SelectMap = @{
    "Select"=@("New-MSKCluster",
               "New-MSKConfiguration",
               "Remove-MSKCluster",
               "Get-MSKCluster",
               "Get-MSKClusterOperation",
               "Get-MSKConfiguration",
               "Get-MSKConfigurationRevision",
               "Get-MSKBootstrapBroker",
               "Get-MSKClusterOperationList",
               "Get-MSKClusterList",
               "Get-MSKConfigurationRevisionList",
               "Get-MSKConfigurationList",
               "Get-MSKNodeList",
               "Get-MSKResourceTag",
               "Add-MSKResourceTag",
               "Remove-MSKResourceTag",
               "Update-MSKBrokerCount",
               "Update-MSKBrokerStorage",
               "Update-MSKClusterConfiguration",
               "Update-MSKMonitoring")
}

_awsArgumentCompleterRegistration $MSK_SelectCompleters $MSK_SelectMap
# Argument completions for service Amazon Kendra


$KNDR_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Kendra.DataSourceSyncJobStatus
        "Get-KNDRDataSourceSyncJobList/StatusFilter"
        {
            $v = "ABORTED","FAILED","INCOMPLETE","STOPPING","SUCCEEDED","SYNCING"
            break
        }

        # Amazon.Kendra.DataSourceType
        "New-KNDRDataSource/Type"
        {
            $v = "DATABASE","S3","SHAREPOINT"
            break
        }

        # Amazon.Kendra.QueryResultType
        "Invoke-KNDRQuery/QueryResultTypeFilter"
        {
            $v = "ANSWER","DOCUMENT","QUESTION_ANSWER"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$KNDR_map = @{
    "QueryResultTypeFilter"=@("Invoke-KNDRQuery")
    "StatusFilter"=@("Get-KNDRDataSourceSyncJobList")
    "Type"=@("New-KNDRDataSource")
}

_awsArgumentCompleterRegistration $KNDR_Completers $KNDR_map

$KNDR_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.KNDR.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$KNDR_SelectMap = @{
    "Select"=@("Remove-KNDRDocumentBatch",
               "Write-KNDRDocumentBatch",
               "New-KNDRDataSource",
               "New-KNDRFaq",
               "New-KNDRIndex",
               "Remove-KNDRFaq",
               "Remove-KNDRIndex",
               "Get-KNDRDataSource",
               "Get-KNDRFaq",
               "Get-KNDRIndex",
               "Get-KNDRDataSourceList",
               "Get-KNDRDataSourceSyncJobList",
               "Get-KNDRFaqList",
               "Get-KNDRIndexList",
               "Invoke-KNDRQuery",
               "Start-KNDRDataSourceSyncJob",
               "Stop-KNDRDataSourceSyncJob",
               "Send-KNDRFeedback",
               "Update-KNDRDataSource",
               "Update-KNDRIndex")
}

_awsArgumentCompleterRegistration $KNDR_SelectCompleters $KNDR_SelectMap
# Argument completions for service Amazon Kinesis


$KIN_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Kinesis.EncryptionType
        {
            ($_ -eq "Start-KINStreamEncryption/EncryptionType") -Or
            ($_ -eq "Stop-KINStreamEncryption/EncryptionType")
        }
        {
            $v = "KMS","NONE"
            break
        }

        # Amazon.Kinesis.ScalingType
        "Update-KINShardCount/ScalingType"
        {
            $v = "UNIFORM_SCALING"
            break
        }

        # Amazon.Kinesis.ShardIteratorType
        "Get-KINShardIterator/ShardIteratorType"
        {
            $v = "AFTER_SEQUENCE_NUMBER","AT_SEQUENCE_NUMBER","AT_TIMESTAMP","LATEST","TRIM_HORIZON"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$KIN_map = @{
    "EncryptionType"=@("Start-KINStreamEncryption","Stop-KINStreamEncryption")
    "ScalingType"=@("Update-KINShardCount")
    "ShardIteratorType"=@("Get-KINShardIterator")
}

_awsArgumentCompleterRegistration $KIN_Completers $KIN_map

$KIN_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.KIN.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$KIN_SelectMap = @{
    "Select"=@("Add-KINTagsToStream",
               "New-KINStream",
               "Request-KINStreamRetentionPeriodDecrease",
               "Remove-KINStream",
               "Unregister-KINStreamConsumer",
               "Get-KINLimit",
               "Get-KINStream",
               "Get-KINStreamConsumer",
               "Get-KINStreamSummary",
               "Disable-KINEnhancedMonitoring",
               "Enable-KINEnhancedMonitoring",
               "Get-KINRecord",
               "Get-KINShardIterator",
               "Request-KINStreamRetentionPeriodIncrease",
               "Get-KINShardList",
               "Get-KINStreamConsumerList",
               "Get-KINStreamList",
               "Get-KINTagsForStream",
               "Merge-KINShard",
               "Write-KINRecord",
               "Write-KINMultipleRecord",
               "Register-KINStreamConsumer",
               "Remove-KINTagsFromStream",
               "Split-KINShard",
               "Start-KINStreamEncryption",
               "Stop-KINStreamEncryption",
               "Update-KINShardCount")
}

_awsArgumentCompleterRegistration $KIN_SelectCompleters $KIN_SelectMap
# Argument completions for service Amazon Kinesis Analytics


$KINA_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.KinesisAnalytics.InputStartingPosition
        "Find-KINAInputSchema/InputStartingPositionConfiguration_InputStartingPosition"
        {
            $v = "LAST_STOPPED_POINT","NOW","TRIM_HORIZON"
            break
        }

        # Amazon.KinesisAnalytics.RecordFormatType
        {
            ($_ -eq "Add-KINAApplicationInput/Input_InputSchema_RecordFormat_RecordFormatType") -Or
            ($_ -eq "Add-KINAApplicationOutput/Output_DestinationSchema_RecordFormatType") -Or
            ($_ -eq "Add-KINAApplicationReferenceDataSource/ReferenceDataSource_ReferenceSchema_RecordFormat_RecordFormatType")
        }
        {
            $v = "CSV","JSON"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$KINA_map = @{
    "Input_InputSchema_RecordFormat_RecordFormatType"=@("Add-KINAApplicationInput")
    "InputStartingPositionConfiguration_InputStartingPosition"=@("Find-KINAInputSchema")
    "Output_DestinationSchema_RecordFormatType"=@("Add-KINAApplicationOutput")
    "ReferenceDataSource_ReferenceSchema_RecordFormat_RecordFormatType"=@("Add-KINAApplicationReferenceDataSource")
}

_awsArgumentCompleterRegistration $KINA_Completers $KINA_map

$KINA_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.KINA.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$KINA_SelectMap = @{
    "Select"=@("Add-KINAApplicationCloudWatchLoggingOption",
               "Add-KINAApplicationInput",
               "Add-KINAApplicationInputProcessingConfiguration",
               "Add-KINAApplicationOutput",
               "Add-KINAApplicationReferenceDataSource",
               "New-KINAApplication",
               "Remove-KINAApplication",
               "Remove-KINAApplicationCloudWatchLoggingOption",
               "Remove-KINAApplicationInputProcessingConfiguration",
               "Remove-KINAApplicationOutput",
               "Remove-KINAApplicationReferenceDataSource",
               "Get-KINAApplication",
               "Find-KINAInputSchema",
               "Get-KINAResourceTag",
               "Start-KINAApplication",
               "Stop-KINAApplication",
               "Add-KINAResourceTag",
               "Remove-KINAResourceTag",
               "Update-KINAApplication",
               "Get-KINAApplicationList")
}

_awsArgumentCompleterRegistration $KINA_SelectCompleters $KINA_SelectMap
# Argument completions for service Amazon Kinesis Analytics V2


$KINA2_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.KinesisAnalyticsV2.RuntimeEnvironment
        "New-KINA2Application/RuntimeEnvironment"
        {
            $v = "FLINK-1_6","SQL-1_0"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$KINA2_map = @{
    "RuntimeEnvironment"=@("New-KINA2Application")
}

_awsArgumentCompleterRegistration $KINA2_Completers $KINA2_map

$KINA2_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.KINA2.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$KINA2_SelectMap = @{
    "Select"=@("Add-KINA2ApplicationCloudWatchLoggingOption",
               "Add-KINA2ApplicationInput",
               "Add-KINA2ApplicationInputProcessingConfiguration",
               "Add-KINA2ApplicationOutput",
               "Add-KINA2ApplicationReferenceDataSource",
               "Add-KINA2ApplicationVpcConfiguration",
               "New-KINA2Application",
               "New-KINA2ApplicationSnapshot",
               "Remove-KINA2Application",
               "Remove-KINA2ApplicationCloudWatchLoggingOption",
               "Remove-KINA2ApplicationInputProcessingConfiguration",
               "Remove-KINA2ApplicationOutput",
               "Remove-KINA2ApplicationReferenceDataSource",
               "Remove-KINA2ApplicationSnapshot",
               "Remove-KINA2ApplicationVpcConfiguration",
               "Get-KINA2Application",
               "Get-KINA2ApplicationSnapshot",
               "Find-KINA2InputSchema",
               "Get-KINA2ApplicationList",
               "Get-KINA2ApplicationSnapshotList",
               "Get-KINA2ResourceTag",
               "Start-KINA2Application",
               "Stop-KINA2Application",
               "Add-KINA2ResourceTag",
               "Remove-KINA2ResourceTag",
               "Update-KINA2Application")
}

_awsArgumentCompleterRegistration $KINA2_SelectCompleters $KINA2_SelectMap
# Argument completions for service Amazon Kinesis Video Streams


$KV_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.KinesisVideo.APIName
        "Get-KVDataEndpoint/APIName"
        {
            $v = "GET_DASH_STREAMING_SESSION_URL","GET_HLS_STREAMING_SESSION_URL","GET_MEDIA","GET_MEDIA_FOR_FRAGMENT_LIST","LIST_FRAGMENTS","PUT_MEDIA"
            break
        }

        # Amazon.KinesisVideo.ChannelRole
        "Get-KVSignalingChannelEndpoint/SingleMasterChannelEndpointConfiguration_Role"
        {
            $v = "MASTER","VIEWER"
            break
        }

        # Amazon.KinesisVideo.ChannelType
        "New-KVSignalingChannel/ChannelType"
        {
            $v = "SINGLE_MASTER"
            break
        }

        # Amazon.KinesisVideo.ComparisonOperator
        "Get-KVSignalingChannelList/ChannelNameCondition_ComparisonOperator"
        {
            $v = "BEGINS_WITH"
            break
        }

        # Amazon.KinesisVideo.UpdateDataRetentionOperation
        "Update-KVDataRetention/Operation"
        {
            $v = "DECREASE_DATA_RETENTION","INCREASE_DATA_RETENTION"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$KV_map = @{
    "APIName"=@("Get-KVDataEndpoint")
    "ChannelNameCondition_ComparisonOperator"=@("Get-KVSignalingChannelList")
    "ChannelType"=@("New-KVSignalingChannel")
    "Operation"=@("Update-KVDataRetention")
    "SingleMasterChannelEndpointConfiguration_Role"=@("Get-KVSignalingChannelEndpoint")
}

_awsArgumentCompleterRegistration $KV_Completers $KV_map

$KV_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.KV.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$KV_SelectMap = @{
    "Select"=@("New-KVSignalingChannel",
               "New-KVStream",
               "Remove-KVSignalingChannel",
               "Remove-KVStream",
               "Get-KVSignalingChannel",
               "Get-KVStream",
               "Get-KVDataEndpoint",
               "Get-KVSignalingChannelEndpoint",
               "Get-KVSignalingChannelList",
               "Get-KVStreamList",
               "Get-KVResourceTag",
               "Get-KVTagsForStreamList",
               "Add-KVResourceTag",
               "Add-KVStreamTag",
               "Remove-KVResourceTag",
               "Remove-KVStreamTag",
               "Update-KVDataRetention",
               "Update-KVSignalingChannel",
               "Update-KVStream")
}

_awsArgumentCompleterRegistration $KV_SelectCompleters $KV_SelectMap
# Argument completions for service Amazon Kinesis Video Streams Media


$KVM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.KVM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$KVM_SelectMap = @{
    "Select"=@("Get-KVMMedia")
}

_awsArgumentCompleterRegistration $KVM_SelectCompleters $KVM_SelectMap
# Argument completions for service Amazon Kinesis Video Signaling Channels


$KVSC_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.KinesisVideoSignalingChannels.Service
        "Get-KVSCIceServerConfig/Service"
        {
            $v = "TURN"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$KVSC_map = @{
    "Service"=@("Get-KVSCIceServerConfig")
}

_awsArgumentCompleterRegistration $KVSC_Completers $KVSC_map

$KVSC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.KVSC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$KVSC_SelectMap = @{
    "Select"=@("Get-KVSCIceServerConfig",
               "Send-KVSCAlexaOfferToMaster")
}

_awsArgumentCompleterRegistration $KVSC_SelectCompleters $KVSC_SelectMap
# Argument completions for service AWS Key Management Service


$KMS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.KeyManagementService.AlgorithmSpec
        "Get-KMSParametersForImport/WrappingAlgorithm"
        {
            $v = "RSAES_OAEP_SHA_1","RSAES_OAEP_SHA_256","RSAES_PKCS1_V1_5"
            break
        }

        # Amazon.KeyManagementService.CustomerMasterKeySpec
        "New-KMSKey/CustomerMasterKeySpec"
        {
            $v = "ECC_NIST_P256","ECC_NIST_P384","ECC_NIST_P521","ECC_SECG_P256K1","RSA_2048","RSA_3072","RSA_4096","SYMMETRIC_DEFAULT"
            break
        }

        # Amazon.KeyManagementService.DataKeyPairSpec
        {
            ($_ -eq "New-KMSDataKeyPair/KeyPairSpec") -Or
            ($_ -eq "New-KMSDataKeyPairWithoutPlaintext/KeyPairSpec")
        }
        {
            $v = "ECC_NIST_P256","ECC_NIST_P384","ECC_NIST_P521","ECC_SECG_P256K1","RSA_2048","RSA_3072","RSA_4096"
            break
        }

        # Amazon.KeyManagementService.DataKeySpec
        {
            ($_ -eq "New-KMSDataKey/KeySpec") -Or
            ($_ -eq "New-KMSDataKeyWithoutPlaintext/KeySpec")
        }
        {
            $v = "AES_128","AES_256"
            break
        }

        # Amazon.KeyManagementService.EncryptionAlgorithmSpec
        {
            ($_ -eq "Invoke-KMSReEncrypt/DestinationEncryptionAlgorithm") -Or
            ($_ -eq "Invoke-KMSDecrypt/EncryptionAlgorithm") -Or
            ($_ -eq "Invoke-KMSEncrypt/EncryptionAlgorithm") -Or
            ($_ -eq "Invoke-KMSReEncrypt/SourceEncryptionAlgorithm")
        }
        {
            $v = "RSAES_OAEP_SHA_1","RSAES_OAEP_SHA_256","SYMMETRIC_DEFAULT"
            break
        }

        # Amazon.KeyManagementService.ExpirationModelType
        "Import-KMSKeyMaterial/ExpirationModel"
        {
            $v = "KEY_MATERIAL_DOES_NOT_EXPIRE","KEY_MATERIAL_EXPIRES"
            break
        }

        # Amazon.KeyManagementService.KeyUsageType
        "New-KMSKey/KeyUsage"
        {
            $v = "ENCRYPT_DECRYPT","SIGN_VERIFY"
            break
        }

        # Amazon.KeyManagementService.MessageType
        {
            ($_ -eq "Invoke-KMSSigning/MessageType") -Or
            ($_ -eq "Test-KMSSignature/MessageType")
        }
        {
            $v = "DIGEST","RAW"
            break
        }

        # Amazon.KeyManagementService.OriginType
        "New-KMSKey/Origin"
        {
            $v = "AWS_CLOUDHSM","AWS_KMS","EXTERNAL"
            break
        }

        # Amazon.KeyManagementService.SigningAlgorithmSpec
        {
            ($_ -eq "Invoke-KMSSigning/SigningAlgorithm") -Or
            ($_ -eq "Test-KMSSignature/SigningAlgorithm")
        }
        {
            $v = "ECDSA_SHA_256","ECDSA_SHA_384","ECDSA_SHA_512","RSASSA_PKCS1_V1_5_SHA_256","RSASSA_PKCS1_V1_5_SHA_384","RSASSA_PKCS1_V1_5_SHA_512","RSASSA_PSS_SHA_256","RSASSA_PSS_SHA_384","RSASSA_PSS_SHA_512"
            break
        }

        # Amazon.KeyManagementService.WrappingKeySpec
        "Get-KMSParametersForImport/WrappingKeySpec"
        {
            $v = "RSA_2048"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$KMS_map = @{
    "CustomerMasterKeySpec"=@("New-KMSKey")
    "DestinationEncryptionAlgorithm"=@("Invoke-KMSReEncrypt")
    "EncryptionAlgorithm"=@("Invoke-KMSDecrypt","Invoke-KMSEncrypt")
    "ExpirationModel"=@("Import-KMSKeyMaterial")
    "KeyPairSpec"=@("New-KMSDataKeyPair","New-KMSDataKeyPairWithoutPlaintext")
    "KeySpec"=@("New-KMSDataKey","New-KMSDataKeyWithoutPlaintext")
    "KeyUsage"=@("New-KMSKey")
    "MessageType"=@("Invoke-KMSSigning","Test-KMSSignature")
    "Origin"=@("New-KMSKey")
    "SigningAlgorithm"=@("Invoke-KMSSigning","Test-KMSSignature")
    "SourceEncryptionAlgorithm"=@("Invoke-KMSReEncrypt")
    "WrappingAlgorithm"=@("Get-KMSParametersForImport")
    "WrappingKeySpec"=@("Get-KMSParametersForImport")
}

_awsArgumentCompleterRegistration $KMS_Completers $KMS_map

$KMS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.KMS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$KMS_SelectMap = @{
    "Select"=@("Stop-KMSKeyDeletion",
               "Connect-KMSCustomKeyStore",
               "New-KMSAlias",
               "New-KMSCustomKeyStore",
               "New-KMSGrant",
               "New-KMSKey",
               "Invoke-KMSDecrypt",
               "Remove-KMSAlias",
               "Remove-KMSCustomKeyStore",
               "Remove-KMSImportedKeyMaterial",
               "Get-KMSCustomKeyStore",
               "Get-KMSKey",
               "Disable-KMSKey",
               "Disable-KMSKeyRotation",
               "Disconnect-KMSCustomKeyStore",
               "Enable-KMSKey",
               "Enable-KMSKeyRotation",
               "Invoke-KMSEncrypt",
               "New-KMSDataKey",
               "New-KMSDataKeyPair",
               "New-KMSDataKeyPairWithoutPlaintext",
               "New-KMSDataKeyWithoutPlaintext",
               "New-KMSRandom",
               "Get-KMSKeyPolicy",
               "Get-KMSKeyRotationStatus",
               "Get-KMSParametersForImport",
               "Get-KMSPublicKey",
               "Import-KMSKeyMaterial",
               "Get-KMSAliasList",
               "Get-KMSGrantList",
               "Get-KMSKeyPolicyList",
               "Get-KMSKeyList",
               "Get-KMSResourceTag",
               "Get-KMSRetirableGrant",
               "Write-KMSKeyPolicy",
               "Invoke-KMSReEncrypt",
               "Disable-KMSGrant",
               "Revoke-KMSGrant",
               "Request-KMSKeyDeletion",
               "Invoke-KMSSigning",
               "Add-KMSResourceTag",
               "Remove-KMSResourceTag",
               "Update-KMSAlias",
               "Update-KMSCustomKeyStore",
               "Update-KMSKeyDescription",
               "Test-KMSSignature")
}

_awsArgumentCompleterRegistration $KMS_SelectCompleters $KMS_SelectMap
# Argument completions for service AWS Lake Formation


$LKF_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.LakeFormation.DataLakeResourceType
        "Get-LKFPermissionList/ResourceType"
        {
            $v = "CATALOG","DATABASE","DATA_LOCATION","TABLE"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$LKF_map = @{
    "ResourceType"=@("Get-LKFPermissionList")
}

_awsArgumentCompleterRegistration $LKF_Completers $LKF_map

$LKF_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.LKF.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$LKF_SelectMap = @{
    "Select"=@("Grant-LKFPermissionBatch",
               "Revoke-LKFPermissionBatch",
               "Unregister-LKFResource",
               "Get-LKFResource",
               "Get-LKFDataLakeSetting",
               "Get-LKFEffectivePermissionsForPath",
               "Grant-LKFPermission",
               "Get-LKFPermissionList",
               "Get-LKFResourceList",
               "Write-LKFDataLakeSetting",
               "Register-LKFResource",
               "Revoke-LKFPermission",
               "Update-LKFResource")
}

_awsArgumentCompleterRegistration $LKF_SelectCompleters $LKF_SelectMap
# Argument completions for service AWS Lambda


$LM_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Lambda.EventSourcePosition
        "New-LMEventSourceMapping/StartingPosition"
        {
            $v = "AT_TIMESTAMP","LATEST","TRIM_HORIZON"
            break
        }

        # Amazon.Lambda.FunctionVersion
        "Get-LMFunctionList/FunctionVersion"
        {
            $v = "ALL"
            break
        }

        # Amazon.Lambda.InvocationType
        "Invoke-LMFunction/InvocationType"
        {
            $v = "DryRun","Event","RequestResponse"
            break
        }

        # Amazon.Lambda.LogType
        "Invoke-LMFunction/LogType"
        {
            $v = "None","Tail"
            break
        }

        # Amazon.Lambda.Runtime
        {
            ($_ -eq "Get-LMLayerList/CompatibleRuntime") -Or
            ($_ -eq "Get-LMLayerVersionList/CompatibleRuntime") -Or
            ($_ -eq "Publish-LMFunction/Runtime") -Or
            ($_ -eq "Update-LMFunctionConfiguration/Runtime")
        }
        {
            $v = "dotnetcore1.0","dotnetcore2.0","dotnetcore2.1","go1.x","java11","java8","nodejs","nodejs10.x","nodejs12.x","nodejs4.3","nodejs4.3-edge","nodejs6.10","nodejs8.10","provided","python2.7","python3.6","python3.7","python3.8","ruby2.5"
            break
        }

        # Amazon.Lambda.TracingMode
        {
            ($_ -eq "Publish-LMFunction/TracingConfig_Mode") -Or
            ($_ -eq "Update-LMFunctionConfiguration/TracingConfig_Mode")
        }
        {
            $v = "Active","PassThrough"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$LM_map = @{
    "CompatibleRuntime"=@("Get-LMLayerList","Get-LMLayerVersionList")
    "FunctionVersion"=@("Get-LMFunctionList")
    "InvocationType"=@("Invoke-LMFunction")
    "LogType"=@("Invoke-LMFunction")
    "Runtime"=@("Publish-LMFunction","Update-LMFunctionConfiguration")
    "StartingPosition"=@("New-LMEventSourceMapping")
    "TracingConfig_Mode"=@("Publish-LMFunction","Update-LMFunctionConfiguration")
}

_awsArgumentCompleterRegistration $LM_Completers $LM_map

$LM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.LM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$LM_SelectMap = @{
    "Select"=@("Add-LMLayerVersionPermission",
               "Add-LMPermission",
               "New-LMAlias",
               "New-LMEventSourceMapping",
               "Publish-LMFunction",
               "Remove-LMAlias",
               "Remove-LMEventSourceMapping",
               "Remove-LMFunction",
               "Remove-LMFunctionConcurrency",
               "Remove-LMFunctionEventInvokeConfig",
               "Remove-LMLayerVersion",
               "Remove-LMProvisionedConcurrencyConfig",
               "Get-LMAccountSetting",
               "Get-LMAlias",
               "Get-LMEventSourceMapping",
               "Get-LMFunction",
               "Get-LMFunctionConcurrency",
               "Get-LMFunctionConfiguration",
               "Get-LMFunctionEventInvokeConfig",
               "Get-LMLayerVersion",
               "Get-LMLayerVersionByArn",
               "Get-LMLayerVersionPolicy",
               "Get-LMPolicy",
               "Get-LMProvisionedConcurrencyConfig",
               "Invoke-LMFunction",
               "Invoke-LMFunctionAsync",
               "Get-LMAliasList",
               "Get-LMEventSourceMappingList",
               "Get-LMFunctionEventInvokeConfigList",
               "Get-LMFunctionList",
               "Get-LMLayerList",
               "Get-LMLayerVersionList",
               "Get-LMProvisionedConcurrencyConfigList",
               "Get-LMResourceTag",
               "Get-LMVersionsByFunction",
               "Publish-LMLayerVersion",
               "Publish-LMVersion",
               "Write-LMFunctionConcurrency",
               "Write-LMFunctionEventInvokeConfig",
               "Write-LMProvisionedConcurrencyConfig",
               "Remove-LMLayerVersionPermission",
               "Remove-LMPermission",
               "Add-LMResourceTag",
               "Remove-LMResourceTag",
               "Update-LMAlias",
               "Update-LMEventSourceMapping",
               "Update-LMFunctionCode",
               "Update-LMFunctionConfiguration",
               "Update-LMFunctionEventInvokeConfig")
}

_awsArgumentCompleterRegistration $LM_SelectCompleters $LM_SelectMap
# Argument completions for service Amazon Lex Model Building Service


$LMB_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.LexModelBuildingService.ExportType
        "Get-LMBExport/ExportType"
        {
            $v = "ALEXA_SKILLS_KIT","LEX"
            break
        }

        # Amazon.LexModelBuildingService.FulfillmentActivityType
        "Write-LMBIntent/FulfillmentActivity_Type"
        {
            $v = "CodeHook","ReturnIntent"
            break
        }

        # Amazon.LexModelBuildingService.Locale
        {
            ($_ -eq "Get-LMBBuiltinIntentList/Locale") -Or
            ($_ -eq "Get-LMBBuiltinSlotType/Locale") -Or
            ($_ -eq "Write-LMBBot/Locale")
        }
        {
            $v = "de-DE","en-GB","en-US"
            break
        }

        # Amazon.LexModelBuildingService.MergeStrategy
        "Start-LMBImport/MergeStrategy"
        {
            $v = "FAIL_ON_CONFLICT","OVERWRITE_LATEST"
            break
        }

        # Amazon.LexModelBuildingService.ProcessBehavior
        "Write-LMBBot/ProcessBehavior"
        {
            $v = "BUILD","SAVE"
            break
        }

        # Amazon.LexModelBuildingService.ResourceType
        {
            ($_ -eq "Get-LMBExport/ResourceType") -Or
            ($_ -eq "Start-LMBImport/ResourceType")
        }
        {
            $v = "BOT","INTENT","SLOT_TYPE"
            break
        }

        # Amazon.LexModelBuildingService.SlotValueSelectionStrategy
        "Write-LMBSlotType/ValueSelectionStrategy"
        {
            $v = "ORIGINAL_VALUE","TOP_RESOLUTION"
            break
        }

        # Amazon.LexModelBuildingService.StatusType
        "Get-LMBUtterancesView/StatusType"
        {
            $v = "Detected","Missed"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$LMB_map = @{
    "ExportType"=@("Get-LMBExport")
    "FulfillmentActivity_Type"=@("Write-LMBIntent")
    "Locale"=@("Get-LMBBuiltinIntentList","Get-LMBBuiltinSlotType","Write-LMBBot")
    "MergeStrategy"=@("Start-LMBImport")
    "ProcessBehavior"=@("Write-LMBBot")
    "ResourceType"=@("Get-LMBExport","Start-LMBImport")
    "StatusType"=@("Get-LMBUtterancesView")
    "ValueSelectionStrategy"=@("Write-LMBSlotType")
}

_awsArgumentCompleterRegistration $LMB_Completers $LMB_map

$LMB_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.LMB.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$LMB_SelectMap = @{
    "Select"=@("New-LMBBotVersion",
               "New-LMBIntentVersion",
               "New-LMBSlotTypeVersion",
               "Remove-LMBBot",
               "Remove-LMBBotAlias",
               "Remove-LMBBotChannelAssociation",
               "Remove-LMBBotVersion",
               "Remove-LMBIntent",
               "Remove-LMBIntentVersion",
               "Remove-LMBSlotType",
               "Remove-LMBSlotTypeVersion",
               "Remove-LMBUtterance",
               "Get-LMBBot",
               "Get-LMBBotAlias",
               "Get-LMBBotAliasList",
               "Get-LMBBotChannelAssociation",
               "Get-LMBBotChannelAssociationList",
               "Get-LMBBotList",
               "Get-LMBBotVersionList",
               "Get-LMBBuiltinIntent",
               "Get-LMBBuiltinIntentList",
               "Get-LMBBuiltinSlotType",
               "Get-LMBExport",
               "Get-LMBImport",
               "Get-LMBIntent",
               "Get-LMBIntentList",
               "Get-LMBIntentVersion",
               "Get-LMBSlotType",
               "Get-LMBSlotTypeList",
               "Get-LMBSlotTypeVersionList",
               "Get-LMBUtterancesView",
               "Write-LMBBot",
               "Write-LMBBotAlias",
               "Write-LMBIntent",
               "Write-LMBSlotType",
               "Start-LMBImport")
}

_awsArgumentCompleterRegistration $LMB_SelectCompleters $LMB_SelectMap
# Argument completions for service AWS License Manager


$LICM_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.LicenseManager.LicenseConfigurationStatus
        "Update-LICMLicenseConfiguration/LicenseConfigurationStatus"
        {
            $v = "AVAILABLE","DISABLED"
            break
        }

        # Amazon.LicenseManager.LicenseCountingType
        "New-LICMLicenseConfiguration/LicenseCountingType"
        {
            $v = "Core","Instance","Socket","vCPU"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$LICM_map = @{
    "LicenseConfigurationStatus"=@("Update-LICMLicenseConfiguration")
    "LicenseCountingType"=@("New-LICMLicenseConfiguration")
}

_awsArgumentCompleterRegistration $LICM_Completers $LICM_map

$LICM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.LICM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$LICM_SelectMap = @{
    "Select"=@("New-LICMLicenseConfiguration",
               "Remove-LICMLicenseConfiguration",
               "Get-LICMLicenseConfiguration",
               "Get-LICMServiceSetting",
               "Get-LICMAssociationsForLicenseConfigurationList",
               "Get-LICMFailuresForLicenseConfigurationOperationList",
               "Get-LICMLicenseConfigurationList",
               "Get-LICMLicenseSpecificationsForResourceList",
               "Get-LICMResourceInventoryList",
               "Get-LICMResourceTagList",
               "Get-LICMUsageForLicenseConfigurationList",
               "Add-LICMResourceTag",
               "Remove-LICMResourceTag",
               "Update-LICMLicenseConfiguration",
               "Update-LICMLicenseSpecificationsForResource",
               "Update-LICMServiceSetting")
}

_awsArgumentCompleterRegistration $LICM_SelectCompleters $LICM_SelectMap
# Argument completions for service Amazon Lightsail


$LS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Lightsail.AddOnType
        {
            ($_ -eq "Enable-LSAddOn/AddOnRequest_AddOnType") -Or
            ($_ -eq "Disable-LSAddOn/AddOnType")
        }
        {
            $v = "AutoSnapshot"
            break
        }

        # Amazon.Lightsail.InstanceAccessProtocol
        "Get-LSInstanceAccessDetail/Protocol"
        {
            $v = "rdp","ssh"
            break
        }

        # Amazon.Lightsail.InstanceMetricName
        "Get-LSInstanceMetricData/MetricName"
        {
            $v = "CPUUtilization","NetworkIn","NetworkOut","StatusCheckFailed","StatusCheckFailed_Instance","StatusCheckFailed_System"
            break
        }

        # Amazon.Lightsail.LoadBalancerAttributeName
        "Update-LSLoadBalancerAttribute/AttributeName"
        {
            $v = "HealthCheckPath","SessionStickinessEnabled","SessionStickiness_LB_CookieDurationSeconds"
            break
        }

        # Amazon.Lightsail.LoadBalancerMetricName
        "Get-LSLoadBalancerMetricData/MetricName"
        {
            $v = "ClientTLSNegotiationErrorCount","HealthyHostCount","HTTPCode_Instance_2XX_Count","HTTPCode_Instance_3XX_Count","HTTPCode_Instance_4XX_Count","HTTPCode_Instance_5XX_Count","HTTPCode_LB_4XX_Count","HTTPCode_LB_5XX_Count","InstanceResponseTime","RejectedConnectionCount","RequestCount","UnhealthyHostCount"
            break
        }

        # Amazon.Lightsail.MetricUnit
        {
            ($_ -eq "Get-LSInstanceMetricData/Unit") -Or
            ($_ -eq "Get-LSLoadBalancerMetricData/Unit") -Or
            ($_ -eq "Get-LSRelationalDatabaseMetricData/Unit")
        }
        {
            $v = "Bits","Bits/Second","Bytes","Bytes/Second","Count","Count/Second","Gigabits","Gigabits/Second","Gigabytes","Gigabytes/Second","Kilobits","Kilobits/Second","Kilobytes","Kilobytes/Second","Megabits","Megabits/Second","Megabytes","Megabytes/Second","Microseconds","Milliseconds","None","Percent","Seconds","Terabits","Terabits/Second","Terabytes","Terabytes/Second"
            break
        }

        # Amazon.Lightsail.NetworkProtocol
        {
            ($_ -eq "Close-LSInstancePublicPort/PortInfo_Protocol") -Or
            ($_ -eq "Open-LSInstancePublicPort/PortInfo_Protocol")
        }
        {
            $v = "all","tcp","udp"
            break
        }

        # Amazon.Lightsail.RegionName
        "Copy-LSSnapshot/SourceRegion"
        {
            $v = "ap-northeast-1","ap-northeast-2","ap-south-1","ap-southeast-1","ap-southeast-2","ca-central-1","eu-central-1","eu-west-1","eu-west-2","eu-west-3","us-east-1","us-east-2","us-west-1","us-west-2"
            break
        }

        # Amazon.Lightsail.RelationalDatabaseMetricName
        "Get-LSRelationalDatabaseMetricData/MetricName"
        {
            $v = "CPUUtilization","DatabaseConnections","DiskQueueDepth","FreeStorageSpace","NetworkReceiveThroughput","NetworkTransmitThroughput"
            break
        }

        # Amazon.Lightsail.RelationalDatabasePasswordVersion
        "Get-LSRelationalDatabaseMasterUserPassword/PasswordVersion"
        {
            $v = "CURRENT","PENDING","PREVIOUS"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$LS_map = @{
    "AddOnRequest_AddOnType"=@("Enable-LSAddOn")
    "AddOnType"=@("Disable-LSAddOn")
    "AttributeName"=@("Update-LSLoadBalancerAttribute")
    "MetricName"=@("Get-LSInstanceMetricData","Get-LSLoadBalancerMetricData","Get-LSRelationalDatabaseMetricData")
    "PasswordVersion"=@("Get-LSRelationalDatabaseMasterUserPassword")
    "PortInfo_Protocol"=@("Close-LSInstancePublicPort","Open-LSInstancePublicPort")
    "Protocol"=@("Get-LSInstanceAccessDetail")
    "SourceRegion"=@("Copy-LSSnapshot")
    "Unit"=@("Get-LSInstanceMetricData","Get-LSLoadBalancerMetricData","Get-LSRelationalDatabaseMetricData")
}

_awsArgumentCompleterRegistration $LS_Completers $LS_map

$LS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.LS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$LS_SelectMap = @{
    "Select"=@("New-LSStaticIp",
               "Add-LSDisk",
               "Add-LSInstancesToLoadBalancer",
               "Add-LSLoadBalancerTlsCertificate",
               "Mount-LSStaticIp",
               "Close-LSInstancePublicPort",
               "Copy-LSSnapshot",
               "New-LSCloudFormationStack",
               "New-LSDisk",
               "New-LSDiskFromSnapshot",
               "New-LSDiskSnapshot",
               "New-LSDomain",
               "New-LSDomainEntry",
               "New-LSInstance",
               "New-LSInstancesFromSnapshot",
               "New-LSInstanceSnapshot",
               "New-LSKeyPair",
               "New-LSLoadBalancer",
               "New-LSLoadBalancerTlsCertificate",
               "New-LSRelationalDatabase",
               "New-LSRelationalDatabaseFromSnapshot",
               "New-LSRelationalDatabaseSnapshot",
               "Remove-LSAutoSnapshot",
               "Remove-LSDisk",
               "Remove-LSDiskSnapshot",
               "Remove-LSDomain",
               "Remove-LSDomainEntry",
               "Remove-LSInstance",
               "Remove-LSInstanceSnapshot",
               "Remove-LSKeyPair",
               "Remove-LSKnownHostKey",
               "Remove-LSLoadBalancer",
               "Remove-LSLoadBalancerTlsCertificate",
               "Remove-LSRelationalDatabase",
               "Remove-LSRelationalDatabaseSnapshot",
               "Dismount-LSDisk",
               "Dismount-LSInstancesFromLoadBalancer",
               "Dismount-LSStaticIp",
               "Disable-LSAddOn",
               "Read-LSDefaultKeyPair",
               "Enable-LSAddOn",
               "Export-LSSnapshot",
               "Get-LSActiveNameList",
               "Get-LSAutoSnapshot",
               "Get-LSBlueprintList",
               "Get-LSBundleList",
               "Get-LSCloudFormationStackRecord",
               "Get-LSDisk",
               "Get-LSDiskList",
               "Get-LSDiskSnapshot",
               "Get-LSDiskSnapshotList",
               "Get-LSDomain",
               "Get-LSDomainList",
               "Get-LSExportSnapshotRecord",
               "Get-LSInstance",
               "Get-LSInstanceAccessDetail",
               "Get-LSInstanceMetricData",
               "Get-LSInstancePortStateList",
               "Get-LSInstanceList",
               "Get-LSInstanceSnapshot",
               "Get-LSInstanceSnapshotList",
               "Get-LSInstanceState",
               "Get-LSKeyPairInfo",
               "Get-LSKeypairList",
               "Get-LSLoadBalancer",
               "Get-LSLoadBalancerMetricData",
               "Get-LSLoadBalancerList",
               "Get-LSLoadBalancerTlsCertificate",
               "Get-LSOperation",
               "Get-LSOperationList",
               "Get-LSOperationListForResource",
               "Get-LSRegionList",
               "Get-LSRelationalDatabase",
               "Get-LSRelationalDatabaseBlueprint",
               "Get-LSRelationalDatabaseBundle",
               "Get-LSRelationalDatabaseEvent",
               "Get-LSRelationalDatabaseLogEvent",
               "Get-LSRelationalDatabaseLogStream",
               "Get-LSRelationalDatabaseMasterUserPassword",
               "Get-LSRelationalDatabaseMetricData",
               "Get-LSRelationalDatabaseParameter",
               "Get-LSRelationalDatabaseList",
               "Get-LSRelationalDatabaseSnapshot",
               "Get-LSRelationalDatabaseSnapshotList",
               "Get-LSStaticIp",
               "Get-LSStaticIpList",
               "Import-LSKeyPair",
               "Test-LSVpcPeered",
               "Open-LSInstancePublicPort",
               "Add-LSPeerVpc",
               "Set-LSInstancePublicPort",
               "Restart-LSInstance",
               "Restart-LSRelationalDatabase",
               "Remove-LSStaticIp",
               "Start-LSInstance",
               "Start-LSRelationalDatabase",
               "Stop-LSInstance",
               "Stop-LSRelationalDatabase",
               "Add-LSResourceTag",
               "Remove-LSPeerVpc",
               "Remove-LSResourceTag",
               "Update-LSDomainEntry",
               "Update-LSLoadBalancerAttribute",
               "Update-LSRelationalDatabase",
               "Update-LSRelationalDatabaseParameter")
}

_awsArgumentCompleterRegistration $LS_SelectCompleters $LS_SelectMap
# Argument completions for service Amazon CloudWatch Logs


$CWL_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CloudWatchLogs.Distribution
        "Write-CWLSubscriptionFilter/Distribution"
        {
            $v = "ByLogStream","Random"
            break
        }

        # Amazon.CloudWatchLogs.ExportTaskStatusCode
        "Get-CWLExportTask/StatusCode"
        {
            $v = "CANCELLED","COMPLETED","FAILED","PENDING","PENDING_CANCEL","RUNNING"
            break
        }

        # Amazon.CloudWatchLogs.OrderBy
        "Get-CWLLogStream/OrderBy"
        {
            $v = "LastEventTime","LogStreamName"
            break
        }

        # Amazon.CloudWatchLogs.QueryStatus
        "Get-CWLQuery/Status"
        {
            $v = "Cancelled","Complete","Failed","Running","Scheduled"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CWL_map = @{
    "Distribution"=@("Write-CWLSubscriptionFilter")
    "OrderBy"=@("Get-CWLLogStream")
    "Status"=@("Get-CWLQuery")
    "StatusCode"=@("Get-CWLExportTask")
}

_awsArgumentCompleterRegistration $CWL_Completers $CWL_map

$CWL_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CWL.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CWL_SelectMap = @{
    "Select"=@("Register-CWLKmsKey",
               "Stop-CWLExportTask",
               "New-CWLExportTask",
               "New-CWLLogGroup",
               "New-CWLLogStream",
               "Remove-CWLDestination",
               "Remove-CWLLogGroup",
               "Remove-CWLLogStream",
               "Remove-CWLMetricFilter",
               "Remove-CWLResourcePolicy",
               "Remove-CWLRetentionPolicy",
               "Remove-CWLSubscriptionFilter",
               "Get-CWLDestination",
               "Get-CWLExportTask",
               "Get-CWLLogGroup",
               "Get-CWLLogStream",
               "Get-CWLMetricFilter",
               "Get-CWLQuery",
               "Get-CWLResourcePolicy",
               "Get-CWLSubscriptionFilter",
               "Unregister-CWLKmsKey",
               "Get-CWLFilteredLogEvent",
               "Get-CWLLogEvent",
               "Get-CWLLogGroupField",
               "Get-CWLLogRecord",
               "Get-CWLQueryResult",
               "Get-CWLLogGroupTag",
               "Write-CWLDestination",
               "Write-CWLDestinationPolicy",
               "Write-CWLLogEvent",
               "Write-CWLMetricFilter",
               "Write-CWLResourcePolicy",
               "Write-CWLRetentionPolicy",
               "Write-CWLSubscriptionFilter",
               "Start-CWLQuery",
               "Stop-CWLQuery",
               "Add-CWLLogGroupTag",
               "Test-CWLMetricFilter",
               "Remove-CWLLogGroupTag")
}

_awsArgumentCompleterRegistration $CWL_SelectCompleters $CWL_SelectMap
# Argument completions for service Amazon Machine Learning


$ML_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.MachineLearning.BatchPredictionFilterVariable
        "Get-MLBatchPredictionList/FilterVariable"
        {
            $v = "CreatedAt","DataSourceId","DataURI","IAMUser","LastUpdatedAt","MLModelId","Name","Status"
            break
        }

        # Amazon.MachineLearning.DataSourceFilterVariable
        "Get-MLDataSourceList/FilterVariable"
        {
            $v = "CreatedAt","DataLocationS3","IAMUser","LastUpdatedAt","Name","Status"
            break
        }

        # Amazon.MachineLearning.EvaluationFilterVariable
        "Get-MLEvaluationList/FilterVariable"
        {
            $v = "CreatedAt","DataSourceId","DataURI","IAMUser","LastUpdatedAt","MLModelId","Name","Status"
            break
        }

        # Amazon.MachineLearning.MLModelFilterVariable
        "Get-MLModelList/FilterVariable"
        {
            $v = "Algorithm","CreatedAt","IAMUser","LastUpdatedAt","MLModelType","Name","RealtimeEndpointStatus","Status","TrainingDataSourceId","TrainingDataURI"
            break
        }

        # Amazon.MachineLearning.MLModelType
        "New-MLModel/MLModelType"
        {
            $v = "BINARY","MULTICLASS","REGRESSION"
            break
        }

        # Amazon.MachineLearning.SortOrder
        {
            ($_ -eq "Get-MLBatchPredictionList/SortOrder") -Or
            ($_ -eq "Get-MLDataSourceList/SortOrder") -Or
            ($_ -eq "Get-MLEvaluationList/SortOrder") -Or
            ($_ -eq "Get-MLModelList/SortOrder")
        }
        {
            $v = "asc","dsc"
            break
        }

        # Amazon.MachineLearning.TaggableResourceType
        {
            ($_ -eq "Add-MLResourceTag/ResourceType") -Or
            ($_ -eq "Get-MLResourceTag/ResourceType") -Or
            ($_ -eq "Remove-MLResourceTag/ResourceType")
        }
        {
            $v = "BatchPrediction","DataSource","Evaluation","MLModel"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ML_map = @{
    "FilterVariable"=@("Get-MLBatchPredictionList","Get-MLDataSourceList","Get-MLEvaluationList","Get-MLModelList")
    "MLModelType"=@("New-MLModel")
    "ResourceType"=@("Add-MLResourceTag","Get-MLResourceTag","Remove-MLResourceTag")
    "SortOrder"=@("Get-MLBatchPredictionList","Get-MLDataSourceList","Get-MLEvaluationList","Get-MLModelList")
}

_awsArgumentCompleterRegistration $ML_Completers $ML_map

$ML_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ML.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ML_SelectMap = @{
    "Select"=@("Add-MLResourceTag",
               "New-MLBatchPrediction",
               "New-MLDataSourceFromRDS",
               "New-MLDataSourceFromRedshift",
               "New-MLDataSourceFromS3",
               "New-MLEvaluation",
               "New-MLModel",
               "New-MLRealtimeEndpoint",
               "Remove-MLBatchPrediction",
               "Remove-MLDataSource",
               "Remove-MLEvaluation",
               "Remove-MLModel",
               "Remove-MLRealtimeEndpoint",
               "Remove-MLResourceTag",
               "Get-MLBatchPredictionList",
               "Get-MLDataSourceList",
               "Get-MLEvaluationList",
               "Get-MLModelList",
               "Get-MLResourceTag",
               "Get-MLBatchPrediction",
               "Get-MLDataSource",
               "Get-MLEvaluation",
               "Get-MLModel",
               "Get-MLPrediction",
               "Update-MLBatchPrediction",
               "Update-MLDataSource",
               "Update-MLEvaluation",
               "Update-MLMLModel")
}

_awsArgumentCompleterRegistration $ML_SelectCompleters $ML_SelectMap
# Argument completions for service Amazon Macie


$MAC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.MAC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MAC_SelectMap = @{
    "Select"=@("Add-MACMemberAccount",
               "Add-MACS3Resource",
               "Remove-MACMemberAccount",
               "Remove-MACS3Resource",
               "Get-MACMemberAccountList",
               "Get-MACS3ResourceList",
               "Update-MACS3Resource")
}

_awsArgumentCompleterRegistration $MAC_SelectCompleters $MAC_SelectMap
# Argument completions for service Amazon Managed Blockchain


$MBC_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ManagedBlockchain.Edition
        "New-MBCNetwork/FrameworkConfiguration_Fabric_Edition"
        {
            $v = "STANDARD","STARTER"
            break
        }

        # Amazon.ManagedBlockchain.Framework
        {
            ($_ -eq "Get-MBCNetworkList/Framework") -Or
            ($_ -eq "New-MBCNetwork/Framework")
        }
        {
            $v = "HYPERLEDGER_FABRIC"
            break
        }

        # Amazon.ManagedBlockchain.MemberStatus
        "Get-MBCMemberList/Status"
        {
            $v = "AVAILABLE","CREATE_FAILED","CREATING","DELETED","DELETING"
            break
        }

        # Amazon.ManagedBlockchain.NetworkStatus
        "Get-MBCNetworkList/Status"
        {
            $v = "AVAILABLE","CREATE_FAILED","CREATING","DELETED","DELETING"
            break
        }

        # Amazon.ManagedBlockchain.NodeStatus
        "Get-MBCNodeList/Status"
        {
            $v = "AVAILABLE","CREATE_FAILED","CREATING","DELETED","DELETING","FAILED"
            break
        }

        # Amazon.ManagedBlockchain.ThresholdComparator
        "New-MBCNetwork/VotingPolicy_ApprovalThresholdPolicy_ThresholdComparator"
        {
            $v = "GREATER_THAN","GREATER_THAN_OR_EQUAL_TO"
            break
        }

        # Amazon.ManagedBlockchain.VoteValue
        "Send-MBCProposalVote/Vote"
        {
            $v = "NO","YES"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MBC_map = @{
    "Framework"=@("Get-MBCNetworkList","New-MBCNetwork")
    "FrameworkConfiguration_Fabric_Edition"=@("New-MBCNetwork")
    "Status"=@("Get-MBCMemberList","Get-MBCNetworkList","Get-MBCNodeList")
    "Vote"=@("Send-MBCProposalVote")
    "VotingPolicy_ApprovalThresholdPolicy_ThresholdComparator"=@("New-MBCNetwork")
}

_awsArgumentCompleterRegistration $MBC_Completers $MBC_map

$MBC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.MBC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MBC_SelectMap = @{
    "Select"=@("New-MBCMember",
               "New-MBCNetwork",
               "New-MBCNode",
               "New-MBCProposal",
               "Remove-MBCMember",
               "Remove-MBCNode",
               "Get-MBCMember",
               "Get-MBCNetwork",
               "Get-MBCNode",
               "Get-MBCProposal",
               "Get-MBCInvitationList",
               "Get-MBCMemberList",
               "Get-MBCNetworkList",
               "Get-MBCNodeList",
               "Get-MBCProposalList",
               "Get-MBCProposalVoteList",
               "Deny-MBCInvitation",
               "Send-MBCProposalVote")
}

_awsArgumentCompleterRegistration $MBC_SelectCompleters $MBC_SelectMap
# Argument completions for service AWS Marketplace Catalog Service


$MCAT_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.MarketplaceCatalog.SortOrder
        {
            ($_ -eq "Get-MCATChangeSetList/Sort_SortOrder") -Or
            ($_ -eq "Get-MCATEntityList/Sort_SortOrder")
        }
        {
            $v = "ASCENDING","DESCENDING"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MCAT_map = @{
    "Sort_SortOrder"=@("Get-MCATChangeSetList","Get-MCATEntityList")
}

_awsArgumentCompleterRegistration $MCAT_Completers $MCAT_map

$MCAT_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.MCAT.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MCAT_SelectMap = @{
    "Select"=@("Stop-MCATChangeSet",
               "Get-MCATChangeSet",
               "Get-MCATEntity",
               "Get-MCATChangeSetList",
               "Get-MCATEntityList",
               "Start-MCATChangeSet")
}

_awsArgumentCompleterRegistration $MCAT_SelectCompleters $MCAT_SelectMap
# Argument completions for service AWS Marketplace Commerce Analytics


$MCA_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.AWSMarketplaceCommerceAnalytics.DataSetType
        "New-MCADataSet/DataSetType"
        {
            $v = "customer_profile_by_geography","customer_profile_by_industry","customer_profile_by_revenue","customer_subscriber_annual_subscriptions","customer_subscriber_hourly_monthly_subscriptions","daily_business_canceled_product_subscribers","daily_business_fees","daily_business_free_trial_conversions","daily_business_new_instances","daily_business_new_product_subscribers","daily_business_usage_by_instance_type","disbursed_amount_by_age_of_disbursed_funds","disbursed_amount_by_age_of_past_due_funds","disbursed_amount_by_age_of_uncollected_funds","disbursed_amount_by_customer_geo","disbursed_amount_by_instance_hours","disbursed_amount_by_product","disbursed_amount_by_product_with_uncollected_funds","disbursed_amount_by_uncollected_funds_breakdown","monthly_revenue_annual_subscriptions","monthly_revenue_billing_and_revenue_data","monthly_revenue_field_demonstration_usage","monthly_revenue_flexible_payment_schedule","sales_compensation_billed_revenue","us_sales_and_use_tax_records"
            break
        }

        # Amazon.AWSMarketplaceCommerceAnalytics.SupportDataSetType
        "Start-MCASupportDataExport/DataSetType"
        {
            $v = "customer_support_contacts_data","test_customer_support_contacts_data"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MCA_map = @{
    "DataSetType"=@("New-MCADataSet","Start-MCASupportDataExport")
}

_awsArgumentCompleterRegistration $MCA_Completers $MCA_map

$MCA_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.MCA.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MCA_SelectMap = @{
    "Select"=@("New-MCADataSet",
               "Start-MCASupportDataExport")
}

_awsArgumentCompleterRegistration $MCA_SelectCompleters $MCA_SelectMap
# Argument completions for service AWS Elemental MediaConnect


$EMCN_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.MediaConnect.Protocol
        {
            ($_ -eq "Update-EMCNFlowOutput/Protocol") -Or
            ($_ -eq "Update-EMCNFlowSource/Protocol")
        }
        {
            $v = "rist","rtp","rtp-fec","zixi-pull","zixi-push"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EMCN_map = @{
    "Protocol"=@("Update-EMCNFlowOutput","Update-EMCNFlowSource")
}

_awsArgumentCompleterRegistration $EMCN_Completers $EMCN_map

$EMCN_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EMCN.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EMCN_SelectMap = @{
    "Select"=@("Add-EMCNFlowOutput",
               "New-EMCNFlow",
               "Remove-EMCNFlow",
               "Get-EMCNFlow",
               "Grant-EMCNFlowEntitlement",
               "Get-EMCNEntitlementList",
               "Get-EMCNFlowList",
               "Get-EMCNResourceTag",
               "Remove-EMCNFlowOutput",
               "Revoke-EMCNFlowEntitlement",
               "Start-EMCNFlow",
               "Stop-EMCNFlow",
               "Add-EMCNResourceTag",
               "Remove-EMCNResourceTag",
               "Update-EMCNFlowEntitlement",
               "Update-EMCNFlowOutput",
               "Update-EMCNFlowSource")
}

_awsArgumentCompleterRegistration $EMCN_SelectCompleters $EMCN_SelectMap
# Argument completions for service AWS Elemental MediaConvert


$EMC_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.MediaConvert.AccelerationMode
        {
            ($_ -eq "New-EMCJob/AccelerationSettings_Mode") -Or
            ($_ -eq "New-EMCJobTemplate/AccelerationSettings_Mode") -Or
            ($_ -eq "Update-EMCJobTemplate/AccelerationSettings_Mode")
        }
        {
            $v = "DISABLED","ENABLED","PREFERRED"
            break
        }

        # Amazon.MediaConvert.BillingTagsSource
        "New-EMCJob/BillingTagsSource"
        {
            $v = "JOB","JOB_TEMPLATE","PRESET","QUEUE"
            break
        }

        # Amazon.MediaConvert.Commitment
        {
            ($_ -eq "New-EMCQueue/ReservationPlanSettings_Commitment") -Or
            ($_ -eq "Update-EMCQueue/ReservationPlanSettings_Commitment")
        }
        {
            $v = "ONE_YEAR"
            break
        }

        # Amazon.MediaConvert.DescribeEndpointsMode
        "Get-EMCEndpoint/Mode"
        {
            $v = "DEFAULT","GET_ONLY"
            break
        }

        # Amazon.MediaConvert.JobStatus
        "Get-EMCJobList/Status"
        {
            $v = "CANCELED","COMPLETE","ERROR","PROGRESSING","SUBMITTED"
            break
        }

        # Amazon.MediaConvert.JobTemplateListBy
        "Get-EMCJobTemplateList/ListBy"
        {
            $v = "CREATION_DATE","NAME","SYSTEM"
            break
        }

        # Amazon.MediaConvert.Order
        {
            ($_ -eq "Get-EMCJobList/Order") -Or
            ($_ -eq "Get-EMCJobTemplateList/Order") -Or
            ($_ -eq "Get-EMCPresetList/Order") -Or
            ($_ -eq "Get-EMCQueueList/Order")
        }
        {
            $v = "ASCENDING","DESCENDING"
            break
        }

        # Amazon.MediaConvert.PresetListBy
        "Get-EMCPresetList/ListBy"
        {
            $v = "CREATION_DATE","NAME","SYSTEM"
            break
        }

        # Amazon.MediaConvert.PricingPlan
        "New-EMCQueue/PricingPlan"
        {
            $v = "ON_DEMAND","RESERVED"
            break
        }

        # Amazon.MediaConvert.QueueListBy
        "Get-EMCQueueList/ListBy"
        {
            $v = "CREATION_DATE","NAME"
            break
        }

        # Amazon.MediaConvert.QueueStatus
        {
            ($_ -eq "New-EMCQueue/Status") -Or
            ($_ -eq "Update-EMCQueue/Status")
        }
        {
            $v = "ACTIVE","PAUSED"
            break
        }

        # Amazon.MediaConvert.RenewalType
        {
            ($_ -eq "New-EMCQueue/ReservationPlanSettings_RenewalType") -Or
            ($_ -eq "Update-EMCQueue/ReservationPlanSettings_RenewalType")
        }
        {
            $v = "AUTO_RENEW","EXPIRE"
            break
        }

        # Amazon.MediaConvert.SimulateReservedQueue
        "New-EMCJob/SimulateReservedQueue"
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.MediaConvert.StatusUpdateInterval
        {
            ($_ -eq "New-EMCJob/StatusUpdateInterval") -Or
            ($_ -eq "New-EMCJobTemplate/StatusUpdateInterval") -Or
            ($_ -eq "Update-EMCJobTemplate/StatusUpdateInterval")
        }
        {
            $v = "SECONDS_10","SECONDS_12","SECONDS_120","SECONDS_15","SECONDS_180","SECONDS_20","SECONDS_240","SECONDS_30","SECONDS_300","SECONDS_360","SECONDS_420","SECONDS_480","SECONDS_540","SECONDS_60","SECONDS_600"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EMC_map = @{
    "AccelerationSettings_Mode"=@("New-EMCJob","New-EMCJobTemplate","Update-EMCJobTemplate")
    "BillingTagsSource"=@("New-EMCJob")
    "ListBy"=@("Get-EMCJobTemplateList","Get-EMCPresetList","Get-EMCQueueList")
    "Mode"=@("Get-EMCEndpoint")
    "Order"=@("Get-EMCJobList","Get-EMCJobTemplateList","Get-EMCPresetList","Get-EMCQueueList")
    "PricingPlan"=@("New-EMCQueue")
    "ReservationPlanSettings_Commitment"=@("New-EMCQueue","Update-EMCQueue")
    "ReservationPlanSettings_RenewalType"=@("New-EMCQueue","Update-EMCQueue")
    "SimulateReservedQueue"=@("New-EMCJob")
    "Status"=@("Get-EMCJobList","New-EMCQueue","Update-EMCQueue")
    "StatusUpdateInterval"=@("New-EMCJob","New-EMCJobTemplate","Update-EMCJobTemplate")
}

_awsArgumentCompleterRegistration $EMC_Completers $EMC_map

$EMC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EMC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EMC_SelectMap = @{
    "Select"=@("Register-EMCCertificate",
               "Stop-EMCJob",
               "New-EMCJob",
               "New-EMCJobTemplate",
               "New-EMCPreset",
               "New-EMCQueue",
               "Remove-EMCJobTemplate",
               "Remove-EMCPreset",
               "Remove-EMCQueue",
               "Get-EMCEndpoint",
               "Unregister-EMCCertificate",
               "Get-EMCJob",
               "Get-EMCJobTemplate",
               "Get-EMCPreset",
               "Get-EMCQueue",
               "Get-EMCJobList",
               "Get-EMCJobTemplateList",
               "Get-EMCPresetList",
               "Get-EMCQueueList",
               "Get-EMCResourceTag",
               "Add-EMCResourceTag",
               "Remove-EMCResourceTag",
               "Update-EMCJobTemplate",
               "Update-EMCPreset",
               "Update-EMCQueue")
}

_awsArgumentCompleterRegistration $EMC_SelectCompleters $EMC_SelectMap
# Argument completions for service AWS Elemental MediaLive


$EML_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.MediaLive.ChannelClass
        {
            ($_ -eq "New-EMLChannel/ChannelClass") -Or
            ($_ -eq "Update-EMLChannelClass/ChannelClass")
        }
        {
            $v = "SINGLE_PIPELINE","STANDARD"
            break
        }

        # Amazon.MediaLive.InputCodec
        {
            ($_ -eq "New-EMLChannel/InputSpecification_Codec") -Or
            ($_ -eq "Update-EMLChannel/InputSpecification_Codec")
        }
        {
            $v = "AVC","HEVC","MPEG2"
            break
        }

        # Amazon.MediaLive.InputMaximumBitrate
        {
            ($_ -eq "New-EMLChannel/InputSpecification_MaximumBitrate") -Or
            ($_ -eq "Update-EMLChannel/InputSpecification_MaximumBitrate")
        }
        {
            $v = "MAX_10_MBPS","MAX_20_MBPS","MAX_50_MBPS"
            break
        }

        # Amazon.MediaLive.InputResolution
        {
            ($_ -eq "New-EMLChannel/InputSpecification_Resolution") -Or
            ($_ -eq "Update-EMLChannel/InputSpecification_Resolution")
        }
        {
            $v = "HD","SD","UHD"
            break
        }

        # Amazon.MediaLive.InputType
        "New-EMLInput/Type"
        {
            $v = "MEDIACONNECT","MP4_FILE","RTMP_PULL","RTMP_PUSH","RTP_PUSH","UDP_PUSH","URL_PULL"
            break
        }

        # Amazon.MediaLive.LogLevel
        {
            ($_ -eq "New-EMLChannel/LogLevel") -Or
            ($_ -eq "Update-EMLChannel/LogLevel")
        }
        {
            $v = "DEBUG","DISABLED","ERROR","INFO","WARNING"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EML_map = @{
    "ChannelClass"=@("New-EMLChannel","Update-EMLChannelClass")
    "InputSpecification_Codec"=@("New-EMLChannel","Update-EMLChannel")
    "InputSpecification_MaximumBitrate"=@("New-EMLChannel","Update-EMLChannel")
    "InputSpecification_Resolution"=@("New-EMLChannel","Update-EMLChannel")
    "LogLevel"=@("New-EMLChannel","Update-EMLChannel")
    "Type"=@("New-EMLInput")
}

_awsArgumentCompleterRegistration $EML_Completers $EML_map

$EML_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EML.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EML_SelectMap = @{
    "Select"=@("Update-EMLScheduleBatch",
               "New-EMLChannel",
               "New-EMLInput",
               "New-EMLInputSecurityGroup",
               "New-EMLMultiplex",
               "New-EMLMultiplexProgram",
               "Add-EMLResourceTag",
               "Remove-EMLChannel",
               "Remove-EMLInput",
               "Remove-EMLInputSecurityGroup",
               "Remove-EMLMultiplex",
               "Remove-EMLMultiplexProgram",
               "Remove-EMLReservation",
               "Remove-EMLSchedule",
               "Remove-EMLResourceTag",
               "Get-EMLChannel",
               "Get-EMLInput",
               "Get-EMLInputSecurityGroup",
               "Get-EMLMultiplex",
               "Get-EMLMultiplexProgram",
               "Get-EMLOffering",
               "Get-EMLReservation",
               "Get-EMLSchedule",
               "Get-EMLChannelList",
               "Get-EMLInputList",
               "Get-EMLInputSecurityGroupList",
               "Get-EMLMultiplexList",
               "Get-EMLMultiplexProgramList",
               "Get-EMLOfferingList",
               "Get-EMLReservationList",
               "Get-EMLResourceTag",
               "New-EMLOfferingPurchase",
               "Start-EMLChannel",
               "Start-EMLMultiplex",
               "Stop-EMLChannel",
               "Stop-EMLMultiplex",
               "Update-EMLChannel",
               "Update-EMLChannelClass",
               "Update-EMLInput",
               "Update-EMLInputSecurityGroup",
               "Update-EMLMultiplex",
               "Update-EMLMultiplexProgram",
               "Update-EMLReservation")
}

_awsArgumentCompleterRegistration $EML_SelectCompleters $EML_SelectMap
# Argument completions for service AWS Elemental MediaPackage


$EMP_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.MediaPackage.Origination
        {
            ($_ -eq "New-EMPOriginEndpoint/Origination") -Or
            ($_ -eq "Update-EMPOriginEndpoint/Origination")
        }
        {
            $v = "ALLOW","DENY"
            break
        }

        # Amazon.MediaPackage.StreamOrder
        {
            ($_ -eq "New-EMPOriginEndpoint/CmafPackage_StreamSelection_StreamOrder") -Or
            ($_ -eq "Update-EMPOriginEndpoint/CmafPackage_StreamSelection_StreamOrder")
        }
        {
            $v = "ORIGINAL","VIDEO_BITRATE_ASCENDING","VIDEO_BITRATE_DESCENDING"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EMP_map = @{
    "CmafPackage_StreamSelection_StreamOrder"=@("New-EMPOriginEndpoint","Update-EMPOriginEndpoint")
    "Origination"=@("New-EMPOriginEndpoint","Update-EMPOriginEndpoint")
}

_awsArgumentCompleterRegistration $EMP_Completers $EMP_map

$EMP_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EMP.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EMP_SelectMap = @{
    "Select"=@("New-EMPChannel",
               "New-EMPHarvestJob",
               "New-EMPOriginEndpoint",
               "Remove-EMPChannel",
               "Remove-EMPOriginEndpoint",
               "Get-EMPChannel",
               "Get-EMPHarvestJob",
               "Get-EMPOriginEndpoint",
               "Get-EMPChannelList",
               "Get-EMPHarvestJobList",
               "Get-EMPOriginEndpointList",
               "Get-EMPResourceTag",
               "Invoke-EMPChannelCredentialRotation",
               "Invoke-EMPIngestEndpointCredentialRotation",
               "Add-EMPResourceTag",
               "Remove-EMPResourceTag",
               "Update-EMPChannel",
               "Update-EMPOriginEndpoint")
}

_awsArgumentCompleterRegistration $EMP_SelectCompleters $EMP_SelectMap
# Argument completions for service AWS Elemental MediaPackage VOD


$EMPV_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EMPV.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EMPV_SelectMap = @{
    "Select"=@("New-EMPVAsset",
               "New-EMPVPackagingConfiguration",
               "New-EMPVPackagingGroup",
               "Remove-EMPVAsset",
               "Remove-EMPVPackagingConfiguration",
               "Remove-EMPVPackagingGroup",
               "Get-EMPVAsset",
               "Get-EMPVPackagingConfiguration",
               "Get-EMPVPackagingGroup",
               "Get-EMPVAssetList",
               "Get-EMPVPackagingConfigurationList",
               "Get-EMPVPackagingGroupList")
}

_awsArgumentCompleterRegistration $EMPV_SelectCompleters $EMPV_SelectMap
# Argument completions for service AWS Elemental MediaStore


$EMS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EMS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EMS_SelectMap = @{
    "Select"=@("New-EMSContainer",
               "Remove-EMSContainer",
               "Remove-EMSContainerPolicy",
               "Remove-EMSCorsPolicy",
               "Remove-EMSLifecyclePolicy",
               "Get-EMSContainer",
               "Get-EMSContainerPolicy",
               "Get-EMSCorsPolicy",
               "Get-EMSLifecyclePolicy",
               "Get-EMSContainerList",
               "Get-EMSResourceTag",
               "Write-EMSContainerPolicy",
               "Write-EMSCorsPolicy",
               "Write-EMSLifecyclePolicy",
               "Start-EMSAccessLogging",
               "Stop-EMSAccessLogging",
               "Add-EMSResourceTag",
               "Remove-EMSResourceTag")
}

_awsArgumentCompleterRegistration $EMS_SelectCompleters $EMS_SelectMap
# Argument completions for service AWS Elemental MediaStore Data Plane


$EMSD_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.MediaStoreData.StorageClass
        "Write-EMSDObject/StorageClass"
        {
            $v = "TEMPORAL"
            break
        }

        # Amazon.MediaStoreData.UploadAvailability
        "Write-EMSDObject/UploadAvailability"
        {
            $v = "STANDARD","STREAMING"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EMSD_map = @{
    "StorageClass"=@("Write-EMSDObject")
    "UploadAvailability"=@("Write-EMSDObject")
}

_awsArgumentCompleterRegistration $EMSD_Completers $EMSD_map

$EMSD_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EMSD.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EMSD_SelectMap = @{
    "Select"=@("Remove-EMSDObject",
               "Get-EMSDObjectMetadata",
               "Get-EMSDObject",
               "Get-EMSDItemList",
               "Write-EMSDObject")
}

_awsArgumentCompleterRegistration $EMSD_SelectCompleters $EMSD_SelectMap
# Argument completions for service AWS Elemental MediaTailor


$EMT_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.EMT.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$EMT_SelectMap = @{
    "Select"=@("Remove-EMTPlaybackConfiguration",
               "Get-EMTPlaybackConfiguration",
               "Get-EMTPlaybackConfigurationList",
               "Get-EMTResourceTag",
               "Set-EMTPlaybackConfiguration",
               "Add-EMTResourceTag",
               "Remove-EMTResourceTag")
}

_awsArgumentCompleterRegistration $EMT_SelectCompleters $EMT_SelectMap
# Argument completions for service AWS Marketplace Metering


$MM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.MM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MM_SelectMap = @{
    "Select"=@("Send-MMMeteringDataBatch",
               "Send-MMMeteringData",
               "Register-MMUsage",
               "Get-MMCustomerMetadata")
}

_awsArgumentCompleterRegistration $MM_SelectCompleters $MM_SelectMap
# Argument completions for service AWS Migration Hub Config


$MHC_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.MigrationHubConfig.TargetType
        {
            ($_ -eq "Get-MHCHomeRegionControl/Target_Type") -Or
            ($_ -eq "New-MHCHomeRegionControl/Target_Type")
        }
        {
            $v = "ACCOUNT"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MHC_map = @{
    "Target_Type"=@("Get-MHCHomeRegionControl","New-MHCHomeRegionControl")
}

_awsArgumentCompleterRegistration $MHC_Completers $MHC_map

$MHC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.MHC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MHC_SelectMap = @{
    "Select"=@("New-MHCHomeRegionControl",
               "Get-MHCHomeRegionControl",
               "Get-MHCHomeRegion")
}

_awsArgumentCompleterRegistration $MHC_SelectCompleters $MHC_SelectMap
# Argument completions for service AWS Mobile


$MOBL_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Mobile.Platform
        "Export-MOBLBundle/Platform"
        {
            $v = "ANDROID","JAVASCRIPT","LINUX","OBJC","OSX","SWIFT","WINDOWS"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MOBL_map = @{
    "Platform"=@("Export-MOBLBundle")
}

_awsArgumentCompleterRegistration $MOBL_Completers $MOBL_map

$MOBL_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.MOBL.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MOBL_SelectMap = @{
    "Select"=@("New-MOBLProject",
               "Remove-MOBLProject",
               "Get-MOBLBundle",
               "Get-MOBLProject",
               "Export-MOBLBundle",
               "Export-MOBLProject",
               "Get-MOBLBundleList",
               "Get-MOBLProjectList",
               "Update-MOBLProject")
}

_awsArgumentCompleterRegistration $MOBL_SelectCompleters $MOBL_SelectMap
# Argument completions for service Amazon CloudWatch


$CW_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.CloudWatch.ComparisonOperator
        "Write-CWMetricAlarm/ComparisonOperator"
        {
            $v = "GreaterThanOrEqualToThreshold","GreaterThanThreshold","GreaterThanUpperThreshold","LessThanLowerOrGreaterThanUpperThreshold","LessThanLowerThreshold","LessThanOrEqualToThreshold","LessThanThreshold"
            break
        }

        # Amazon.CloudWatch.HistoryItemType
        "Get-CWAlarmHistory/HistoryItemType"
        {
            $v = "Action","ConfigurationUpdate","StateUpdate"
            break
        }

        # Amazon.CloudWatch.ScanBy
        "Get-CWMetricData/ScanBy"
        {
            $v = "TimestampAscending","TimestampDescending"
            break
        }

        # Amazon.CloudWatch.StandardUnit
        {
            ($_ -eq "Get-CWAlarmForMetric/Unit") -Or
            ($_ -eq "Get-CWMetricStatistic/Unit") -Or
            ($_ -eq "Write-CWMetricAlarm/Unit")
        }
        {
            $v = "Bits","Bits/Second","Bytes","Bytes/Second","Count","Count/Second","Gigabits","Gigabits/Second","Gigabytes","Gigabytes/Second","Kilobits","Kilobits/Second","Kilobytes","Kilobytes/Second","Megabits","Megabits/Second","Megabytes","Megabytes/Second","Microseconds","Milliseconds","None","Percent","Seconds","Terabits","Terabits/Second","Terabytes","Terabytes/Second"
            break
        }

        # Amazon.CloudWatch.StateValue
        {
            ($_ -eq "Get-CWAlarm/StateValue") -Or
            ($_ -eq "Set-CWAlarmState/StateValue")
        }
        {
            $v = "ALARM","INSUFFICIENT_DATA","OK"
            break
        }

        # Amazon.CloudWatch.Statistic
        {
            ($_ -eq "Get-CWAlarmForMetric/Statistic") -Or
            ($_ -eq "Write-CWMetricAlarm/Statistic")
        }
        {
            $v = "Average","Maximum","Minimum","SampleCount","Sum"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CW_map = @{
    "ComparisonOperator"=@("Write-CWMetricAlarm")
    "HistoryItemType"=@("Get-CWAlarmHistory")
    "ScanBy"=@("Get-CWMetricData")
    "StateValue"=@("Get-CWAlarm","Set-CWAlarmState")
    "Statistic"=@("Get-CWAlarmForMetric","Write-CWMetricAlarm")
    "Unit"=@("Get-CWAlarmForMetric","Get-CWMetricStatistic","Write-CWMetricAlarm")
}

_awsArgumentCompleterRegistration $CW_Completers $CW_map

$CW_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.CW.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$CW_SelectMap = @{
    "Select"=@("Remove-CWAlarm",
               "Remove-CWAnomalyDetector",
               "Remove-CWDashboard",
               "Remove-CWInsightRule",
               "Get-CWAlarmHistory",
               "Get-CWAlarm",
               "Get-CWAlarmForMetric",
               "Get-CWAnomalyDetector",
               "Get-CWInsightRule",
               "Disable-CWAlarmAction",
               "Disable-CWInsightRule",
               "Enable-CWAlarmAction",
               "Enable-CWInsightRule",
               "Get-CWDashboard",
               "Get-CWInsightRuleReport",
               "Get-CWMetricData",
               "Get-CWMetricStatistic",
               "Get-CWMetricWidgetImage",
               "Get-CWDashboardList",
               "Get-CWMetricList",
               "Get-CWResourceTag",
               "Write-CWAnomalyDetector",
               "Write-CWDashboard",
               "Write-CWInsightRule",
               "Write-CWMetricAlarm",
               "Write-CWMetricData",
               "Set-CWAlarmState",
               "Add-CWResourceTag",
               "Remove-CWResourceTag")
}

_awsArgumentCompleterRegistration $CW_SelectCompleters $CW_SelectMap
# Argument completions for service Amazon MQ


$MQ_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.MQ.DeploymentMode
        "New-MQBroker/DeploymentMode"
        {
            $v = "ACTIVE_STANDBY_MULTI_AZ","SINGLE_INSTANCE"
            break
        }

        # Amazon.MQ.EngineType
        {
            ($_ -eq "New-MQBroker/EngineType") -Or
            ($_ -eq "New-MQConfiguration/EngineType")
        }
        {
            $v = "ACTIVEMQ"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MQ_map = @{
    "DeploymentMode"=@("New-MQBroker")
    "EngineType"=@("New-MQBroker","New-MQConfiguration")
}

_awsArgumentCompleterRegistration $MQ_Completers $MQ_map

$MQ_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.MQ.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MQ_SelectMap = @{
    "Select"=@("New-MQBroker",
               "New-MQConfiguration",
               "New-MQTag",
               "New-MQUser",
               "Remove-MQBroker",
               "Remove-MQTag",
               "Remove-MQUser",
               "Get-MQBroker",
               "Get-MQBrokerEngineType",
               "Get-MQBrokerInstanceOption",
               "Get-MQConfiguration",
               "Get-MQConfigurationRevision",
               "Get-MQUser",
               "Get-MQBrokerList",
               "Get-MQConfigurationRevisionList",
               "Get-MQConfigurationList",
               "Get-MQTagList",
               "Get-MQUserList",
               "Restart-MQBroker",
               "Update-MQBroker",
               "Update-MQConfiguration",
               "Update-MQUser")
}

_awsArgumentCompleterRegistration $MQ_SelectCompleters $MQ_SelectMap
# Argument completions for service Amazon MTurk Service


$MTR_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.MTurk.EventType
        "Send-MTRTestEventNotification/TestEventType"
        {
            $v = "AssignmentAbandoned","AssignmentAccepted","AssignmentApproved","AssignmentRejected","AssignmentReturned","AssignmentSubmitted","HITCreated","HITDisposed","HITExpired","HITExtended","HITReviewable","Ping"
            break
        }

        # Amazon.MTurk.NotificationTransport
        {
            ($_ -eq "Send-MTRTestEventNotification/Notification_Transport") -Or
            ($_ -eq "Update-MTRNotificationSetting/Notification_Transport")
        }
        {
            $v = "Email","SNS","SQS"
            break
        }

        # Amazon.MTurk.QualificationStatus
        "Get-MTRWorkersWithQualificationType/Status"
        {
            $v = "Granted","Revoked"
            break
        }

        # Amazon.MTurk.QualificationTypeStatus
        {
            ($_ -eq "New-MTRQualificationType/QualificationTypeStatus") -Or
            ($_ -eq "Update-MTRQualificationType/QualificationTypeStatus")
        }
        {
            $v = "Active","Inactive"
            break
        }

        # Amazon.MTurk.ReviewableHITStatus
        "Get-MTRReviewableHITList/Status"
        {
            $v = "Reviewable","Reviewing"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MTR_map = @{
    "Notification_Transport"=@("Send-MTRTestEventNotification","Update-MTRNotificationSetting")
    "QualificationTypeStatus"=@("New-MTRQualificationType","Update-MTRQualificationType")
    "Status"=@("Get-MTRReviewableHITList","Get-MTRWorkersWithQualificationType")
    "TestEventType"=@("Send-MTRTestEventNotification")
}

_awsArgumentCompleterRegistration $MTR_Completers $MTR_map

$MTR_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.MTR.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$MTR_SelectMap = @{
    "Select"=@("Grant-MTRQualificationRequest",
               "Approve-MTRAssignment",
               "Add-MTRQualificationToWorker",
               "New-MTRAdditionalAssignmentsForHIT",
               "New-MTRHIT",
               "New-MTRHITType",
               "New-MTRHITWithHITType",
               "New-MTRQualificationType",
               "New-MTRWorkerBlock",
               "Remove-MTRHIT",
               "Remove-MTRQualificationType",
               "Remove-MTRWorkerBlock",
               "Remove-MTRQualificationFromWorker",
               "Get-MTRAccountBalance",
               "Get-MTRAssignment",
               "Get-MTRFileUploadURL",
               "Get-MTRHIT",
               "Get-MTRQualificationScore",
               "Get-MTRQualificationType",
               "Get-MTRHITAssignmentList",
               "Get-MTRBonusPaymentList",
               "Get-MTRHITList",
               "Get-MTRHITListForQualificationType",
               "Get-MTRQualificationRequestList",
               "Get-MTRQualificationTypeList",
               "Get-MTRReviewableHITList",
               "Get-MTRReviewPolicyResultList",
               "Get-MTRWorkerBlockList",
               "Get-MTRWorkersWithQualificationType",
               "Send-MTRWorkerNotification",
               "Deny-MTRAssignment",
               "Deny-MTRQualificationRequest",
               "Send-MTRBonus",
               "Send-MTRTestEventNotification",
               "Update-MTRExpirationForHIT",
               "Update-MTRHITReviewStatus",
               "Update-MTRHITTypeOfHIT",
               "Update-MTRNotificationSetting",
               "Update-MTRQualificationType")
}

_awsArgumentCompleterRegistration $MTR_SelectCompleters $MTR_SelectMap
# Argument completions for service Amazon Neptune


$NPT_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Neptune.SourceType
        "Get-NPTEvent/SourceType"
        {
            $v = "db-cluster","db-cluster-snapshot","db-instance","db-parameter-group","db-security-group","db-snapshot"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$NPT_map = @{
    "SourceType"=@("Get-NPTEvent")
}

_awsArgumentCompleterRegistration $NPT_Completers $NPT_map

$NPT_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.NPT.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$NPT_SelectMap = @{
    "Select"=@("Add-NPTRoleToDBCluster",
               "Add-NPTSourceIdentifierToSubscription",
               "Add-NPTResourceTag",
               "Submit-NPTPendingMaintenanceAction",
               "Copy-NPTDBClusterParameterGroup",
               "Copy-NPTDBClusterSnapshot",
               "Copy-NPTDBParameterGroup",
               "New-NPTDBCluster",
               "New-NPTDBClusterParameterGroup",
               "New-NPTDBClusterSnapshot",
               "New-NPTDBInstance",
               "New-NPTDBParameterGroup",
               "New-NPTDBSubnetGroup",
               "New-NPTEventSubscription",
               "Remove-NPTDBCluster",
               "Remove-NPTDBClusterParameterGroup",
               "Remove-NPTDBClusterSnapshot",
               "Remove-NPTDBInstance",
               "Remove-NPTDBParameterGroup",
               "Remove-NPTDBSubnetGroup",
               "Remove-NPTEventSubscription",
               "Get-NPTDBClusterParameterGroup",
               "Get-NPTDBClusterParameter",
               "Get-NPTDBCluster",
               "Get-NPTDBClusterSnapshotAttribute",
               "Get-NPTDBClusterSnapshot",
               "Get-NPTDBEngineVersion",
               "Get-NPTDBInstance",
               "Get-NPTDBParameterGroup",
               "Get-NPTDBParameter",
               "Get-NPTDBSubnetGroup",
               "Get-NPTEngineDefaultClusterParameter",
               "Get-NPTEngineDefaultParameter",
               "Get-NPTEventCategory",
               "Get-NPTEvent",
               "Get-NPTEventSubscription",
               "Get-NPTOrderableDBInstanceOption",
               "Get-NPTPendingMaintenanceAction",
               "Get-NPTValidDBInstanceModification",
               "Start-NPTDBClusterFailover",
               "Get-NPTResourceTagList",
               "Edit-NPTDBCluster",
               "Edit-NPTDBClusterParameterGroup",
               "Edit-NPTDBClusterSnapshotAttribute",
               "Edit-NPTDBInstance",
               "Edit-NPTDBParameterGroup",
               "Edit-NPTDBSubnetGroup",
               "Edit-NPTEventSubscription",
               "Convert-NPTReadReplicaDBCluster",
               "Restart-NPTDBInstance",
               "Remove-NPTRoleFromDBCluster",
               "Remove-NPTSourceIdentifierFromSubscription",
               "Remove-NPTResourceTag",
               "Reset-NPTDBClusterParameterGroup",
               "Reset-NPTDBParameterGroup",
               "Restore-NPTDBClusterFromSnapshot",
               "Restore-NPTDBClusterToPointInTime")
}

_awsArgumentCompleterRegistration $NPT_SelectCompleters $NPT_SelectMap
# Argument completions for service AWS Network Manager


$NMGR_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.NMGR.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$NMGR_SelectMap = @{
    "Select"=@("Register-NMGRCustomerGateway",
               "Register-NMGRLink",
               "New-NMGRDevice",
               "New-NMGRGlobalNetwork",
               "New-NMGRLink",
               "New-NMGRSite",
               "Remove-NMGRDevice",
               "Remove-NMGRGlobalNetwork",
               "Remove-NMGRLink",
               "Remove-NMGRSite",
               "Unregister-NMGRTransitGateway",
               "Get-NMGRGlobalNetwork",
               "Unregister-NMGRCustomerGateway",
               "Unregister-NMGRLink",
               "Get-NMGRCustomerGatewayAssociation",
               "Get-NMGRDevice",
               "Get-NMGRLinkAssociation",
               "Get-NMGRLink",
               "Get-NMGRSite",
               "Get-NMGRTransitGatewayRegistration",
               "Get-NMGRResourceTag",
               "Register-NMGRTransitGateway",
               "Add-NMGRResourceTag",
               "Remove-NMGRResourceTag",
               "Update-NMGRDevice",
               "Update-NMGRGlobalNetwork",
               "Update-NMGRLink",
               "Update-NMGRSite")
}

_awsArgumentCompleterRegistration $NMGR_SelectCompleters $NMGR_SelectMap
# Argument completions for service AWS OpsWorks


$OPS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.OpsWorks.AppType
        {
            ($_ -eq "New-OPSApp/Type") -Or
            ($_ -eq "Update-OPSApp/Type")
        }
        {
            $v = "aws-flow-ruby","java","nodejs","other","php","rails","static"
            break
        }

        # Amazon.OpsWorks.Architecture
        {
            ($_ -eq "New-OPSInstance/Architecture") -Or
            ($_ -eq "Update-OPSInstance/Architecture")
        }
        {
            $v = "i386","x86_64"
            break
        }

        # Amazon.OpsWorks.AutoScalingType
        {
            ($_ -eq "New-OPSInstance/AutoScalingType") -Or
            ($_ -eq "Update-OPSInstance/AutoScalingType")
        }
        {
            $v = "load","timer"
            break
        }

        # Amazon.OpsWorks.DeploymentCommandName
        "New-OPSDeployment/Command_Name"
        {
            $v = "configure","deploy","execute_recipes","install_dependencies","restart","rollback","setup","start","stop","undeploy","update_custom_cookbooks","update_dependencies"
            break
        }

        # Amazon.OpsWorks.LayerType
        "New-OPSLayer/Type"
        {
            $v = "aws-flow-ruby","custom","db-master","ecs-cluster","java-app","lb","memcached","monitoring-master","nodejs-app","php-app","rails-app","web"
            break
        }

        # Amazon.OpsWorks.RootDeviceType
        {
            ($_ -eq "Copy-OPSStack/DefaultRootDeviceType") -Or
            ($_ -eq "New-OPSStack/DefaultRootDeviceType") -Or
            ($_ -eq "Update-OPSStack/DefaultRootDeviceType") -Or
            ($_ -eq "New-OPSInstance/RootDeviceType")
        }
        {
            $v = "ebs","instance-store"
            break
        }

        # Amazon.OpsWorks.SourceType
        {
            ($_ -eq "New-OPSApp/AppSource_Type") -Or
            ($_ -eq "Update-OPSApp/AppSource_Type") -Or
            ($_ -eq "Copy-OPSStack/CustomCookbooksSource_Type") -Or
            ($_ -eq "New-OPSStack/CustomCookbooksSource_Type") -Or
            ($_ -eq "Update-OPSStack/CustomCookbooksSource_Type")
        }
        {
            $v = "archive","git","s3","svn"
            break
        }

        # Amazon.OpsWorks.VirtualizationType
        "New-OPSInstance/VirtualizationType"
        {
            $v = "hvm","paravirtual"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$OPS_map = @{
    "AppSource_Type"=@("New-OPSApp","Update-OPSApp")
    "Architecture"=@("New-OPSInstance","Update-OPSInstance")
    "AutoScalingType"=@("New-OPSInstance","Update-OPSInstance")
    "Command_Name"=@("New-OPSDeployment")
    "CustomCookbooksSource_Type"=@("Copy-OPSStack","New-OPSStack","Update-OPSStack")
    "DefaultRootDeviceType"=@("Copy-OPSStack","New-OPSStack","Update-OPSStack")
    "RootDeviceType"=@("New-OPSInstance")
    "Type"=@("New-OPSApp","New-OPSLayer","Update-OPSApp")
    "VirtualizationType"=@("New-OPSInstance")
}

_awsArgumentCompleterRegistration $OPS_Completers $OPS_map

$OPS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.OPS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$OPS_SelectMap = @{
    "Select"=@("Register-OPSInstanceAssignment",
               "Add-OPSVolume",
               "Add-OPSElasticIp",
               "Add-OPSElasticLoadBalancer",
               "Copy-OPSStack",
               "New-OPSApp",
               "New-OPSDeployment",
               "New-OPSInstance",
               "New-OPSLayer",
               "New-OPSStack",
               "New-OPSUserProfile",
               "Remove-OPSApp",
               "Remove-OPSInstance",
               "Remove-OPSLayer",
               "Remove-OPSStack",
               "Remove-OPSUserProfile",
               "Unregister-OPSEcsCluster",
               "Unregister-OPSElasticIp",
               "Unregister-OPSInstance",
               "Unregister-OPSRdsDbInstance",
               "Unregister-OPSVolume",
               "Get-OPSAgentVersion",
               "Get-OPSApp",
               "Get-OPSCommand",
               "Get-OPSDeployment",
               "Get-OPSEcsCluster",
               "Get-OPSElasticIp",
               "Get-OPSElasticLoadBalancer",
               "Get-OPSInstance",
               "Get-OPSLayer",
               "Get-OPSLoadBasedAutoScaling",
               "Get-OPSMyUserProfile",
               "Get-OPSOperatingSystem",
               "Get-OPSPermission",
               "Get-OPSRaidArray",
               "Get-OPSRdsDbInstance",
               "Get-OPSServiceError",
               "Get-OPSStackProvisioningParameter",
               "Get-OPSStack",
               "Get-OPSStackSummary",
               "Get-OPSTimeBasedAutoScaling",
               "Get-OPSUserProfile",
               "Get-OPSVolume",
               "Dismount-OPSElasticLoadBalancer",
               "Remove-OPSElasticIp",
               "Get-OPSHostnameSuggestion",
               "Grant-OPSAccess",
               "Get-OPSResourceTag",
               "Restart-OPSInstance",
               "Register-OPSEcsCluster",
               "Register-OPSElasticIp",
               "Register-OPSInstance",
               "Register-OPSRdsDbInstance",
               "Register-OPSVolume",
               "Set-OPSLoadBasedAutoScaling",
               "Set-OPSPermission",
               "Set-OPSTimeBasedAutoScaling",
               "Start-OPSInstance",
               "Start-OPSStack",
               "Stop-OPSInstance",
               "Stop-OPSStack",
               "Add-OPSResourceTag",
               "Unregister-OPSInstanceAssignment",
               "Remove-OPSVolume",
               "Remove-OPSResourceTag",
               "Update-OPSApp",
               "Update-OPSElasticIp",
               "Update-OPSInstance",
               "Update-OPSLayer",
               "Update-OPSMyUserProfile",
               "Update-OPSRdsDbInstance",
               "Update-OPSStack",
               "Update-OPSUserProfile",
               "Update-OPSVolume")
}

_awsArgumentCompleterRegistration $OPS_SelectCompleters $OPS_SelectMap
# Argument completions for service AWS OpsWorksCM


$OWCM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.OWCM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$OWCM_SelectMap = @{
    "Select"=@("Add-OWCMNode",
               "New-OWCMBackup",
               "New-OWCMServer",
               "Remove-OWCMBackup",
               "Remove-OWCMServer",
               "Get-OWCMAccountAttribute",
               "Get-OWCMBackupList",
               "Get-OWCMEventList",
               "Get-OWCMNodeAssociationStatus",
               "Get-OWCMServerList",
               "Remove-OWCMNode",
               "Export-OWCMServerEngineAttribute",
               "Restore-OWCMServer",
               "Start-OWCMMaintenance",
               "Update-OWCMServer",
               "Update-OWCMServerEngineAttribute")
}

_awsArgumentCompleterRegistration $OWCM_SelectCompleters $OWCM_SelectMap
# Argument completions for service AWS Organizations


$ORG_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Organizations.ActionType
        {
            ($_ -eq "Get-ORGAccountHandshakeList/Filter_ActionType") -Or
            ($_ -eq "Get-ORGOrganizationHandshakeList/Filter_ActionType")
        }
        {
            $v = "ADD_ORGANIZATIONS_SERVICE_LINKED_ROLE","APPROVE_ALL_FEATURES","ENABLE_ALL_FEATURES","INVITE"
            break
        }

        # Amazon.Organizations.ChildType
        "Get-ORGChild/ChildType"
        {
            $v = "ACCOUNT","ORGANIZATIONAL_UNIT"
            break
        }

        # Amazon.Organizations.EffectivePolicyType
        "Get-ORGEffectivePolicy/PolicyType"
        {
            $v = "TAG_POLICY"
            break
        }

        # Amazon.Organizations.HandshakePartyType
        "New-ORGAccountInvitation/Target_Type"
        {
            $v = "ACCOUNT","EMAIL","ORGANIZATION"
            break
        }

        # Amazon.Organizations.IAMUserAccessToBilling
        {
            ($_ -eq "New-ORGAccount/IamUserAccessToBilling") -Or
            ($_ -eq "New-ORGGovCloudAccount/IamUserAccessToBilling")
        }
        {
            $v = "ALLOW","DENY"
            break
        }

        # Amazon.Organizations.OrganizationFeatureSet
        "New-ORGOrganization/FeatureSet"
        {
            $v = "ALL","CONSOLIDATED_BILLING"
            break
        }

        # Amazon.Organizations.PolicyType
        {
            ($_ -eq "Get-ORGPolicyForTarget/Filter") -Or
            ($_ -eq "Get-ORGPolicyList/Filter") -Or
            ($_ -eq "Disable-ORGPolicyType/PolicyType") -Or
            ($_ -eq "Enable-ORGPolicyType/PolicyType") -Or
            ($_ -eq "New-ORGPolicy/Type")
        }
        {
            $v = "SERVICE_CONTROL_POLICY","TAG_POLICY"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ORG_map = @{
    "ChildType"=@("Get-ORGChild")
    "FeatureSet"=@("New-ORGOrganization")
    "Filter"=@("Get-ORGPolicyForTarget","Get-ORGPolicyList")
    "Filter_ActionType"=@("Get-ORGAccountHandshakeList","Get-ORGOrganizationHandshakeList")
    "IamUserAccessToBilling"=@("New-ORGAccount","New-ORGGovCloudAccount")
    "PolicyType"=@("Disable-ORGPolicyType","Enable-ORGPolicyType","Get-ORGEffectivePolicy")
    "Target_Type"=@("New-ORGAccountInvitation")
    "Type"=@("New-ORGPolicy")
}

_awsArgumentCompleterRegistration $ORG_Completers $ORG_map

$ORG_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ORG.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ORG_SelectMap = @{
    "Select"=@("Confirm-ORGHandshake",
               "Add-ORGPolicy",
               "Stop-ORGHandshake",
               "New-ORGAccount",
               "New-ORGGovCloudAccount",
               "New-ORGOrganization",
               "New-ORGOrganizationalUnit",
               "New-ORGPolicy",
               "Deny-ORGHandshake",
               "Remove-ORGOrganization",
               "Remove-ORGOrganizationalUnit",
               "Remove-ORGPolicy",
               "Get-ORGAccount",
               "Get-ORGAccountCreationStatus",
               "Get-ORGEffectivePolicy",
               "Get-ORGHandshake",
               "Get-ORGOrganization",
               "Get-ORGOrganizationalUnit",
               "Get-ORGPolicy",
               "Dismount-ORGPolicy",
               "Disable-ORGAWSServiceAccess",
               "Disable-ORGPolicyType",
               "Enable-ORGAllFeature",
               "Enable-ORGAWSServiceAccess",
               "Enable-ORGPolicyType",
               "New-ORGAccountInvitation",
               "Remove-ORGOrganizationAssociation",
               "Get-ORGAccountList",
               "Get-ORGAccountForParent",
               "Get-ORGAWSServiceAccessForOrganization",
               "Get-ORGChild",
               "Get-ORGAccountCreationStatusList",
               "Get-ORGAccountHandshakeList",
               "Get-ORGOrganizationHandshakeList",
               "Get-ORGOrganizationalUnitList",
               "Get-ORGParent",
               "Get-ORGPolicyList",
               "Get-ORGPolicyForTarget",
               "Get-ORGRoot",
               "Get-ORGResourceTag",
               "Get-ORGTargetForPolicy",
               "Move-ORGAccount",
               "Remove-ORGAccountFromOrganization",
               "Add-ORGResourceTag",
               "Remove-ORGResourceTag",
               "Update-ORGOrganizationalUnit",
               "Update-ORGPolicy")
}

_awsArgumentCompleterRegistration $ORG_SelectCompleters $ORG_SelectMap
# Argument completions for service AWS Outposts


$OUTP_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.OUTP.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$OUTP_SelectMap = @{
    "Select"=@("New-OUTPOutpost",
               "Get-OUTPOutpost",
               "Get-OUTPOutpostInstanceType",
               "Get-OUTPOutpostList",
               "Get-OUTPSiteList")
}

_awsArgumentCompleterRegistration $OUTP_SelectCompleters $OUTP_SelectMap
# Argument completions for service AWS Personalize


$PERS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Personalize.RecipeProvider
        "Get-PERSRecipeList/RecipeProvider"
        {
            $v = "SERVICE"
            break
        }

        # Amazon.Personalize.TrainingMode
        "New-PERSSolutionVersion/TrainingMode"
        {
            $v = "FULL","UPDATE"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$PERS_map = @{
    "RecipeProvider"=@("Get-PERSRecipeList")
    "TrainingMode"=@("New-PERSSolutionVersion")
}

_awsArgumentCompleterRegistration $PERS_Completers $PERS_map

$PERS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.PERS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$PERS_SelectMap = @{
    "Select"=@("New-PERSBatchInferenceJob",
               "New-PERSCampaign",
               "New-PERSDataset",
               "New-PERSDatasetGroup",
               "New-PERSDatasetImportJob",
               "New-PERSEventTracker",
               "New-PERSSchema",
               "New-PERSSolution",
               "New-PERSSolutionVersion",
               "Remove-PERSCampaign",
               "Remove-PERSDataset",
               "Remove-PERSDatasetGroup",
               "Remove-PERSEventTracker",
               "Remove-PERSSchema",
               "Remove-PERSSolution",
               "Get-PERSAlgorithm",
               "Get-PERSBatchInferenceJob",
               "Get-PERSCampaign",
               "Get-PERSDataset",
               "Get-PERSDatasetGroup",
               "Get-PERSDatasetImportJob",
               "Get-PERSEventTracker",
               "Get-PERSFeatureTransformation",
               "Get-PERSRecipe",
               "Get-PERSSchema",
               "Get-PERSSolution",
               "Get-PERSSolutionVersion",
               "Get-PERSSolutionMetric",
               "Get-PERSBatchInferenceJobList",
               "Get-PERSCampaignList",
               "Get-PERSDatasetGroupList",
               "Get-PERSDatasetImportJobList",
               "Get-PERSDatasetList",
               "Get-PERSEventTrackerList",
               "Get-PERSRecipeList",
               "Get-PERSSchemaList",
               "Get-PERSSolutionList",
               "Get-PERSSolutionVersionList",
               "Update-PERSCampaign")
}

_awsArgumentCompleterRegistration $PERS_SelectCompleters $PERS_SelectMap
# Argument completions for service Amazon Personalize Events


$PERSE_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.PERSE.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$PERSE_SelectMap = @{
    "Select"=@("Write-PERSEEvent")
}

_awsArgumentCompleterRegistration $PERSE_SelectCompleters $PERSE_SelectMap
# Argument completions for service Amazon Personalize Runtime


$PERSR_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.PERSR.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$PERSR_SelectMap = @{
    "Select"=@("Get-PERSRPersonalizedRanking",
               "Get-PERSRRecommendation")
}

_awsArgumentCompleterRegistration $PERSR_SelectCompleters $PERSR_SelectMap
# Argument completions for service AWS Performance Insights


$PI_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.PI.ServiceType
        {
            ($_ -eq "Get-PIDimensionKey/ServiceType") -Or
            ($_ -eq "Get-PIResourceMetric/ServiceType")
        }
        {
            $v = "RDS"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$PI_map = @{
    "ServiceType"=@("Get-PIDimensionKey","Get-PIResourceMetric")
}

_awsArgumentCompleterRegistration $PI_Completers $PI_map

$PI_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.PI.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$PI_SelectMap = @{
    "Select"=@("Get-PIDimensionKey",
               "Get-PIResourceMetric")
}

_awsArgumentCompleterRegistration $PI_SelectCompleters $PI_SelectMap
# Argument completions for service Amazon Pinpoint


$PIN_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Pinpoint.Action
        {
            ($_ -eq "Send-PINMessage/MessageRequest_MessageConfiguration_ADMMessage_Action") -Or
            ($_ -eq "Send-PINMessage/MessageRequest_MessageConfiguration_APNSMessage_Action") -Or
            ($_ -eq "Send-PINMessage/MessageRequest_MessageConfiguration_BaiduMessage_Action") -Or
            ($_ -eq "Send-PINMessage/MessageRequest_MessageConfiguration_DefaultPushNotificationMessage_Action") -Or
            ($_ -eq "Send-PINMessage/MessageRequest_MessageConfiguration_GCMMessage_Action") -Or
            ($_ -eq "New-PINPushTemplate/PushNotificationTemplateRequest_ADM_Action") -Or
            ($_ -eq "Update-PINPushTemplate/PushNotificationTemplateRequest_ADM_Action") -Or
            ($_ -eq "New-PINPushTemplate/PushNotificationTemplateRequest_APNS_Action") -Or
            ($_ -eq "Update-PINPushTemplate/PushNotificationTemplateRequest_APNS_Action") -Or
            ($_ -eq "New-PINPushTemplate/PushNotificationTemplateRequest_Baidu_Action") -Or
            ($_ -eq "Update-PINPushTemplate/PushNotificationTemplateRequest_Baidu_Action") -Or
            ($_ -eq "New-PINPushTemplate/PushNotificationTemplateRequest_Default_Action") -Or
            ($_ -eq "Update-PINPushTemplate/PushNotificationTemplateRequest_Default_Action") -Or
            ($_ -eq "New-PINPushTemplate/PushNotificationTemplateRequest_GCM_Action") -Or
            ($_ -eq "Update-PINPushTemplate/PushNotificationTemplateRequest_GCM_Action") -Or
            ($_ -eq "Send-PINUserMessageBatch/SendUsersMessageRequest_MessageConfiguration_ADMMessage_Action") -Or
            ($_ -eq "Send-PINUserMessageBatch/SendUsersMessageRequest_MessageConfiguration_APNSMessage_Action") -Or
            ($_ -eq "Send-PINUserMessageBatch/SendUsersMessageRequest_MessageConfiguration_BaiduMessage_Action") -Or
            ($_ -eq "Send-PINUserMessageBatch/SendUsersMessageRequest_MessageConfiguration_DefaultPushNotificationMessage_Action") -Or
            ($_ -eq "Send-PINUserMessageBatch/SendUsersMessageRequest_MessageConfiguration_GCMMessage_Action") -Or
            ($_ -eq "New-PINCampaign/WriteCampaignRequest_MessageConfiguration_ADMMessage_Action") -Or
            ($_ -eq "Update-PINCampaign/WriteCampaignRequest_MessageConfiguration_ADMMessage_Action") -Or
            ($_ -eq "New-PINCampaign/WriteCampaignRequest_MessageConfiguration_APNSMessage_Action") -Or
            ($_ -eq "Update-PINCampaign/WriteCampaignRequest_MessageConfiguration_APNSMessage_Action") -Or
            ($_ -eq "New-PINCampaign/WriteCampaignRequest_MessageConfiguration_BaiduMessage_Action") -Or
            ($_ -eq "Update-PINCampaign/WriteCampaignRequest_MessageConfiguration_BaiduMessage_Action") -Or
            ($_ -eq "New-PINCampaign/WriteCampaignRequest_MessageConfiguration_DefaultMessage_Action") -Or
            ($_ -eq "Update-PINCampaign/WriteCampaignRequest_MessageConfiguration_DefaultMessage_Action") -Or
            ($_ -eq "New-PINCampaign/WriteCampaignRequest_MessageConfiguration_GCMMessage_Action") -Or
            ($_ -eq "Update-PINCampaign/WriteCampaignRequest_MessageConfiguration_GCMMessage_Action")
        }
        {
            $v = "DEEP_LINK","OPEN_APP","URL"
            break
        }

        # Amazon.Pinpoint.ChannelType
        "Update-PINEndpoint/EndpointRequest_ChannelType"
        {
            $v = "ADM","APNS","APNS_SANDBOX","APNS_VOIP","APNS_VOIP_SANDBOX","BAIDU","CUSTOM","EMAIL","GCM","SMS","VOICE"
            break
        }

        # Amazon.Pinpoint.DimensionType
        {
            ($_ -eq "New-PINCampaign/WriteCampaignRequest_Schedule_EventFilter_Dimensions_EventType_DimensionType") -Or
            ($_ -eq "Update-PINCampaign/WriteCampaignRequest_Schedule_EventFilter_Dimensions_EventType_DimensionType") -Or
            ($_ -eq "New-PINSegment/WriteSegmentRequest_Dimensions_Demographic_AppVersion_DimensionType") -Or
            ($_ -eq "Update-PINSegment/WriteSegmentRequest_Dimensions_Demographic_AppVersion_DimensionType") -Or
            ($_ -eq "New-PINSegment/WriteSegmentRequest_Dimensions_Demographic_Channel_DimensionType") -Or
            ($_ -eq "Update-PINSegment/WriteSegmentRequest_Dimensions_Demographic_Channel_DimensionType") -Or
            ($_ -eq "New-PINSegment/WriteSegmentRequest_Dimensions_Demographic_DeviceType_DimensionType") -Or
            ($_ -eq "Update-PINSegment/WriteSegmentRequest_Dimensions_Demographic_DeviceType_DimensionType") -Or
            ($_ -eq "New-PINSegment/WriteSegmentRequest_Dimensions_Demographic_Make_DimensionType") -Or
            ($_ -eq "Update-PINSegment/WriteSegmentRequest_Dimensions_Demographic_Make_DimensionType") -Or
            ($_ -eq "New-PINSegment/WriteSegmentRequest_Dimensions_Demographic_Model_DimensionType") -Or
            ($_ -eq "Update-PINSegment/WriteSegmentRequest_Dimensions_Demographic_Model_DimensionType") -Or
            ($_ -eq "New-PINSegment/WriteSegmentRequest_Dimensions_Demographic_Platform_DimensionType") -Or
            ($_ -eq "Update-PINSegment/WriteSegmentRequest_Dimensions_Demographic_Platform_DimensionType") -Or
            ($_ -eq "New-PINSegment/WriteSegmentRequest_Dimensions_Location_Country_DimensionType") -Or
            ($_ -eq "Update-PINSegment/WriteSegmentRequest_Dimensions_Location_Country_DimensionType")
        }
        {
            $v = "EXCLUSIVE","INCLUSIVE"
            break
        }

        # Amazon.Pinpoint.Duration
        {
            ($_ -eq "New-PINSegment/WriteSegmentRequest_Dimensions_Behavior_Recency_Duration") -Or
            ($_ -eq "Update-PINSegment/WriteSegmentRequest_Dimensions_Behavior_Recency_Duration")
        }
        {
            $v = "DAY_14","DAY_30","DAY_7","HR_24"
            break
        }

        # Amazon.Pinpoint.FilterType
        {
            ($_ -eq "New-PINCampaign/WriteCampaignRequest_Schedule_EventFilter_FilterType") -Or
            ($_ -eq "Update-PINCampaign/WriteCampaignRequest_Schedule_EventFilter_FilterType")
        }
        {
            $v = "ENDPOINT","SYSTEM"
            break
        }

        # Amazon.Pinpoint.Format
        "New-PINImportJob/ImportJobRequest_Format"
        {
            $v = "CSV","JSON"
            break
        }

        # Amazon.Pinpoint.Frequency
        {
            ($_ -eq "New-PINCampaign/WriteCampaignRequest_Schedule_Frequency") -Or
            ($_ -eq "Update-PINCampaign/WriteCampaignRequest_Schedule_Frequency")
        }
        {
            $v = "DAILY","EVENT","HOURLY","MONTHLY","ONCE","WEEKLY"
            break
        }

        # Amazon.Pinpoint.Include
        {
            ($_ -eq "New-PINSegment/WriteSegmentRequest_SegmentGroups_Include") -Or
            ($_ -eq "Update-PINSegment/WriteSegmentRequest_SegmentGroups_Include")
        }
        {
            $v = "ALL","ANY","NONE"
            break
        }

        # Amazon.Pinpoint.MessageType
        {
            ($_ -eq "Send-PINMessage/MessageRequest_MessageConfiguration_SMSMessage_MessageType") -Or
            ($_ -eq "Send-PINUserMessageBatch/SendUsersMessageRequest_MessageConfiguration_SMSMessage_MessageType") -Or
            ($_ -eq "New-PINCampaign/WriteCampaignRequest_MessageConfiguration_SMSMessage_MessageType") -Or
            ($_ -eq "Update-PINCampaign/WriteCampaignRequest_MessageConfiguration_SMSMessage_MessageType")
        }
        {
            $v = "PROMOTIONAL","TRANSACTIONAL"
            break
        }

        # Amazon.Pinpoint.Mode
        {
            ($_ -eq "Update-PINApplicationSettingList/WriteApplicationSettingsRequest_CampaignHook_Mode") -Or
            ($_ -eq "New-PINCampaign/WriteCampaignRequest_Hook_Mode") -Or
            ($_ -eq "Update-PINCampaign/WriteCampaignRequest_Hook_Mode")
        }
        {
            $v = "DELIVERY","FILTER"
            break
        }

        # Amazon.Pinpoint.RecencyType
        {
            ($_ -eq "New-PINSegment/WriteSegmentRequest_Dimensions_Behavior_Recency_RecencyType") -Or
            ($_ -eq "Update-PINSegment/WriteSegmentRequest_Dimensions_Behavior_Recency_RecencyType")
        }
        {
            $v = "ACTIVE","INACTIVE"
            break
        }

        # Amazon.Pinpoint.State
        {
            ($_ -eq "Update-PINJourneyState/JourneyStateRequest_State") -Or
            ($_ -eq "New-PINJourney/WriteJourneyRequest_State") -Or
            ($_ -eq "Update-PINJourney/WriteJourneyRequest_State")
        }
        {
            $v = "ACTIVE","CANCELLED","CLOSED","COMPLETED","DRAFT"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$PIN_map = @{
    "EndpointRequest_ChannelType"=@("Update-PINEndpoint")
    "ImportJobRequest_Format"=@("New-PINImportJob")
    "JourneyStateRequest_State"=@("Update-PINJourneyState")
    "MessageRequest_MessageConfiguration_ADMMessage_Action"=@("Send-PINMessage")
    "MessageRequest_MessageConfiguration_APNSMessage_Action"=@("Send-PINMessage")
    "MessageRequest_MessageConfiguration_BaiduMessage_Action"=@("Send-PINMessage")
    "MessageRequest_MessageConfiguration_DefaultPushNotificationMessage_Action"=@("Send-PINMessage")
    "MessageRequest_MessageConfiguration_GCMMessage_Action"=@("Send-PINMessage")
    "MessageRequest_MessageConfiguration_SMSMessage_MessageType"=@("Send-PINMessage")
    "PushNotificationTemplateRequest_ADM_Action"=@("New-PINPushTemplate","Update-PINPushTemplate")
    "PushNotificationTemplateRequest_APNS_Action"=@("New-PINPushTemplate","Update-PINPushTemplate")
    "PushNotificationTemplateRequest_Baidu_Action"=@("New-PINPushTemplate","Update-PINPushTemplate")
    "PushNotificationTemplateRequest_Default_Action"=@("New-PINPushTemplate","Update-PINPushTemplate")
    "PushNotificationTemplateRequest_GCM_Action"=@("New-PINPushTemplate","Update-PINPushTemplate")
    "SendUsersMessageRequest_MessageConfiguration_ADMMessage_Action"=@("Send-PINUserMessageBatch")
    "SendUsersMessageRequest_MessageConfiguration_APNSMessage_Action"=@("Send-PINUserMessageBatch")
    "SendUsersMessageRequest_MessageConfiguration_BaiduMessage_Action"=@("Send-PINUserMessageBatch")
    "SendUsersMessageRequest_MessageConfiguration_DefaultPushNotificationMessage_Action"=@("Send-PINUserMessageBatch")
    "SendUsersMessageRequest_MessageConfiguration_GCMMessage_Action"=@("Send-PINUserMessageBatch")
    "SendUsersMessageRequest_MessageConfiguration_SMSMessage_MessageType"=@("Send-PINUserMessageBatch")
    "WriteApplicationSettingsRequest_CampaignHook_Mode"=@("Update-PINApplicationSettingList")
    "WriteCampaignRequest_Hook_Mode"=@("New-PINCampaign","Update-PINCampaign")
    "WriteCampaignRequest_MessageConfiguration_ADMMessage_Action"=@("New-PINCampaign","Update-PINCampaign")
    "WriteCampaignRequest_MessageConfiguration_APNSMessage_Action"=@("New-PINCampaign","Update-PINCampaign")
    "WriteCampaignRequest_MessageConfiguration_BaiduMessage_Action"=@("New-PINCampaign","Update-PINCampaign")
    "WriteCampaignRequest_MessageConfiguration_DefaultMessage_Action"=@("New-PINCampaign","Update-PINCampaign")
    "WriteCampaignRequest_MessageConfiguration_GCMMessage_Action"=@("New-PINCampaign","Update-PINCampaign")
    "WriteCampaignRequest_MessageConfiguration_SMSMessage_MessageType"=@("New-PINCampaign","Update-PINCampaign")
    "WriteCampaignRequest_Schedule_EventFilter_Dimensions_EventType_DimensionType"=@("New-PINCampaign","Update-PINCampaign")
    "WriteCampaignRequest_Schedule_EventFilter_FilterType"=@("New-PINCampaign","Update-PINCampaign")
    "WriteCampaignRequest_Schedule_Frequency"=@("New-PINCampaign","Update-PINCampaign")
    "WriteJourneyRequest_State"=@("New-PINJourney","Update-PINJourney")
    "WriteSegmentRequest_Dimensions_Behavior_Recency_Duration"=@("New-PINSegment","Update-PINSegment")
    "WriteSegmentRequest_Dimensions_Behavior_Recency_RecencyType"=@("New-PINSegment","Update-PINSegment")
    "WriteSegmentRequest_Dimensions_Demographic_AppVersion_DimensionType"=@("New-PINSegment","Update-PINSegment")
    "WriteSegmentRequest_Dimensions_Demographic_Channel_DimensionType"=@("New-PINSegment","Update-PINSegment")
    "WriteSegmentRequest_Dimensions_Demographic_DeviceType_DimensionType"=@("New-PINSegment","Update-PINSegment")
    "WriteSegmentRequest_Dimensions_Demographic_Make_DimensionType"=@("New-PINSegment","Update-PINSegment")
    "WriteSegmentRequest_Dimensions_Demographic_Model_DimensionType"=@("New-PINSegment","Update-PINSegment")
    "WriteSegmentRequest_Dimensions_Demographic_Platform_DimensionType"=@("New-PINSegment","Update-PINSegment")
    "WriteSegmentRequest_Dimensions_Location_Country_DimensionType"=@("New-PINSegment","Update-PINSegment")
    "WriteSegmentRequest_SegmentGroups_Include"=@("New-PINSegment","Update-PINSegment")
}

_awsArgumentCompleterRegistration $PIN_Completers $PIN_map

$PIN_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.PIN.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$PIN_SelectMap = @{
    "Select"=@("New-PINApp",
               "New-PINCampaign",
               "New-PINEmailTemplate",
               "New-PINExportJob",
               "New-PINImportJob",
               "New-PINJourney",
               "New-PINPushTemplate",
               "New-PINSegment",
               "New-PINSmsTemplate",
               "New-PINVoiceTemplate",
               "Remove-PINAdmChannel",
               "Remove-PINApnsChannel",
               "Remove-PINApnsSandboxChannel",
               "Remove-PINApnsVoipChannel",
               "Remove-PINApnsVoipSandboxChannel",
               "Remove-PINApp",
               "Remove-PINBaiduChannel",
               "Remove-PINCampaign",
               "Remove-PINEmailChannel",
               "Remove-PINEmailTemplate",
               "Remove-PINEndpoint",
               "Remove-PINEventStream",
               "Remove-PINGcmChannel",
               "Remove-PINJourney",
               "Remove-PINPushTemplate",
               "Remove-PINSegment",
               "Remove-PINSmsChannel",
               "Remove-PINSmsTemplate",
               "Remove-PINUserEndpoint",
               "Remove-PINVoiceChannel",
               "Remove-PINVoiceTemplate",
               "Get-PINAdmChannel",
               "Get-PINApnsChannel",
               "Get-PINApnsSandboxChannel",
               "Get-PINApnsVoipChannel",
               "Get-PINApnsVoipSandboxChannel",
               "Get-PINApp",
               "Get-PINApplicationDateRangeKpi",
               "Get-PINApplicationSettingList",
               "Get-PINAppList",
               "Get-PINBaiduChannel",
               "Get-PINCampaign",
               "Get-PINCampaignActivityList",
               "Get-PINCampaignDateRangeKpi",
               "Get-PINCampaignList",
               "Get-PINCampaignVersion",
               "Get-PINCampaignVersionList",
               "Get-PINChannel",
               "Get-PINEmailChannel",
               "Get-PINEmailTemplate",
               "Get-PINEndpoint",
               "Get-PINEventStream",
               "Get-PINExportJob",
               "Get-PINExportJobList",
               "Get-PINGcmChannel",
               "Get-PINImportJob",
               "Get-PINImportJobList",
               "Get-PINJourney",
               "Get-PINJourneyDateRangeKpi",
               "Get-PINJourneyExecutionActivityMetric",
               "Get-PINJourneyExecutionMetric",
               "Get-PINPushTemplate",
               "Get-PINSegment",
               "Get-PINSegmentExportJobList",
               "Get-PINSegmentImportJobList",
               "Get-PINSegmentList",
               "Get-PINSegmentVersion",
               "Get-PINSegmentVersionList",
               "Get-PINSmsChannel",
               "Get-PINSmsTemplate",
               "Get-PINUserEndpoint",
               "Get-PINVoiceChannel",
               "Get-PINVoiceTemplate",
               "Get-PINJourneyList",
               "Get-PINResourceTag",
               "Get-PINTemplateList",
               "Confirm-PINPhoneNumber",
               "Write-PINEvent",
               "Write-PINEventStream",
               "Remove-PINAttribute",
               "Send-PINMessage",
               "Send-PINUserMessageBatch",
               "Add-PINResourceTag",
               "Remove-PINResourceTag",
               "Update-PINAdmChannel",
               "Update-PINApnsChannel",
               "Update-PINApnsSandboxChannel",
               "Update-PINApnsVoipChannel",
               "Update-PINApnsVoipSandboxChannel",
               "Update-PINApplicationSettingList",
               "Update-PINBaiduChannel",
               "Update-PINCampaign",
               "Update-PINEmailChannel",
               "Update-PINEmailTemplate",
               "Update-PINEndpoint",
               "Update-PINEndpointsBatch",
               "Update-PINGcmChannel",
               "Update-PINJourney",
               "Update-PINJourneyState",
               "Update-PINPushTemplate",
               "Update-PINSegment",
               "Update-PINSmsChannel",
               "Update-PINSmsTemplate",
               "Update-PINVoiceChannel",
               "Update-PINVoiceTemplate")
}

_awsArgumentCompleterRegistration $PIN_SelectCompleters $PIN_SelectMap
# Argument completions for service Amazon Pinpoint Email


$PINE_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.PinpointEmail.BehaviorOnMxFailure
        "Write-PINEEmailIdentityMailFromAttribute/BehaviorOnMxFailure"
        {
            $v = "REJECT_MESSAGE","USE_DEFAULT_VALUE"
            break
        }

        # Amazon.PinpointEmail.TlsPolicy
        {
            ($_ -eq "New-PINEConfigurationSet/DeliveryOptions_TlsPolicy") -Or
            ($_ -eq "Write-PINEConfigurationSetDeliveryOption/TlsPolicy")
        }
        {
            $v = "OPTIONAL","REQUIRE"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$PINE_map = @{
    "BehaviorOnMxFailure"=@("Write-PINEEmailIdentityMailFromAttribute")
    "DeliveryOptions_TlsPolicy"=@("New-PINEConfigurationSet")
    "TlsPolicy"=@("Write-PINEConfigurationSetDeliveryOption")
}

_awsArgumentCompleterRegistration $PINE_Completers $PINE_map

$PINE_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.PINE.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$PINE_SelectMap = @{
    "Select"=@("New-PINEConfigurationSet",
               "New-PINEConfigurationSetEventDestination",
               "New-PINEDedicatedIpPool",
               "New-PINEDeliverabilityTestReport",
               "New-PINEEmailIdentity",
               "Remove-PINEConfigurationSet",
               "Remove-PINEConfigurationSetEventDestination",
               "Remove-PINEDedicatedIpPool",
               "Remove-PINEEmailIdentity",
               "Get-PINEAccount",
               "Get-PINEBlacklistReport",
               "Get-PINEConfigurationSet",
               "Get-PINEConfigurationSetEventDestination",
               "Get-PINEDedicatedIp",
               "Get-PINEDedicatedIpList",
               "Get-PINEDeliverabilityDashboardOption",
               "Get-PINEDeliverabilityTestReport",
               "Get-PINEDomainDeliverabilityCampaign",
               "Get-PINEDomainStatisticsReport",
               "Get-PINEEmailIdentity",
               "Get-PINEConfigurationSetList",
               "Get-PINEDedicatedIpPoolList",
               "Get-PINEDeliverabilityTestReportList",
               "Get-PINEDomainDeliverabilityCampaignList",
               "Get-PINEEmailIdentityList",
               "Get-PINEResourceTag",
               "Write-PINEAccountDedicatedIpWarmupAttribute",
               "Write-PINEAccountSendingAttribute",
               "Write-PINEConfigurationSetDeliveryOption",
               "Write-PINEConfigurationSetReputationOption",
               "Write-PINEConfigurationSetSendingOption",
               "Write-PINEConfigurationSetTrackingOption",
               "Write-PINEDedicatedIpInPool",
               "Write-PINEDedicatedIpWarmupAttribute",
               "Write-PINEDeliverabilityDashboardOption",
               "Write-PINEEmailIdentityDkimAttribute",
               "Write-PINEEmailIdentityFeedbackAttribute",
               "Write-PINEEmailIdentityMailFromAttribute",
               "Send-PINEEmail",
               "Add-PINEResourceTag",
               "Remove-PINEResourceTag",
               "Update-PINEConfigurationSetEventDestination")
}

_awsArgumentCompleterRegistration $PINE_SelectCompleters $PINE_SelectMap
# Argument completions for service Amazon Polly


$POL_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Polly.Engine
        {
            ($_ -eq "Get-POLSpeech/Engine") -Or
            ($_ -eq "Get-POLVoice/Engine") -Or
            ($_ -eq "Start-POLSpeechSynthesisTask/Engine")
        }
        {
            $v = "neural","standard"
            break
        }

        # Amazon.Polly.LanguageCode
        {
            ($_ -eq "Get-POLSpeech/LanguageCode") -Or
            ($_ -eq "Get-POLVoice/LanguageCode") -Or
            ($_ -eq "Start-POLSpeechSynthesisTask/LanguageCode")
        }
        {
            $v = "arb","cmn-CN","cy-GB","da-DK","de-DE","en-AU","en-GB","en-GB-WLS","en-IN","en-US","es-ES","es-MX","es-US","fr-CA","fr-FR","hi-IN","is-IS","it-IT","ja-JP","ko-KR","nb-NO","nl-NL","pl-PL","pt-BR","pt-PT","ro-RO","ru-RU","sv-SE","tr-TR"
            break
        }

        # Amazon.Polly.OutputFormat
        {
            ($_ -eq "Get-POLSpeech/OutputFormat") -Or
            ($_ -eq "Start-POLSpeechSynthesisTask/OutputFormat")
        }
        {
            $v = "json","mp3","ogg_vorbis","pcm"
            break
        }

        # Amazon.Polly.TaskStatus
        "Get-POLSpeechSynthesisTaskList/Status"
        {
            $v = "completed","failed","inProgress","scheduled"
            break
        }

        # Amazon.Polly.TextType
        {
            ($_ -eq "Get-POLSpeech/TextType") -Or
            ($_ -eq "Start-POLSpeechSynthesisTask/TextType")
        }
        {
            $v = "ssml","text"
            break
        }

        # Amazon.Polly.VoiceId
        {
            ($_ -eq "Get-POLSpeech/VoiceId") -Or
            ($_ -eq "Start-POLSpeechSynthesisTask/VoiceId")
        }
        {
            $v = "Aditi","Amy","Astrid","Bianca","Brian","Camila","Carla","Carmen","Celine","Chantal","Conchita","Cristiano","Dora","Emma","Enrique","Ewa","Filiz","Geraint","Giorgio","Gwyneth","Hans","Ines","Ivy","Jacek","Jan","Joanna","Joey","Justin","Karl","Kendra","Kimberly","Lea","Liv","Lotte","Lucia","Lupe","Mads","Maja","Marlene","Mathieu","Matthew","Maxim","Mia","Miguel","Mizuki","Naja","Nicole","Penelope","Raveena","Ricardo","Ruben","Russell","Salli","Seoyeon","Takumi","Tatyana","Vicki","Vitoria","Zeina","Zhiyu"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$POL_map = @{
    "Engine"=@("Get-POLSpeech","Get-POLVoice","Start-POLSpeechSynthesisTask")
    "LanguageCode"=@("Get-POLSpeech","Get-POLVoice","Start-POLSpeechSynthesisTask")
    "OutputFormat"=@("Get-POLSpeech","Start-POLSpeechSynthesisTask")
    "Status"=@("Get-POLSpeechSynthesisTaskList")
    "TextType"=@("Get-POLSpeech","Start-POLSpeechSynthesisTask")
    "VoiceId"=@("Get-POLSpeech","Start-POLSpeechSynthesisTask")
}

_awsArgumentCompleterRegistration $POL_Completers $POL_map

$POL_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.POL.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$POL_SelectMap = @{
    "Select"=@("Remove-POLLexicon",
               "Get-POLVoice",
               "Get-POLLexicon",
               "Get-POLSpeechSynthesisTask",
               "Get-POLLexiconList",
               "Get-POLSpeechSynthesisTaskList",
               "Write-POLLexicon",
               "Start-POLSpeechSynthesisTask",
               "Get-POLSpeech")
}

_awsArgumentCompleterRegistration $POL_SelectCompleters $POL_SelectMap
# Argument completions for service AWS Price List Service


$PLS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.PLS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$PLS_SelectMap = @{
    "Select"=@("Get-PLSService",
               "Get-PLSAttributeValue",
               "Get-PLSProduct")
}

_awsArgumentCompleterRegistration $PLS_SelectCompleters $PLS_SelectMap
# Argument completions for service Amazon QLDB


$QLDB_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.QLDB.PermissionsMode
        "New-QLDBLedger/PermissionsMode"
        {
            $v = "ALLOW_ALL"
            break
        }

        # Amazon.QLDB.S3ObjectEncryptionType
        "Export-QLDBJournalToS3/S3ExportConfiguration_EncryptionConfiguration_ObjectEncryptionType"
        {
            $v = "NO_ENCRYPTION","SSE_KMS","SSE_S3"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$QLDB_map = @{
    "PermissionsMode"=@("New-QLDBLedger")
    "S3ExportConfiguration_EncryptionConfiguration_ObjectEncryptionType"=@("Export-QLDBJournalToS3")
}

_awsArgumentCompleterRegistration $QLDB_Completers $QLDB_map

$QLDB_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.QLDB.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$QLDB_SelectMap = @{
    "Select"=@("New-QLDBLedger",
               "Remove-QLDBLedger",
               "Get-QLDBJournalS3Export",
               "Get-QLDBLedger",
               "Export-QLDBJournalToS3",
               "Get-QLDBBlock",
               "Get-QLDBDigest",
               "Get-QLDBRevision",
               "Get-QLDBJournalS3ExportList",
               "Get-QLDBJournalS3ExportsForLedgerList",
               "Get-QLDBLedgerList",
               "Get-QLDBResourceTag",
               "Add-QLDBResourceTag",
               "Remove-QLDBResourceTag",
               "Update-QLDBLedger")
}

_awsArgumentCompleterRegistration $QLDB_SelectCompleters $QLDB_SelectMap
# Argument completions for service Amazon QLDB Session


$QLDBS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.QLDBS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$QLDBS_SelectMap = @{
    "Select"=@("Send-QLDBSCommand")
}

_awsArgumentCompleterRegistration $QLDBS_SelectCompleters $QLDBS_SelectMap
# Argument completions for service Amazon QuickSight


$QS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.QuickSight.AssignmentStatus
        {
            ($_ -eq "Get-QSIAMPolicyAssignmentList/AssignmentStatus") -Or
            ($_ -eq "New-QSIAMPolicyAssignment/AssignmentStatus") -Or
            ($_ -eq "Update-QSIAMPolicyAssignment/AssignmentStatus")
        }
        {
            $v = "DISABLED","DRAFT","ENABLED"
            break
        }

        # Amazon.QuickSight.DashboardBehavior
        {
            ($_ -eq "New-QSDashboard/DashboardPublishOptions_AdHocFilteringOption_AvailabilityStatus") -Or
            ($_ -eq "Update-QSDashboard/DashboardPublishOptions_AdHocFilteringOption_AvailabilityStatus") -Or
            ($_ -eq "New-QSDashboard/DashboardPublishOptions_ExportToCSVOption_AvailabilityStatus") -Or
            ($_ -eq "Update-QSDashboard/DashboardPublishOptions_ExportToCSVOption_AvailabilityStatus")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.QuickSight.DashboardUIState
        {
            ($_ -eq "New-QSDashboard/DashboardPublishOptions_SheetControlsOption_VisibilityState") -Or
            ($_ -eq "Update-QSDashboard/DashboardPublishOptions_SheetControlsOption_VisibilityState")
        }
        {
            $v = "COLLAPSED","EXPANDED"
            break
        }

        # Amazon.QuickSight.DataSetImportMode
        {
            ($_ -eq "New-QSDataSet/ImportMode") -Or
            ($_ -eq "Update-QSDataSet/ImportMode")
        }
        {
            $v = "DIRECT_QUERY","SPICE"
            break
        }

        # Amazon.QuickSight.DataSourceType
        "New-QSDataSource/Type"
        {
            $v = "ADOBE_ANALYTICS","AMAZON_ELASTICSEARCH","ATHENA","AURORA","AURORA_POSTGRESQL","AWS_IOT_ANALYTICS","GITHUB","JIRA","MARIADB","MYSQL","POSTGRESQL","PRESTO","REDSHIFT","S3","SALESFORCE","SERVICENOW","SNOWFLAKE","SPARK","SQLSERVER","TERADATA","TWITTER"
            break
        }

        # Amazon.QuickSight.IdentityType
        {
            ($_ -eq "Get-QSDashboardEmbedUrl/IdentityType") -Or
            ($_ -eq "Register-QSUser/IdentityType")
        }
        {
            $v = "IAM","QUICKSIGHT"
            break
        }

        # Amazon.QuickSight.RowLevelPermissionPolicy
        {
            ($_ -eq "New-QSDataSet/RowLevelPermissionDataSet_PermissionPolicy") -Or
            ($_ -eq "Update-QSDataSet/RowLevelPermissionDataSet_PermissionPolicy")
        }
        {
            $v = "DENY_ACCESS","GRANT_ACCESS"
            break
        }

        # Amazon.QuickSight.UserRole
        {
            ($_ -eq "Update-QSUser/Role") -Or
            ($_ -eq "Register-QSUser/UserRole")
        }
        {
            $v = "ADMIN","AUTHOR","READER","RESTRICTED_AUTHOR","RESTRICTED_READER"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$QS_map = @{
    "AssignmentStatus"=@("Get-QSIAMPolicyAssignmentList","New-QSIAMPolicyAssignment","Update-QSIAMPolicyAssignment")
    "DashboardPublishOptions_AdHocFilteringOption_AvailabilityStatus"=@("New-QSDashboard","Update-QSDashboard")
    "DashboardPublishOptions_ExportToCSVOption_AvailabilityStatus"=@("New-QSDashboard","Update-QSDashboard")
    "DashboardPublishOptions_SheetControlsOption_VisibilityState"=@("New-QSDashboard","Update-QSDashboard")
    "IdentityType"=@("Get-QSDashboardEmbedUrl","Register-QSUser")
    "ImportMode"=@("New-QSDataSet","Update-QSDataSet")
    "Role"=@("Update-QSUser")
    "RowLevelPermissionDataSet_PermissionPolicy"=@("New-QSDataSet","Update-QSDataSet")
    "Type"=@("New-QSDataSource")
    "UserRole"=@("Register-QSUser")
}

_awsArgumentCompleterRegistration $QS_Completers $QS_map

$QS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.QS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$QS_SelectMap = @{
    "Select"=@("Stop-QSIngestion",
               "New-QSDashboard",
               "New-QSDataSet",
               "New-QSDataSource",
               "New-QSGroup",
               "New-QSGroupMembership",
               "New-QSIAMPolicyAssignment",
               "New-QSIngestion",
               "New-QSTemplate",
               "New-QSTemplateAlias",
               "Remove-QSDashboard",
               "Remove-QSDataSet",
               "Remove-QSDataSource",
               "Remove-QSGroup",
               "Remove-QSGroupMembership",
               "Remove-QSIAMPolicyAssignment",
               "Remove-QSTemplate",
               "Remove-QSTemplateAlias",
               "Remove-QSUser",
               "Remove-QSUserByPrincipalId",
               "Get-QSDashboard",
               "Get-QSDashboardPermission",
               "Get-QSDataSet",
               "Get-QSDataSetPermission",
               "Get-QSDataSource",
               "Get-QSDataSourcePermission",
               "Get-QSGroup",
               "Get-QSIAMPolicyAssignment",
               "Get-QSIngestion",
               "Get-QSTemplate",
               "Get-QSTemplateAlias",
               "Get-QSTemplatePermission",
               "Get-QSUser",
               "Get-QSDashboardEmbedUrl",
               "Get-QSDashboardList",
               "Get-QSDashboardVersionList",
               "Get-QSDataSetList",
               "Get-QSDataSourceList",
               "Get-QSGroupMembershipList",
               "Get-QSGroupList",
               "Get-QSIAMPolicyAssignmentList",
               "Get-QSIAMPolicyAssignmentsForUserList",
               "Get-QSIngestionList",
               "Get-QSResourceTag",
               "Get-QSTemplateAliasList",
               "Get-QSTemplateList",
               "Get-QSTemplateVersionList",
               "Get-QSUserGroupList",
               "Get-QSUserList",
               "Register-QSUser",
               "Add-QSResourceTag",
               "Remove-QSResourceTag",
               "Update-QSDashboard",
               "Update-QSDashboardPermission",
               "Update-QSDashboardPublishedVersion",
               "Update-QSDataSet",
               "Update-QSDataSetPermission",
               "Update-QSDataSource",
               "Update-QSDataSourcePermission",
               "Update-QSGroup",
               "Update-QSIAMPolicyAssignment",
               "Update-QSTemplate",
               "Update-QSTemplateAlias",
               "Update-QSTemplatePermission",
               "Update-QSUser")
}

_awsArgumentCompleterRegistration $QS_SelectCompleters $QS_SelectMap
# Argument completions for service AWS Resource Access Manager (RAM)


$RAM_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.RAM.ResourceOwner
        {
            ($_ -eq "Get-RAMPrincipalList/ResourceOwner") -Or
            ($_ -eq "Get-RAMResourceList/ResourceOwner") -Or
            ($_ -eq "Get-RAMResourceShare/ResourceOwner")
        }
        {
            $v = "OTHER-ACCOUNTS","SELF"
            break
        }

        # Amazon.RAM.ResourceShareAssociationStatus
        "Get-RAMResourceShareAssociation/AssociationStatus"
        {
            $v = "ASSOCIATED","ASSOCIATING","DISASSOCIATED","DISASSOCIATING","FAILED"
            break
        }

        # Amazon.RAM.ResourceShareAssociationType
        "Get-RAMResourceShareAssociation/AssociationType"
        {
            $v = "PRINCIPAL","RESOURCE"
            break
        }

        # Amazon.RAM.ResourceShareStatus
        "Get-RAMResourceShare/ResourceShareStatus"
        {
            $v = "ACTIVE","DELETED","DELETING","FAILED","PENDING"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$RAM_map = @{
    "AssociationStatus"=@("Get-RAMResourceShareAssociation")
    "AssociationType"=@("Get-RAMResourceShareAssociation")
    "ResourceOwner"=@("Get-RAMPrincipalList","Get-RAMResourceList","Get-RAMResourceShare")
    "ResourceShareStatus"=@("Get-RAMResourceShare")
}

_awsArgumentCompleterRegistration $RAM_Completers $RAM_map

$RAM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.RAM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$RAM_SelectMap = @{
    "Select"=@("Confirm-RAMResourceShareInvitation",
               "Connect-RAMResourceShare",
               "Add-RAMPermissionToResourceShare",
               "New-RAMResourceShare",
               "Remove-RAMResourceShare",
               "Disconnect-RAMResourceShare",
               "Remove-RAMPermissionFromResourceShare",
               "Enable-RAMSharingWithAwsOrganization",
               "Get-RAMPermission",
               "Get-RAMResourcePolicy",
               "Get-RAMResourceShareAssociation",
               "Get-RAMResourceShareInvitation",
               "Get-RAMResourceShare",
               "Get-RAMPendingInvitationResourceList",
               "Get-RAMPermissionList",
               "Get-RAMPrincipalList",
               "Get-RAMResourceList",
               "Get-RAMResourceSharePermissionList",
               "Convert-RAMPolicyBasedResourceShareToPromoted",
               "Deny-RAMResourceShareInvitation",
               "Add-RAMResourceTag",
               "Remove-RAMResourceTag",
               "Update-RAMResourceShare")
}

_awsArgumentCompleterRegistration $RAM_SelectCompleters $RAM_SelectMap
# Argument completions for service Amazon Relational Database Service


$RDS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.RDS.ActivityStreamMode
        "Start-RDSActivityStream/Mode"
        {
            $v = "async","sync"
            break
        }

        # Amazon.RDS.EngineFamily
        "New-RDSDBProxy/EngineFamily"
        {
            $v = "MYSQL"
            break
        }

        # Amazon.RDS.SourceType
        "Get-RDSEvent/SourceType"
        {
            $v = "db-cluster","db-cluster-snapshot","db-instance","db-parameter-group","db-security-group","db-snapshot"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$RDS_map = @{
    "EngineFamily"=@("New-RDSDBProxy")
    "Mode"=@("Start-RDSActivityStream")
    "SourceType"=@("Get-RDSEvent")
}

_awsArgumentCompleterRegistration $RDS_Completers $RDS_map

$RDS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.RDS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$RDS_SelectMap = @{
    "Select"=@("Add-RDSRoleToDBCluster",
               "Add-RDSRoleToDBInstance",
               "Add-RDSSourceIdentifierToSubscription",
               "Add-RDSTagsToResource",
               "Submit-RDSPendingMaintenanceAction",
               "Enable-RDSDBSecurityGroupIngress",
               "Reset-RDSDBCluster",
               "Copy-RDSDBClusterParameterGroup",
               "Copy-RDSDBClusterSnapshot",
               "Copy-RDSDBParameterGroup",
               "Copy-RDSDBSnapshot",
               "Copy-RDSOptionGroup",
               "New-RDSCustomAvailabilityZone",
               "New-RDSDBCluster",
               "New-RDSDBClusterEndpoint",
               "New-RDSDBClusterParameterGroup",
               "New-RDSDBClusterSnapshot",
               "New-RDSDBInstance",
               "New-RDSDBInstanceReadReplica",
               "New-RDSDBParameterGroup",
               "New-RDSDBProxy",
               "New-RDSDBSecurityGroup",
               "New-RDSDBSnapshot",
               "New-RDSDBSubnetGroup",
               "New-RDSEventSubscription",
               "New-RDSGlobalCluster",
               "New-RDSOptionGroup",
               "Remove-RDSCustomAvailabilityZone",
               "Remove-RDSDBCluster",
               "Remove-RDSDBClusterEndpoint",
               "Remove-RDSDBClusterParameterGroup",
               "Remove-RDSDBClusterSnapshot",
               "Remove-RDSDBInstance",
               "Remove-RDSDBInstanceAutomatedBackup",
               "Remove-RDSDBParameterGroup",
               "Remove-RDSDBProxy",
               "Remove-RDSDBSecurityGroup",
               "Remove-RDSDBSnapshot",
               "Remove-RDSDBSubnetGroup",
               "Remove-RDSEventSubscription",
               "Remove-RDSGlobalCluster",
               "Remove-RDSInstallationMedia",
               "Remove-RDSOptionGroup",
               "Unregister-RDSDBProxyTarget",
               "Get-RDSAccountAttribute",
               "Get-RDSCertificate",
               "Get-RDSCustomAvailabilityZone",
               "Get-RDSDBClusterBacktrackList",
               "Get-RDSDBClusterEndpoint",
               "Get-RDSDBClusterParameterGroup",
               "Get-RDSDBClusterParameter",
               "Get-RDSDBCluster",
               "Get-RDSDBClusterSnapshotAttribute",
               "Get-RDSDBClusterSnapshot",
               "Get-RDSDBEngineVersion",
               "Get-RDSDBInstanceAutomatedBackup",
               "Get-RDSDBInstance",
               "Get-RDSDBLogFile",
               "Get-RDSDBParameterGroup",
               "Get-RDSDBParameter",
               "Get-RDSDBProxy",
               "Get-RDSDBProxyTargetGroup",
               "Get-RDSDBProxyTarget",
               "Get-RDSDBSecurityGroup",
               "Get-RDSDBSnapshotAttribute",
               "Get-RDSDBSnapshot",
               "Get-RDSDBSubnetGroup",
               "Get-RDSEngineDefaultClusterParameter",
               "Get-RDSEngineDefaultParameter",
               "Get-RDSEventCategory",
               "Get-RDSEvent",
               "Get-RDSEventSubscription",
               "Get-RDSGlobalCluster",
               "Get-RDSInstallationMedia",
               "Get-RDSOptionGroupOption",
               "Get-RDSOptionGroup",
               "Get-RDSOrderableDBInstanceOption",
               "Get-RDSPendingMaintenanceAction",
               "Get-RDSReservedDBInstance",
               "Get-RDSReservedDBInstancesOfferingList",
               "Get-RDSSourceRegion",
               "Get-RDSValidDBInstanceModification",
               "Get-RDSDBLogFilePortion",
               "Start-RDSDBClusterFailover",
               "Import-RDSInstallationMedia",
               "Get-RDSTagForResource",
               "Edit-RDSCurrentDBClusterCapacity",
               "Edit-RDSDBCluster",
               "Edit-RDSDBClusterEndpoint",
               "Edit-RDSDBClusterParameterGroup",
               "Edit-RDSDBClusterSnapshotAttribute",
               "Edit-RDSDBInstance",
               "Edit-RDSDBParameterGroup",
               "Edit-RDSDBProxy",
               "Edit-RDSDBProxyTargetGroup",
               "Edit-RDSDBSnapshot",
               "Edit-RDSDBSnapshotAttribute",
               "Edit-RDSDBSubnetGroup",
               "Edit-RDSEventSubscription",
               "Edit-RDSGlobalCluster",
               "Edit-RDSOptionGroup",
               "Convert-RDSReadReplicaToStandalone",
               "Convert-RDSReadReplicaDBCluster",
               "New-RDSReservedDBInstancesOfferingPurchase",
               "Restart-RDSDBInstance",
               "Register-RDSDBProxyTarget",
               "Remove-RDSFromGlobalCluster",
               "Remove-RDSRoleFromDBCluster",
               "Remove-RDSRoleFromDBInstance",
               "Remove-RDSSourceIdentifierFromSubscription",
               "Remove-RDSTagFromResource",
               "Reset-RDSDBClusterParameterGroup",
               "Reset-RDSDBParameterGroup",
               "Restore-RDSDBClusterFromS3",
               "Restore-RDSDBClusterFromSnapshot",
               "Restore-RDSDBClusterToPointInTime",
               "Restore-RDSDBInstanceFromDBSnapshot",
               "Restore-RDSDBInstanceFromS3",
               "Restore-RDSDBInstanceToPointInTime",
               "Revoke-RDSDBSecurityGroupIngress",
               "Start-RDSActivityStream",
               "Start-RDSDBCluster",
               "Start-RDSDBInstance",
               "Stop-RDSActivityStream",
               "Stop-RDSDBCluster",
               "Stop-RDSDBInstance")
}

_awsArgumentCompleterRegistration $RDS_SelectCompleters $RDS_SelectMap
# Argument completions for service AWS RDS DataService


$RDSD_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.RDSDataService.DecimalReturnType
        "Invoke-RDSDStatement/ResultSetOptions_DecimalReturnType"
        {
            $v = "DOUBLE_OR_LONG","STRING"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$RDSD_map = @{
    "ResultSetOptions_DecimalReturnType"=@("Invoke-RDSDStatement")
}

_awsArgumentCompleterRegistration $RDSD_Completers $RDSD_map

$RDSD_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.RDSD.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$RDSD_SelectMap = @{
    "Select"=@("Invoke-RDSDStatementBatch",
               "Start-RDSDTransaction",
               "Confirm-RDSDTransaction",
               "Invoke-RDSDSqlStatement",
               "Invoke-RDSDStatement",
               "Reset-RDSDTransaction")
}

_awsArgumentCompleterRegistration $RDSD_SelectCompleters $RDSD_SelectMap
# Argument completions for service Amazon Redshift


$RS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Redshift.ActionType
        "Get-RSNodeConfigurationOption/ActionType"
        {
            $v = "recommend-node-config","restore-cluster"
            break
        }

        # Amazon.Redshift.ScheduledActionTypeValues
        "Get-RSScheduledAction/TargetActionType"
        {
            $v = "ResizeCluster"
            break
        }

        # Amazon.Redshift.SourceType
        "Get-RSEvent/SourceType"
        {
            $v = "cluster","cluster-parameter-group","cluster-security-group","cluster-snapshot","scheduled-action"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$RS_map = @{
    "ActionType"=@("Get-RSNodeConfigurationOption")
    "SourceType"=@("Get-RSEvent")
    "TargetActionType"=@("Get-RSScheduledAction")
}

_awsArgumentCompleterRegistration $RS_Completers $RS_map

$RS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.RS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$RS_SelectMap = @{
    "Select"=@("Switch-RSReservedNode",
               "Approve-RSClusterSecurityGroupIngress",
               "Approve-RSSnapshotAccess",
               "Remove-RSClusterSnapshotBatch",
               "Edit-RSClusterSnapshotBatch",
               "Stop-RSResize",
               "Copy-RSClusterSnapshot",
               "New-RSCluster",
               "New-RSClusterParameterGroup",
               "New-RSClusterSecurityGroup",
               "New-RSClusterSnapshot",
               "New-RSClusterSubnetGroup",
               "New-RSEventSubscription",
               "New-RSHsmClientCertificate",
               "New-RSHsmConfiguration",
               "New-RSScheduledAction",
               "New-RSSnapshotCopyGrant",
               "New-RSSnapshotSchedule",
               "New-RSResourceTag",
               "Remove-RSCluster",
               "Remove-RSClusterParameterGroup",
               "Remove-RSClusterSecurityGroup",
               "Remove-RSClusterSnapshot",
               "Remove-RSClusterSubnetGroup",
               "Remove-RSEventSubscription",
               "Remove-RSHsmClientCertificate",
               "Remove-RSHsmConfiguration",
               "Remove-RSScheduledAction",
               "Remove-RSSnapshotCopyGrant",
               "Remove-RSSnapshotSchedule",
               "Remove-RSResourceTag",
               "Get-RSAccountAttribute",
               "Get-RSClusterDbRevision",
               "Get-RSClusterParameterGroup",
               "Get-RSClusterParameter",
               "Get-RSCluster",
               "Get-RSClusterSecurityGroup",
               "Get-RSClusterSnapshot",
               "Get-RSClusterSubnetGroup",
               "Get-RSClusterTrack",
               "Get-RSClusterVersion",
               "Get-RSDefaultClusterParameter",
               "Get-RSEventCategory",
               "Get-RSEvent",
               "Get-RSEventSubscription",
               "Get-RSHsmClientCertificate",
               "Get-RSHsmConfiguration",
               "Get-RSLoggingStatus",
               "Get-RSNodeConfigurationOption",
               "Get-RSOrderableClusterOption",
               "Get-RSReservedNodeOffering",
               "Get-RSReservedNode",
               "Get-RSResize",
               "Get-RSScheduledAction",
               "Get-RSSnapshotCopyGrant",
               "Get-RSSnapshotSchedule",
               "Get-RSStorage",
               "Get-RSTableRestoreStatus",
               "Get-RSResourceTag",
               "Disable-RSLogging",
               "Disable-RSSnapshotCopy",
               "Enable-RSLogging",
               "Enable-RSSnapshotCopy",
               "Get-RSClusterCredential",
               "Get-RSReservedNodeExchangeOffering",
               "Edit-RSCluster",
               "Edit-RSClusterDbRevision",
               "Edit-RSClusterIamRole",
               "Edit-RSClusterMaintenance",
               "Edit-RSClusterParameterGroup",
               "Edit-RSClusterSnapshot",
               "Edit-RSClusterSnapshotSchedule",
               "Edit-RSClusterSubnetGroup",
               "Edit-RSEventSubscription",
               "Edit-RSScheduledAction",
               "Edit-RSSnapshotCopyRetentionPeriod",
               "Edit-RSSnapshotSchedule",
               "Request-RSReservedNodeOffering",
               "Restart-RSCluster",
               "Reset-RSClusterParameterGroup",
               "Set-RSClusterSize",
               "Restore-RSFromClusterSnapshot",
               "Restore-RSTableFromClusterSnapshot",
               "Revoke-RSClusterSecurityGroupIngress",
               "Revoke-RSSnapshotAccess",
               "Switch-RSEncryptionKey")
}

_awsArgumentCompleterRegistration $RS_SelectCompleters $RS_SelectMap
# Argument completions for service Amazon Rekognition


$REK_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Rekognition.CelebrityRecognitionSortBy
        "Get-REKCelebrityRecognition/SortBy"
        {
            $v = "ID","TIMESTAMP"
            break
        }

        # Amazon.Rekognition.ContentModerationSortBy
        "Get-REKContentModeration/SortBy"
        {
            $v = "NAME","TIMESTAMP"
            break
        }

        # Amazon.Rekognition.FaceAttributes
        "Start-REKFaceDetection/FaceAttributes"
        {
            $v = "ALL","DEFAULT"
            break
        }

        # Amazon.Rekognition.FaceSearchSortBy
        "Get-REKFaceSearch/SortBy"
        {
            $v = "INDEX","TIMESTAMP"
            break
        }

        # Amazon.Rekognition.LabelDetectionSortBy
        "Get-REKLabelDetection/SortBy"
        {
            $v = "NAME","TIMESTAMP"
            break
        }

        # Amazon.Rekognition.PersonTrackingSortBy
        "Get-REKPersonTracking/SortBy"
        {
            $v = "INDEX","TIMESTAMP"
            break
        }

        # Amazon.Rekognition.QualityFilter
        {
            ($_ -eq "Add-REKDetectedFacesToCollection/QualityFilter") -Or
            ($_ -eq "Compare-REKFace/QualityFilter") -Or
            ($_ -eq "Search-REKFacesByImage/QualityFilter")
        }
        {
            $v = "AUTO","HIGH","LOW","MEDIUM","NONE"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$REK_map = @{
    "FaceAttributes"=@("Start-REKFaceDetection")
    "QualityFilter"=@("Add-REKDetectedFacesToCollection","Compare-REKFace","Search-REKFacesByImage")
    "SortBy"=@("Get-REKCelebrityRecognition","Get-REKContentModeration","Get-REKFaceSearch","Get-REKLabelDetection","Get-REKPersonTracking")
}

_awsArgumentCompleterRegistration $REK_Completers $REK_map

$REK_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.REK.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$REK_SelectMap = @{
    "Select"=@("Compare-REKFace",
               "New-REKCollection",
               "New-REKProject",
               "New-REKProjectVersion",
               "New-REKStreamProcessor",
               "Remove-REKCollection",
               "Remove-REKFace",
               "Remove-REKStreamProcessor",
               "Get-REKCollection",
               "Get-REKProject",
               "Get-REKProjectVersion",
               "Get-REKStreamProcessor",
               "Find-REKCustomLabel",
               "Find-REKFace",
               "Find-REKLabel",
               "Find-REKModerationLabel",
               "Find-REKText",
               "Get-REKCelebrityInfo",
               "Get-REKCelebrityRecognition",
               "Get-REKContentModeration",
               "Get-REKFaceDetection",
               "Get-REKFaceSearch",
               "Get-REKLabelDetection",
               "Get-REKPersonTracking",
               "Add-REKDetectedFacesToCollection",
               "Get-REKCollectionIdList",
               "Get-REKFaceList",
               "Get-REKStreamProcessorList",
               "Find-REKCelebrity",
               "Search-REKFace",
               "Search-REKFacesByImage",
               "Start-REKCelebrityRecognition",
               "Start-REKContentModeration",
               "Start-REKFaceDetection",
               "Start-REKFaceSearch",
               "Start-REKLabelDetection",
               "Start-REKPersonTracking",
               "Start-REKProjectVersion",
               "Start-REKStreamProcessor",
               "Stop-REKProjectVersion",
               "Stop-REKStreamProcessor")
}

_awsArgumentCompleterRegistration $REK_SelectCompleters $REK_SelectMap
# Argument completions for service AWS Resource Groups


$RG_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.RG.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$RG_SelectMap = @{
    "Select"=@("New-RGGroup",
               "Remove-RGGroup",
               "Get-RGGroup",
               "Get-RGGroupQuery",
               "Get-RGResourceTag",
               "Get-RGGroupResourceList",
               "Get-RGGroupList",
               "Find-RGResource",
               "Add-RGResourceTag",
               "Remove-RGResourceTag",
               "Update-RGGroup",
               "Update-RGGroupQuery")
}

_awsArgumentCompleterRegistration $RG_SelectCompleters $RG_SelectMap
# Argument completions for service AWS Resource Groups Tagging API


$RGT_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.RGT.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$RGT_SelectMap = @{
    "Select"=@("Get-RGTReportCreation",
               "Get-RGTComplianceSummary",
               "Get-RGTResource",
               "Get-RGTTagKey",
               "Get-RGTTagValue",
               "Start-RGTReportCreation",
               "Add-RGTResourceTag",
               "Remove-RGTResourceTag")
}

_awsArgumentCompleterRegistration $RGT_SelectCompleters $RGT_SelectMap
# Argument completions for service AWS RoboMaker


$ROBO_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.RoboMaker.Architecture
        "New-ROBORobot/Architecture"
        {
            $v = "ARM64","ARMHF","X86_64"
            break
        }

        # Amazon.RoboMaker.FailureBehavior
        "New-ROBOSimulationJob/FailureBehavior"
        {
            $v = "Continue","Fail"
            break
        }

        # Amazon.RoboMaker.RenderingEngineType
        {
            ($_ -eq "New-ROBOSimulationApplication/RenderingEngine_Name") -Or
            ($_ -eq "Update-ROBOSimulationApplication/RenderingEngine_Name")
        }
        {
            $v = "OGRE"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ROBO_map = @{
    "Architecture"=@("New-ROBORobot")
    "FailureBehavior"=@("New-ROBOSimulationJob")
    "RenderingEngine_Name"=@("New-ROBOSimulationApplication","Update-ROBOSimulationApplication")
}

_awsArgumentCompleterRegistration $ROBO_Completers $ROBO_map

$ROBO_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ROBO.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ROBO_SelectMap = @{
    "Select"=@("Get-ROBOSimulationJobList",
               "Stop-ROBODeploymentJob",
               "Stop-ROBOSimulationJob",
               "New-ROBODeploymentJob",
               "New-ROBOFleet",
               "New-ROBORobot",
               "New-ROBORobotApplication",
               "New-ROBORobotApplicationVersion",
               "New-ROBOSimulationApplication",
               "New-ROBOSimulationApplicationVersion",
               "New-ROBOSimulationJob",
               "Remove-ROBOFleet",
               "Remove-ROBORobot",
               "Remove-ROBORobotApplication",
               "Remove-ROBOSimulationApplication",
               "Unregister-ROBORobot",
               "Get-ROBODeploymentJob",
               "Get-ROBOFleet",
               "Get-ROBORobot",
               "Get-ROBORobotApplication",
               "Get-ROBOSimulationApplication",
               "Get-ROBOSimulationJob",
               "Get-ROBODeploymentJobList",
               "Get-ROBOFleetList",
               "Get-ROBORobotApplicationList",
               "Get-ROBORobotList",
               "Get-ROBOSimulationApplicationList",
               "Get-ROBOSimulationJobSummary",
               "Get-ROBOResourceTag",
               "Register-ROBORobot",
               "Restart-ROBOSimulationJob",
               "Sync-ROBODeploymentJob",
               "Add-ROBOResourceTag",
               "Remove-ROBOResourceTag",
               "Update-ROBORobotApplication",
               "Update-ROBOSimulationApplication")
}

_awsArgumentCompleterRegistration $ROBO_SelectCompleters $ROBO_SelectMap
# Argument completions for service Amazon Route 53


$R53_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Route53.AccountLimitType
        "Get-R53AccountLimit/Type"
        {
            $v = "MAX_HEALTH_CHECKS_BY_OWNER","MAX_HOSTED_ZONES_BY_OWNER","MAX_REUSABLE_DELEGATION_SETS_BY_OWNER","MAX_TRAFFIC_POLICIES_BY_OWNER","MAX_TRAFFIC_POLICY_INSTANCES_BY_OWNER"
            break
        }

        # Amazon.Route53.CloudWatchRegion
        {
            ($_ -eq "Update-R53HealthCheck/AlarmIdentifier_Region") -Or
            ($_ -eq "New-R53HealthCheck/HealthCheckConfig_AlarmIdentifier_Region")
        }
        {
            $v = "ap-east-1","ap-northeast-1","ap-northeast-2","ap-northeast-3","ap-south-1","ap-southeast-1","ap-southeast-2","ca-central-1","cn-north-1","cn-northwest-1","eu-central-1","eu-north-1","eu-west-1","eu-west-2","eu-west-3","me-south-1","sa-east-1","us-east-1","us-east-2","us-west-1","us-west-2"
            break
        }

        # Amazon.Route53.HealthCheckType
        "New-R53HealthCheck/HealthCheckConfig_Type"
        {
            $v = "CALCULATED","CLOUDWATCH_METRIC","HTTP","HTTPS","HTTPS_STR_MATCH","HTTP_STR_MATCH","TCP"
            break
        }

        # Amazon.Route53.HostedZoneLimitType
        "Get-R53HostedZoneLimit/Type"
        {
            $v = "MAX_RRSETS_BY_ZONE","MAX_VPCS_ASSOCIATED_BY_ZONE"
            break
        }

        # Amazon.Route53.InsufficientDataHealthStatus
        {
            ($_ -eq "New-R53HealthCheck/HealthCheckConfig_InsufficientDataHealthStatus") -Or
            ($_ -eq "Update-R53HealthCheck/InsufficientDataHealthStatus")
        }
        {
            $v = "Healthy","LastKnownStatus","Unhealthy"
            break
        }

        # Amazon.Route53.ReusableDelegationSetLimitType
        "Get-R53ReusableDelegationSetLimit/Type"
        {
            $v = "MAX_ZONES_BY_REUSABLE_DELEGATION_SET"
            break
        }

        # Amazon.Route53.RRType
        {
            ($_ -eq "Test-R53DNSAnswer/RecordType") -Or
            ($_ -eq "Get-R53ResourceRecordSet/StartRecordType") -Or
            ($_ -eq "Get-R53TrafficPolicyInstanceList/TrafficPolicyInstanceTypeMarker") -Or
            ($_ -eq "Get-R53TrafficPolicyInstancesByHostedZone/TrafficPolicyInstanceTypeMarker") -Or
            ($_ -eq "Get-R53TrafficPolicyInstancesByPolicy/TrafficPolicyInstanceTypeMarker")
        }
        {
            $v = "A","AAAA","CAA","CNAME","MX","NAPTR","NS","PTR","SOA","SPF","SRV","TXT"
            break
        }

        # Amazon.Route53.TagResourceType
        {
            ($_ -eq "Edit-R53TagsForResource/ResourceType") -Or
            ($_ -eq "Get-R53TagsForResource/ResourceType") -Or
            ($_ -eq "Get-R53TagsForResourceList/ResourceType")
        }
        {
            $v = "healthcheck","hostedzone"
            break
        }

        # Amazon.Route53.VPCRegion
        {
            ($_ -eq "New-R53HostedZone/VPC_VPCRegion") -Or
            ($_ -eq "New-R53VPCAssociationAuthorization/VPC_VPCRegion") -Or
            ($_ -eq "Register-R53VPCWithHostedZone/VPC_VPCRegion") -Or
            ($_ -eq "Remove-R53VPCAssociationAuthorization/VPC_VPCRegion") -Or
            ($_ -eq "Unregister-R53VPCFromHostedZone/VPC_VPCRegion")
        }
        {
            $v = "ap-east-1","ap-northeast-1","ap-northeast-2","ap-northeast-3","ap-south-1","ap-southeast-1","ap-southeast-2","ca-central-1","cn-north-1","eu-central-1","eu-north-1","eu-west-1","eu-west-2","eu-west-3","me-south-1","sa-east-1","us-east-1","us-east-2","us-west-1","us-west-2"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$R53_map = @{
    "AlarmIdentifier_Region"=@("Update-R53HealthCheck")
    "HealthCheckConfig_AlarmIdentifier_Region"=@("New-R53HealthCheck")
    "HealthCheckConfig_InsufficientDataHealthStatus"=@("New-R53HealthCheck")
    "HealthCheckConfig_Type"=@("New-R53HealthCheck")
    "InsufficientDataHealthStatus"=@("Update-R53HealthCheck")
    "RecordType"=@("Test-R53DNSAnswer")
    "ResourceType"=@("Edit-R53TagsForResource","Get-R53TagsForResource","Get-R53TagsForResourceList")
    "StartRecordType"=@("Get-R53ResourceRecordSet")
    "TrafficPolicyInstanceTypeMarker"=@("Get-R53TrafficPolicyInstanceList","Get-R53TrafficPolicyInstancesByHostedZone","Get-R53TrafficPolicyInstancesByPolicy")
    "Type"=@("Get-R53AccountLimit","Get-R53HostedZoneLimit","Get-R53ReusableDelegationSetLimit")
    "VPC_VPCRegion"=@("New-R53HostedZone","New-R53VPCAssociationAuthorization","Register-R53VPCWithHostedZone","Remove-R53VPCAssociationAuthorization","Unregister-R53VPCFromHostedZone")
}

_awsArgumentCompleterRegistration $R53_Completers $R53_map

$R53_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.R53.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$R53_SelectMap = @{
    "Select"=@("Register-R53VPCWithHostedZone",
               "Edit-R53ResourceRecordSet",
               "Edit-R53TagsForResource",
               "New-R53HealthCheck",
               "New-R53HostedZone",
               "New-R53QueryLoggingConfig",
               "New-R53ReusableDelegationSet",
               "New-R53TrafficPolicy",
               "New-R53TrafficPolicyInstance",
               "New-R53TrafficPolicyVersion",
               "New-R53VPCAssociationAuthorization",
               "Remove-R53HealthCheck",
               "Remove-R53HostedZone",
               "Remove-R53QueryLoggingConfig",
               "Remove-R53ReusableDelegationSet",
               "Remove-R53TrafficPolicy",
               "Remove-R53TrafficPolicyInstance",
               "Remove-R53VPCAssociationAuthorization",
               "Unregister-R53VPCFromHostedZone",
               "Get-R53AccountLimit",
               "Get-R53Change",
               "Get-R53CheckerIpRange",
               "Get-R53GeoLocation",
               "Get-R53HealthCheck",
               "Get-R53HealthCheckCount",
               "Get-R53HealthCheckLastFailureReason",
               "Get-R53HealthCheckStatus",
               "Get-R53HostedZone",
               "Get-R53HostedZoneCount",
               "Get-R53HostedZoneLimit",
               "Get-R53QueryLoggingConfig",
               "Get-R53ReusableDelegationSet",
               "Get-R53ReusableDelegationSetLimit",
               "Get-R53TrafficPolicy",
               "Get-R53TrafficPolicyInstance",
               "Get-R53TrafficPolicyInstanceCount",
               "Get-R53GeoLocationList",
               "Get-R53HealthCheckList",
               "Get-R53HostedZoneList",
               "Get-R53QueryLoggingConfigList",
               "Get-R53ResourceRecordSet",
               "Get-R53ReusableDelegationSetList",
               "Get-R53TagsForResource",
               "Get-R53TagsForResourceList",
               "Get-R53TrafficPolicyList",
               "Get-R53TrafficPolicyInstanceList",
               "Get-R53TrafficPolicyInstancesByHostedZone",
               "Get-R53TrafficPolicyInstancesByPolicy",
               "Get-R53TrafficPolicyVersionList",
               "Get-R53VPCAssociationAuthorizationList",
               "Test-R53DNSAnswer",
               "Update-R53HealthCheck",
               "Update-R53HostedZoneComment",
               "Update-R53TrafficPolicyComment",
               "Update-R53TrafficPolicyInstance",
               "Get-R53HostedZonesByName")
}

_awsArgumentCompleterRegistration $R53_SelectCompleters $R53_SelectMap
# Argument completions for service Amazon Route 53 Domains


$R53D_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Route53Domains.ContactType
        {
            ($_ -eq "Invoke-R53DDomainTransfer/AdminContact_ContactType") -Or
            ($_ -eq "Register-R53DDomain/AdminContact_ContactType") -Or
            ($_ -eq "Update-R53DDomainContact/AdminContact_ContactType") -Or
            ($_ -eq "Invoke-R53DDomainTransfer/RegistrantContact_ContactType") -Or
            ($_ -eq "Register-R53DDomain/RegistrantContact_ContactType") -Or
            ($_ -eq "Update-R53DDomainContact/RegistrantContact_ContactType") -Or
            ($_ -eq "Invoke-R53DDomainTransfer/TechContact_ContactType") -Or
            ($_ -eq "Register-R53DDomain/TechContact_ContactType") -Or
            ($_ -eq "Update-R53DDomainContact/TechContact_ContactType")
        }
        {
            $v = "ASSOCIATION","COMPANY","PERSON","PUBLIC_BODY","RESELLER"
            break
        }

        # Amazon.Route53Domains.CountryCode
        {
            ($_ -eq "Invoke-R53DDomainTransfer/AdminContact_CountryCode") -Or
            ($_ -eq "Register-R53DDomain/AdminContact_CountryCode") -Or
            ($_ -eq "Update-R53DDomainContact/AdminContact_CountryCode") -Or
            ($_ -eq "Invoke-R53DDomainTransfer/RegistrantContact_CountryCode") -Or
            ($_ -eq "Register-R53DDomain/RegistrantContact_CountryCode") -Or
            ($_ -eq "Update-R53DDomainContact/RegistrantContact_CountryCode") -Or
            ($_ -eq "Invoke-R53DDomainTransfer/TechContact_CountryCode") -Or
            ($_ -eq "Register-R53DDomain/TechContact_CountryCode") -Or
            ($_ -eq "Update-R53DDomainContact/TechContact_CountryCode")
        }
        {
            $v = "AD","AE","AF","AG","AI","AL","AM","AN","AO","AQ","AR","AS","AT","AU","AW","AZ","BA","BB","BD","BE","BF","BG","BH","BI","BJ","BL","BM","BN","BO","BR","BS","BT","BW","BY","BZ","CA","CC","CD","CF","CG","CH","CI","CK","CL","CM","CN","CO","CR","CU","CV","CX","CY","CZ","DE","DJ","DK","DM","DO","DZ","EC","EE","EG","ER","ES","ET","FI","FJ","FK","FM","FO","FR","GA","GB","GD","GE","GH","GI","GL","GM","GN","GQ","GR","GT","GU","GW","GY","HK","HN","HR","HT","HU","ID","IE","IL","IM","IN","IQ","IR","IS","IT","JM","JO","JP","KE","KG","KH","KI","KM","KN","KP","KR","KW","KY","KZ","LA","LB","LC","LI","LK","LR","LS","LT","LU","LV","LY","MA","MC","MD","ME","MF","MG","MH","MK","ML","MM","MN","MO","MP","MR","MS","MT","MU","MV","MW","MX","MY","MZ","NA","NC","NE","NG","NI","NL","NO","NP","NR","NU","NZ","OM","PA","PE","PF","PG","PH","PK","PL","PM","PN","PR","PT","PW","PY","QA","RO","RS","RU","RW","SA","SB","SC","SD","SE","SG","SH","SI","SK","SL","SM","SN","SO","SR","ST","SV","SY","SZ","TC","TD","TG","TH","TJ","TK","TL","TM","TN","TO","TR","TT","TV","TW","TZ","UA","UG","US","UY","UZ","VA","VC","VE","VG","VI","VN","VU","WF","WS","YE","YT","ZA","ZM","ZW"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$R53D_map = @{
    "AdminContact_ContactType"=@("Invoke-R53DDomainTransfer","Register-R53DDomain","Update-R53DDomainContact")
    "AdminContact_CountryCode"=@("Invoke-R53DDomainTransfer","Register-R53DDomain","Update-R53DDomainContact")
    "RegistrantContact_ContactType"=@("Invoke-R53DDomainTransfer","Register-R53DDomain","Update-R53DDomainContact")
    "RegistrantContact_CountryCode"=@("Invoke-R53DDomainTransfer","Register-R53DDomain","Update-R53DDomainContact")
    "TechContact_ContactType"=@("Invoke-R53DDomainTransfer","Register-R53DDomain","Update-R53DDomainContact")
    "TechContact_CountryCode"=@("Invoke-R53DDomainTransfer","Register-R53DDomain","Update-R53DDomainContact")
}

_awsArgumentCompleterRegistration $R53D_Completers $R53D_map

$R53D_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.R53D.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$R53D_SelectMap = @{
    "Select"=@("Test-R53DDomainAvailability",
               "Test-R53DDomainTransferability",
               "Remove-R53DTagsForDomain",
               "Disable-R53DDomainAutoRenew",
               "Disable-R53DDomainTransferLock",
               "Enable-R53DDomainAutoRenew",
               "Enable-R53DDomainTransferLock",
               "Get-R53DContactReachabilityStatus",
               "Get-R53DDomainDetail",
               "Get-R53DDomainSuggestion",
               "Get-R53DOperationDetail",
               "Get-R53DDomainList",
               "Get-R53DOperationList",
               "Get-R53DTagsForDomain",
               "Register-R53DDomain",
               "Update-R53DDomainRenewal",
               "Send-R53DContactReachabilityEmail",
               "Get-R53DDomainAuthCode",
               "Invoke-R53DDomainTransfer",
               "Update-R53DDomainContact",
               "Update-R53DDomainContactPrivacy",
               "Update-R53DDomainNameserver",
               "Update-R53DTagsForDomain",
               "Get-R53DBillingRecord")
}

_awsArgumentCompleterRegistration $R53D_SelectCompleters $R53D_SelectMap
# Argument completions for service Amazon Route 53 Resolver


$R53R_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Route53Resolver.ResolverEndpointDirection
        "New-R53RResolverEndpoint/Direction"
        {
            $v = "INBOUND","OUTBOUND"
            break
        }

        # Amazon.Route53Resolver.RuleTypeOption
        "New-R53RResolverRule/RuleType"
        {
            $v = "FORWARD","RECURSIVE","SYSTEM"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$R53R_map = @{
    "Direction"=@("New-R53RResolverEndpoint")
    "RuleType"=@("New-R53RResolverRule")
}

_awsArgumentCompleterRegistration $R53R_Completers $R53R_map

$R53R_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.R53R.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$R53R_SelectMap = @{
    "Select"=@("Add-R53RResolverEndpointIpAddressAssociation",
               "Add-R53RResolverRuleAssociation",
               "New-R53RResolverEndpoint",
               "New-R53RResolverRule",
               "Remove-R53RResolverEndpoint",
               "Remove-R53RResolverRule",
               "Remove-R53RResolverEndpointIpAddressAssociation",
               "Remove-R53RResolverRuleAssociation",
               "Get-R53RResolverEndpoint",
               "Get-R53RResolverRule",
               "Get-R53RResolverRuleAssociation",
               "Get-R53RResolverRulePolicy",
               "Get-R53RResolverEndpointIpAddressList",
               "Get-R53RResolverEndpointList",
               "Get-R53RResolverRuleAssociationList",
               "Get-R53RResolverRuleList",
               "Get-R53RResourceTagList",
               "Set-R53RResolverRulePolicy",
               "Add-R53RResourceTag",
               "Remove-R53RResourceTag",
               "Update-R53RResolverEndpoint",
               "Update-R53RResolverRule")
}

_awsArgumentCompleterRegistration $R53R_SelectCompleters $R53R_SelectMap
# Argument completions for service Amazon Lex


$LEX_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Lex.DialogActionType
        "Write-LEXSession/DialogAction_Type"
        {
            $v = "Close","ConfirmIntent","Delegate","ElicitIntent","ElicitSlot"
            break
        }

        # Amazon.Lex.FulfillmentState
        "Write-LEXSession/DialogAction_FulfillmentState"
        {
            $v = "Failed","Fulfilled","ReadyForFulfillment"
            break
        }

        # Amazon.Lex.MessageFormatType
        "Write-LEXSession/DialogAction_MessageFormat"
        {
            $v = "Composite","CustomPayload","PlainText","SSML"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$LEX_map = @{
    "DialogAction_FulfillmentState"=@("Write-LEXSession")
    "DialogAction_MessageFormat"=@("Write-LEXSession")
    "DialogAction_Type"=@("Write-LEXSession")
}

_awsArgumentCompleterRegistration $LEX_Completers $LEX_map

$LEX_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.LEX.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$LEX_SelectMap = @{
    "Select"=@("Remove-LEXSession",
               "Get-LEXSession",
               "Send-LEXContent",
               "Send-LEXText",
               "Write-LEXSession")
}

_awsArgumentCompleterRegistration $LEX_SelectCompleters $LEX_SelectMap
# Argument completions for service Amazon SageMaker Runtime


$SMR_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SMR.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SMR_SelectMap = @{
    "Select"=@("Invoke-SMREndpoint")
}

_awsArgumentCompleterRegistration $SMR_SelectCompleters $SMR_SelectMap
# Argument completions for service Amazon Simple Storage Service (S3)


$S3_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.S3.BucketAccelerateStatus
        "Write-S3BucketAccelerateConfiguration/AccelerateConfiguration_Status"
        {
            $v = "Enabled","Suspended"
            break
        }

        # Amazon.S3.EncodingType
        {
            ($_ -eq "Get-S3Object/Encoding") -Or
            ($_ -eq "Get-S3Version/Encoding")
        }
        {
            $v = "Url"
            break
        }

        # Amazon.S3.ExpressionType
        "Select-S3ObjectContent/ExpressionType"
        {
            $v = "SQL"
            break
        }

        # Amazon.S3.GlacierJobTier
        {
            ($_ -eq "Restore-S3Object/RetrievalTier") -Or
            ($_ -eq "Restore-S3Object/Tier")
        }
        {
            $v = "Bulk","Expedited","Standard"
            break
        }

        # Amazon.S3.InventoryFormat
        "Write-S3BucketInventoryConfiguration/InventoryConfiguration_Destination_S3BucketDestination_InventoryFormat"
        {
            $v = "CSV","ORC","Parquet"
            break
        }

        # Amazon.S3.InventoryFrequency
        "Write-S3BucketInventoryConfiguration/InventoryConfiguration_Schedule_Frequency"
        {
            $v = "Daily","Weekly"
            break
        }

        # Amazon.S3.InventoryIncludedObjectVersions
        "Write-S3BucketInventoryConfiguration/InventoryConfiguration_IncludedObjectVersions"
        {
            $v = "All","Current"
            break
        }

        # Amazon.S3.ObjectLockEnabled
        "Write-S3ObjectLockConfiguration/ObjectLockConfiguration_ObjectLockEnabled"
        {
            $v = "Enabled"
            break
        }

        # Amazon.S3.ObjectLockLegalHoldStatus
        "Write-S3ObjectLegalHold/LegalHold_Status"
        {
            $v = "OFF","ON"
            break
        }

        # Amazon.S3.ObjectLockRetentionMode
        {
            ($_ -eq "Write-S3ObjectLockConfiguration/ObjectLockConfiguration_Rule_DefaultRetention_Mode") -Or
            ($_ -eq "Write-S3ObjectRetention/Retention_Mode")
        }
        {
            $v = "COMPLIANCE","GOVERNANCE"
            break
        }

        # Amazon.S3.RequestPayer
        {
            ($_ -eq "Get-S3Object/RequestPayer") -Or
            ($_ -eq "Get-S3ObjectLegalHold/RequestPayer") -Or
            ($_ -eq "Get-S3ObjectMetadata/RequestPayer") -Or
            ($_ -eq "Get-S3ObjectRetention/RequestPayer") -Or
            ($_ -eq "Restore-S3Object/RequestPayer") -Or
            ($_ -eq "Write-S3ObjectLegalHold/RequestPayer") -Or
            ($_ -eq "Write-S3ObjectLockConfiguration/RequestPayer") -Or
            ($_ -eq "Write-S3ObjectRetention/RequestPayer")
        }
        {
            $v = "requester"
            break
        }

        # Amazon.S3.RestoreRequestType
        "Restore-S3Object/RestoreRequestType"
        {
            $v = "SELECT"
            break
        }

        # Amazon.S3.S3CannedACL
        {
            ($_ -eq "Set-S3ACL/CannedACL") -Or
            ($_ -eq "Copy-S3Object/CannedACLName") -Or
            ($_ -eq "New-S3Bucket/CannedACLName") -Or
            ($_ -eq "Write-S3Object/CannedACLName") -Or
            ($_ -eq "Restore-S3Object/OutputLocation_S3_CannedACL")
        }
        {
            $v = "authenticated-read","aws-exec-read","bucket-owner-full-control","bucket-owner-read","log-delivery-write","NoACL","private","public-read","public-read-write"
            break
        }

        # Amazon.S3.S3StorageClass
        "Restore-S3Object/OutputLocation_S3_StorageClass"
        {
            $v = "DEEP_ARCHIVE","GLACIER","INTELLIGENT_TIERING","ONEZONE_IA","REDUCED_REDUNDANCY","STANDARD","STANDARD_IA"
            break
        }

        # Amazon.S3.ServerSideEncryptionCustomerMethod
        {
            ($_ -eq "Copy-S3Object/CopySourceServerSideEncryptionCustomerMethod") -Or
            ($_ -eq "Select-S3ObjectContent/ServerSideCustomerEncryptionMethod") -Or
            ($_ -eq "Copy-S3Object/ServerSideEncryptionCustomerMethod") -Or
            ($_ -eq "Get-S3ObjectMetadata/ServerSideEncryptionCustomerMethod") -Or
            ($_ -eq "Get-S3PreSignedURL/ServerSideEncryptionCustomerMethod") -Or
            ($_ -eq "Read-S3Object/ServerSideEncryptionCustomerMethod") -Or
            ($_ -eq "Write-S3Object/ServerSideEncryptionCustomerMethod")
        }
        {
            $v = "","AES256"
            break
        }

        # Amazon.S3.ServerSideEncryptionMethod
        {
            ($_ -eq "Restore-S3Object/OutputLocation_S3_Encryption_EncryptionType") -Or
            ($_ -eq "Copy-S3Object/ServerSideEncryption") -Or
            ($_ -eq "Write-S3Object/ServerSideEncryption") -Or
            ($_ -eq "Get-S3PreSignedURL/ServerSideEncryptionMethod")
        }
        {
            $v = "","AES256","aws:kms"
            break
        }

        # Amazon.S3.StorageClassAnalysisSchemaVersion
        "Write-S3BucketAnalyticsConfiguration/AnalyticsConfiguration_StorageClassAnalysis_DataExport_OutputSchemaVersion"
        {
            $v = "V_1"
            break
        }

        # Amazon.S3.VersionStatus
        "Write-S3BucketVersioning/VersioningConfig_Status"
        {
            $v = "Enabled","Off","Suspended"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$S3_map = @{
    "AccelerateConfiguration_Status"=@("Write-S3BucketAccelerateConfiguration")
    "AnalyticsConfiguration_StorageClassAnalysis_DataExport_OutputSchemaVersion"=@("Write-S3BucketAnalyticsConfiguration")
    "CannedACL"=@("Set-S3ACL")
    "CannedACLName"=@("Copy-S3Object","New-S3Bucket","Write-S3Object")
    "CopySourceServerSideEncryptionCustomerMethod"=@("Copy-S3Object")
    "Encoding"=@("Get-S3Object","Get-S3Version")
    "ExpressionType"=@("Select-S3ObjectContent")
    "InventoryConfiguration_Destination_S3BucketDestination_InventoryFormat"=@("Write-S3BucketInventoryConfiguration")
    "InventoryConfiguration_IncludedObjectVersions"=@("Write-S3BucketInventoryConfiguration")
    "InventoryConfiguration_Schedule_Frequency"=@("Write-S3BucketInventoryConfiguration")
    "LegalHold_Status"=@("Write-S3ObjectLegalHold")
    "ObjectLockConfiguration_ObjectLockEnabled"=@("Write-S3ObjectLockConfiguration")
    "ObjectLockConfiguration_Rule_DefaultRetention_Mode"=@("Write-S3ObjectLockConfiguration")
    "OutputLocation_S3_CannedACL"=@("Restore-S3Object")
    "OutputLocation_S3_Encryption_EncryptionType"=@("Restore-S3Object")
    "OutputLocation_S3_StorageClass"=@("Restore-S3Object")
    "RequestPayer"=@("Get-S3Object","Get-S3ObjectLegalHold","Get-S3ObjectMetadata","Get-S3ObjectRetention","Restore-S3Object","Write-S3ObjectLegalHold","Write-S3ObjectLockConfiguration","Write-S3ObjectRetention")
    "RestoreRequestType"=@("Restore-S3Object")
    "Retention_Mode"=@("Write-S3ObjectRetention")
    "RetrievalTier"=@("Restore-S3Object")
    "ServerSideCustomerEncryptionMethod"=@("Select-S3ObjectContent")
    "ServerSideEncryption"=@("Copy-S3Object","Write-S3Object")
    "ServerSideEncryptionCustomerMethod"=@("Copy-S3Object","Get-S3ObjectMetadata","Get-S3PreSignedURL","Read-S3Object","Write-S3Object")
    "ServerSideEncryptionMethod"=@("Get-S3PreSignedURL")
    "Tier"=@("Restore-S3Object")
    "VersioningConfig_Status"=@("Write-S3BucketVersioning")
}

_awsArgumentCompleterRegistration $S3_Completers $S3_map

$S3_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.S3.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$S3_SelectMap = @{
    "Select"=@("Remove-S3BucketAnalyticsConfiguration",
               "Remove-S3BucketEncryption",
               "Remove-S3BucketInventoryConfiguration",
               "Remove-S3BucketMetricsConfiguration",
               "Remove-S3BucketPolicy",
               "Remove-S3BucketReplication",
               "Remove-S3BucketTagging",
               "Remove-S3BucketWebsite",
               "Remove-S3CORSConfiguration",
               "Remove-S3LifecycleConfiguration",
               "Remove-S3ObjectTagSet",
               "Remove-S3PublicAccessBlock",
               "Get-S3ACL",
               "Get-S3BucketAccelerateConfiguration",
               "Get-S3BucketAnalyticsConfiguration",
               "Get-S3BucketEncryption",
               "Get-S3BucketInventoryConfiguration",
               "Get-S3BucketLocation",
               "Get-S3BucketLogging",
               "Get-S3BucketMetricsConfiguration",
               "Get-S3BucketNotification",
               "Get-S3BucketPolicy",
               "Get-S3BucketPolicyStatus",
               "Get-S3BucketReplication",
               "Get-S3BucketRequestPayment",
               "Get-S3BucketTagging",
               "Get-S3BucketVersioning",
               "Get-S3BucketWebsite",
               "Get-S3CORSConfiguration",
               "Get-S3LifecycleConfiguration",
               "Get-S3ObjectLegalHold",
               "Get-S3ObjectLockConfiguration",
               "Get-S3ObjectMetadata",
               "Get-S3ObjectRetention",
               "Get-S3ObjectTagSet",
               "Get-S3PublicAccessBlock",
               "Get-S3BucketAnalyticsConfigurationList",
               "Get-S3BucketInventoryConfigurationList",
               "Get-S3BucketMetricsConfigurationList",
               "Get-S3Bucket",
               "Get-S3Object",
               "Get-S3Version",
               "Set-S3ACL",
               "Write-S3BucketAccelerateConfiguration",
               "Write-S3BucketAnalyticsConfiguration",
               "Set-S3BucketEncryption",
               "Write-S3BucketInventoryConfiguration",
               "Write-S3BucketLogging",
               "Write-S3BucketMetricsConfiguration",
               "Write-S3BucketNotification",
               "Write-S3BucketPolicy",
               "Write-S3BucketReplication",
               "Write-S3BucketRequestPayment",
               "Write-S3BucketTagging",
               "Write-S3BucketVersioning",
               "Write-S3BucketWebsite",
               "Write-S3CORSConfiguration",
               "Write-S3LifecycleConfiguration",
               "Write-S3ObjectLegalHold",
               "Write-S3ObjectLockConfiguration",
               "Write-S3ObjectRetention",
               "Write-S3ObjectTagSet",
               "Add-S3PublicAccessBlock",
               "Restore-S3Object",
               "Select-S3ObjectContent",
               "Copy-S3Object",
               "Get-S3PreSignedURL",
               "New-S3Bucket",
               "Read-S3Object",
               "Remove-S3Bucket",
               "Remove-S3MultipartUpload",
               "Remove-S3Object",
               "Test-S3Bucket",
               "Write-S3Object")
}

_awsArgumentCompleterRegistration $S3_SelectCompleters $S3_SelectMap
# Argument completions for service Amazon S3 Control


$S3C_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.S3Control.JobManifestFormat
        "New-S3CJob/Manifest_Spec_Format"
        {
            $v = "S3BatchOperations_CSV_20180820","S3InventoryReport_CSV_20161130"
            break
        }

        # Amazon.S3Control.JobReportFormat
        "New-S3CJob/Report_Format"
        {
            $v = "Report_CSV_20180820"
            break
        }

        # Amazon.S3Control.JobReportScope
        "New-S3CJob/Report_ReportScope"
        {
            $v = "AllTasks","FailedTasksOnly"
            break
        }

        # Amazon.S3Control.RequestedJobStatus
        "Update-S3CJobStatus/RequestedJobStatus"
        {
            $v = "Cancelled","Ready"
            break
        }

        # Amazon.S3Control.S3CannedAccessControlList
        {
            ($_ -eq "New-S3CJob/Operation_S3PutObjectAcl_AccessControlPolicy_CannedAccessControlList") -Or
            ($_ -eq "New-S3CJob/Operation_S3PutObjectCopy_CannedAccessControlList")
        }
        {
            $v = "authenticated-read","aws-exec-read","bucket-owner-full-control","bucket-owner-read","private","public-read","public-read-write"
            break
        }

        # Amazon.S3Control.S3GlacierJobTier
        "New-S3CJob/Operation_S3InitiateRestoreObject_GlacierJobTier"
        {
            $v = "BULK","STANDARD"
            break
        }

        # Amazon.S3Control.S3MetadataDirective
        "New-S3CJob/Operation_S3PutObjectCopy_MetadataDirective"
        {
            $v = "COPY","REPLACE"
            break
        }

        # Amazon.S3Control.S3ObjectLockLegalHoldStatus
        "New-S3CJob/Operation_S3PutObjectCopy_ObjectLockLegalHoldStatus"
        {
            $v = "OFF","ON"
            break
        }

        # Amazon.S3Control.S3ObjectLockMode
        "New-S3CJob/Operation_S3PutObjectCopy_ObjectLockMode"
        {
            $v = "COMPLIANCE","GOVERNANCE"
            break
        }

        # Amazon.S3Control.S3SSEAlgorithm
        "New-S3CJob/Operation_S3PutObjectCopy_NewObjectMetadata_SSEAlgorithm"
        {
            $v = "AES256","KMS"
            break
        }

        # Amazon.S3Control.S3StorageClass
        "New-S3CJob/Operation_S3PutObjectCopy_StorageClass"
        {
            $v = "DEEP_ARCHIVE","GLACIER","INTELLIGENT_TIERING","ONEZONE_IA","STANDARD","STANDARD_IA"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$S3C_map = @{
    "Manifest_Spec_Format"=@("New-S3CJob")
    "Operation_S3InitiateRestoreObject_GlacierJobTier"=@("New-S3CJob")
    "Operation_S3PutObjectAcl_AccessControlPolicy_CannedAccessControlList"=@("New-S3CJob")
    "Operation_S3PutObjectCopy_CannedAccessControlList"=@("New-S3CJob")
    "Operation_S3PutObjectCopy_MetadataDirective"=@("New-S3CJob")
    "Operation_S3PutObjectCopy_NewObjectMetadata_SSEAlgorithm"=@("New-S3CJob")
    "Operation_S3PutObjectCopy_ObjectLockLegalHoldStatus"=@("New-S3CJob")
    "Operation_S3PutObjectCopy_ObjectLockMode"=@("New-S3CJob")
    "Operation_S3PutObjectCopy_StorageClass"=@("New-S3CJob")
    "Report_Format"=@("New-S3CJob")
    "Report_ReportScope"=@("New-S3CJob")
    "RequestedJobStatus"=@("Update-S3CJobStatus")
}

_awsArgumentCompleterRegistration $S3C_Completers $S3C_map

$S3C_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.S3C.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$S3C_SelectMap = @{
    "Select"=@("New-S3CAccessPoint",
               "New-S3CJob",
               "Remove-S3CAccessPoint",
               "Remove-S3CAccessPointPolicy",
               "Remove-S3CPublicAccessBlock",
               "Get-S3CJob",
               "Get-S3CAccessPoint",
               "Get-S3CAccessPointPolicy",
               "Get-S3CAccessPointPolicyStatus",
               "Get-S3CPublicAccessBlock",
               "Get-S3CAccessPointList",
               "Get-S3CJobList",
               "Write-S3CAccessPointPolicy",
               "Add-S3CPublicAccessBlock",
               "Update-S3CJobPriority",
               "Update-S3CJobStatus")
}

_awsArgumentCompleterRegistration $S3C_SelectCompleters $S3C_SelectMap
# Argument completions for service Amazon SageMaker Service


$SM_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.SageMaker.AlgorithmSortBy
        "Get-SMAlgorithmList/SortBy"
        {
            $v = "CreationTime","Name"
            break
        }

        # Amazon.SageMaker.AppInstanceType
        "New-SMApp/ResourceSpec_InstanceType"
        {
            $v = "ml.c5.12xlarge","ml.c5.18xlarge","ml.c5.24xlarge","ml.c5.2xlarge","ml.c5.4xlarge","ml.c5.9xlarge","ml.c5.large","ml.c5.xlarge","ml.g4dn.12xlarge","ml.g4dn.16xlarge","ml.g4dn.2xlarge","ml.g4dn.4xlarge","ml.g4dn.8xlarge","ml.g4dn.xlarge","ml.m5.12xlarge","ml.m5.16xlarge","ml.m5.24xlarge","ml.m5.2xlarge","ml.m5.4xlarge","ml.m5.8xlarge","ml.m5.large","ml.m5.xlarge","ml.p3.16xlarge","ml.p3.2xlarge","ml.p3.8xlarge","ml.t3.2xlarge","ml.t3.large","ml.t3.medium","ml.t3.micro","ml.t3.small","ml.t3.xlarge","system"
            break
        }

        # Amazon.SageMaker.AppSortKey
        "Get-SMAppList/SortBy"
        {
            $v = "CreationTime"
            break
        }

        # Amazon.SageMaker.AppType
        {
            ($_ -eq "Get-SMApp/AppType") -Or
            ($_ -eq "New-SMApp/AppType") -Or
            ($_ -eq "Remove-SMApp/AppType")
        }
        {
            $v = "JupyterServer","KernelGateway","TensorBoard"
            break
        }

        # Amazon.SageMaker.AssemblyType
        "New-SMTransformJob/TransformOutput_AssembleWith"
        {
            $v = "Line","None"
            break
        }

        # Amazon.SageMaker.AuthMode
        "New-SMDomain/AuthMode"
        {
            $v = "IAM","SSO"
            break
        }

        # Amazon.SageMaker.AutoMLJobStatus
        "Get-SMAutoMLJobList/StatusEquals"
        {
            $v = "Completed","Failed","InProgress","Stopped","Stopping"
            break
        }

        # Amazon.SageMaker.AutoMLMetricEnum
        "New-SMAutoMLJob/AutoMLJobObjective_MetricName"
        {
            $v = "Accuracy","F1","F1macro","MSE"
            break
        }

        # Amazon.SageMaker.AutoMLSortBy
        "Get-SMAutoMLJobList/SortBy"
        {
            $v = "CreationTime","Name","Status"
            break
        }

        # Amazon.SageMaker.AutoMLSortOrder
        {
            ($_ -eq "Get-SMAutoMLJobList/SortOrder") -Or
            ($_ -eq "Get-SMCandidatesForAutoMLJobList/SortOrder")
        }
        {
            $v = "Ascending","Descending"
            break
        }

        # Amazon.SageMaker.AwsManagedHumanLoopRequestSource
        "New-SMFlowDefinition/HumanLoopActivationConfig_HumanLoopRequestSource_AwsManagedHumanLoopRequestSource"
        {
            $v = "AWS/Rekognition/DetectModerationLabels/Image/V3","AWS/Textract/AnalyzeDocument/Forms/V1"
            break
        }

        # Amazon.SageMaker.BatchStrategy
        "New-SMTransformJob/BatchStrategy"
        {
            $v = "MultiRecord","SingleRecord"
            break
        }

        # Amazon.SageMaker.BooleanOperator
        "Search-SMResource/SearchExpression_Operator"
        {
            $v = "And","Or"
            break
        }

        # Amazon.SageMaker.CandidateSortBy
        "Get-SMCandidatesForAutoMLJobList/SortBy"
        {
            $v = "CreationTime","FinalObjectiveMetricValue","Status"
            break
        }

        # Amazon.SageMaker.CandidateStatus
        "Get-SMCandidatesForAutoMLJobList/StatusEquals"
        {
            $v = "Completed","Failed","InProgress","Stopped","Stopping"
            break
        }

        # Amazon.SageMaker.CodeRepositorySortBy
        "Get-SMCodeRepositoryList/SortBy"
        {
            $v = "CreationTime","LastModifiedTime","Name"
            break
        }

        # Amazon.SageMaker.CodeRepositorySortOrder
        "Get-SMCodeRepositoryList/SortOrder"
        {
            $v = "Ascending","Descending"
            break
        }

        # Amazon.SageMaker.CompilationJobStatus
        "Get-SMCompilationJobList/StatusEquals"
        {
            $v = "COMPLETED","FAILED","INPROGRESS","STARTING","STOPPED","STOPPING"
            break
        }

        # Amazon.SageMaker.CompressionType
        "New-SMTransformJob/TransformInput_CompressionType"
        {
            $v = "Gzip","None"
            break
        }

        # Amazon.SageMaker.DirectInternetAccess
        "New-SMNotebookInstance/DirectInternetAccess"
        {
            $v = "Disabled","Enabled"
            break
        }

        # Amazon.SageMaker.EndpointConfigSortKey
        "Get-SMConfigList/SortBy"
        {
            $v = "CreationTime","Name"
            break
        }

        # Amazon.SageMaker.EndpointSortKey
        "Get-SMEndpointList/SortBy"
        {
            $v = "CreationTime","Name","Status"
            break
        }

        # Amazon.SageMaker.EndpointStatus
        "Get-SMEndpointList/StatusEquals"
        {
            $v = "Creating","Deleting","Failed","InService","OutOfService","RollingBack","SystemUpdating","Updating"
            break
        }

        # Amazon.SageMaker.ExecutionStatus
        "Get-SMMonitoringExecutionList/StatusEquals"
        {
            $v = "Completed","CompletedWithViolations","Failed","InProgress","Pending","Stopped","Stopping"
            break
        }

        # Amazon.SageMaker.Framework
        "New-SMCompilationJob/InputConfig_Framework"
        {
            $v = "MXNET","ONNX","PYTORCH","TENSORFLOW","XGBOOST"
            break
        }

        # Amazon.SageMaker.HyperParameterTuningJobObjectiveType
        {
            ($_ -eq "New-SMHyperParameterTuningJob/HyperParameterTuningJobConfig_HyperParameterTuningJobObjective_Type") -Or
            ($_ -eq "New-SMHyperParameterTuningJob/TrainingJobDefinition_TuningObjective_Type")
        }
        {
            $v = "Maximize","Minimize"
            break
        }

        # Amazon.SageMaker.HyperParameterTuningJobSortByOptions
        "Get-SMHyperParameterTuningJobList/SortBy"
        {
            $v = "CreationTime","Name","Status"
            break
        }

        # Amazon.SageMaker.HyperParameterTuningJobStatus
        "Get-SMHyperParameterTuningJobList/StatusEquals"
        {
            $v = "Completed","Failed","InProgress","Stopped","Stopping"
            break
        }

        # Amazon.SageMaker.HyperParameterTuningJobStrategyType
        "New-SMHyperParameterTuningJob/HyperParameterTuningJobConfig_Strategy"
        {
            $v = "Bayesian","Random"
            break
        }

        # Amazon.SageMaker.HyperParameterTuningJobWarmStartType
        "New-SMHyperParameterTuningJob/WarmStartConfig_WarmStartType"
        {
            $v = "IdenticalDataAndAlgorithm","TransferLearning"
            break
        }

        # Amazon.SageMaker.InstanceType
        {
            ($_ -eq "New-SMNotebookInstance/InstanceType") -Or
            ($_ -eq "Update-SMNotebookInstance/InstanceType")
        }
        {
            $v = "ml.c4.2xlarge","ml.c4.4xlarge","ml.c4.8xlarge","ml.c4.xlarge","ml.c5.18xlarge","ml.c5.2xlarge","ml.c5.4xlarge","ml.c5.9xlarge","ml.c5.xlarge","ml.c5d.18xlarge","ml.c5d.2xlarge","ml.c5d.4xlarge","ml.c5d.9xlarge","ml.c5d.xlarge","ml.m4.10xlarge","ml.m4.16xlarge","ml.m4.2xlarge","ml.m4.4xlarge","ml.m4.xlarge","ml.m5.12xlarge","ml.m5.24xlarge","ml.m5.2xlarge","ml.m5.4xlarge","ml.m5.xlarge","ml.p2.16xlarge","ml.p2.8xlarge","ml.p2.xlarge","ml.p3.16xlarge","ml.p3.2xlarge","ml.p3.8xlarge","ml.t2.2xlarge","ml.t2.large","ml.t2.medium","ml.t2.xlarge","ml.t3.2xlarge","ml.t3.large","ml.t3.medium","ml.t3.xlarge"
            break
        }

        # Amazon.SageMaker.JoinSource
        "New-SMTransformJob/DataProcessing_JoinSource"
        {
            $v = "Input","None"
            break
        }

        # Amazon.SageMaker.LabelingJobStatus
        "Get-SMLabelingJobList/StatusEquals"
        {
            $v = "Completed","Failed","InProgress","Stopped","Stopping"
            break
        }

        # Amazon.SageMaker.ListCompilationJobsSortBy
        "Get-SMCompilationJobList/SortBy"
        {
            $v = "CreationTime","Name","Status"
            break
        }

        # Amazon.SageMaker.ListLabelingJobsForWorkteamSortByOptions
        "Get-SMLabelingJobListForWorkteam/SortBy"
        {
            $v = "CreationTime"
            break
        }

        # Amazon.SageMaker.ListWorkteamsSortByOptions
        "Get-SMWorkteamList/SortBy"
        {
            $v = "CreateDate","Name"
            break
        }

        # Amazon.SageMaker.ModelPackageSortBy
        "Get-SMModelPackageList/SortBy"
        {
            $v = "CreationTime","Name"
            break
        }

        # Amazon.SageMaker.ModelSortKey
        "Get-SMModelList/SortBy"
        {
            $v = "CreationTime","Name"
            break
        }

        # Amazon.SageMaker.MonitoringExecutionSortKey
        "Get-SMMonitoringExecutionList/SortBy"
        {
            $v = "CreationTime","ScheduledTime","Status"
            break
        }

        # Amazon.SageMaker.MonitoringScheduleSortKey
        "Get-SMMonitoringScheduleList/SortBy"
        {
            $v = "CreationTime","Name","Status"
            break
        }

        # Amazon.SageMaker.NotebookInstanceLifecycleConfigSortKey
        "Get-SMNotebookInstanceLifecycleConfigList/SortBy"
        {
            $v = "CreationTime","LastModifiedTime","Name"
            break
        }

        # Amazon.SageMaker.NotebookInstanceLifecycleConfigSortOrder
        "Get-SMNotebookInstanceLifecycleConfigList/SortOrder"
        {
            $v = "Ascending","Descending"
            break
        }

        # Amazon.SageMaker.NotebookInstanceSortKey
        "Get-SMNotebookInstanceList/SortBy"
        {
            $v = "CreationTime","Name","Status"
            break
        }

        # Amazon.SageMaker.NotebookInstanceSortOrder
        "Get-SMNotebookInstanceList/SortOrder"
        {
            $v = "Ascending","Descending"
            break
        }

        # Amazon.SageMaker.NotebookInstanceStatus
        "Get-SMNotebookInstanceList/StatusEquals"
        {
            $v = "Deleting","Failed","InService","Pending","Stopped","Stopping","Updating"
            break
        }

        # Amazon.SageMaker.OrderKey
        {
            ($_ -eq "Get-SMConfigList/SortOrder") -Or
            ($_ -eq "Get-SMEndpointList/SortOrder") -Or
            ($_ -eq "Get-SMModelList/SortOrder")
        }
        {
            $v = "Ascending","Descending"
            break
        }

        # Amazon.SageMaker.ProblemType
        "New-SMAutoMLJob/ProblemType"
        {
            $v = "BinaryClassification","MulticlassClassification","Regression"
            break
        }

        # Amazon.SageMaker.ProcessingInstanceType
        "New-SMProcessingJob/ProcessingResources_ClusterConfig_InstanceType"
        {
            $v = "ml.c4.2xlarge","ml.c4.4xlarge","ml.c4.8xlarge","ml.c4.xlarge","ml.c5.18xlarge","ml.c5.2xlarge","ml.c5.4xlarge","ml.c5.9xlarge","ml.c5.xlarge","ml.m4.10xlarge","ml.m4.16xlarge","ml.m4.2xlarge","ml.m4.4xlarge","ml.m4.xlarge","ml.m5.12xlarge","ml.m5.24xlarge","ml.m5.2xlarge","ml.m5.4xlarge","ml.m5.large","ml.m5.xlarge","ml.p2.16xlarge","ml.p2.8xlarge","ml.p2.xlarge","ml.p3.16xlarge","ml.p3.2xlarge","ml.p3.8xlarge","ml.r5.12xlarge","ml.r5.16xlarge","ml.r5.24xlarge","ml.r5.2xlarge","ml.r5.4xlarge","ml.r5.8xlarge","ml.r5.large","ml.r5.xlarge","ml.t3.2xlarge","ml.t3.large","ml.t3.medium","ml.t3.xlarge"
            break
        }

        # Amazon.SageMaker.ProcessingJobStatus
        "Get-SMProcessingJobList/StatusEquals"
        {
            $v = "Completed","Failed","InProgress","Stopped","Stopping"
            break
        }

        # Amazon.SageMaker.ResourceType
        {
            ($_ -eq "Get-SMSearchSuggestion/Resource") -Or
            ($_ -eq "Search-SMResource/Resource")
        }
        {
            $v = "Experiment","ExperimentTrial","ExperimentTrialComponent","TrainingJob"
            break
        }

        # Amazon.SageMaker.RetentionType
        "Remove-SMDomain/RetentionPolicy_HomeEfsFileSystem"
        {
            $v = "Delete","Retain"
            break
        }

        # Amazon.SageMaker.RootAccess
        {
            ($_ -eq "New-SMNotebookInstance/RootAccess") -Or
            ($_ -eq "Update-SMNotebookInstance/RootAccess")
        }
        {
            $v = "Disabled","Enabled"
            break
        }

        # Amazon.SageMaker.S3DataType
        "New-SMTransformJob/TransformInput_DataSource_S3DataSource_S3DataType"
        {
            $v = "AugmentedManifestFile","ManifestFile","S3Prefix"
            break
        }

        # Amazon.SageMaker.ScheduleStatus
        "Get-SMMonitoringScheduleList/StatusEquals"
        {
            $v = "Failed","Pending","Scheduled","Stopped"
            break
        }

        # Amazon.SageMaker.SearchSortOrder
        "Search-SMResource/SortOrder"
        {
            $v = "Ascending","Descending"
            break
        }

        # Amazon.SageMaker.SortBy
        {
            ($_ -eq "Get-SMLabelingJobList/SortBy") -Or
            ($_ -eq "Get-SMProcessingJobList/SortBy") -Or
            ($_ -eq "Get-SMTrainingJobList/SortBy") -Or
            ($_ -eq "Get-SMTransformJobList/SortBy")
        }
        {
            $v = "CreationTime","Name","Status"
            break
        }

        # Amazon.SageMaker.SortExperimentsBy
        "Get-SMExperimentList/SortBy"
        {
            $v = "CreationTime","Name"
            break
        }

        # Amazon.SageMaker.SortOrder
        {
            ($_ -eq "Get-SMAlgorithmList/SortOrder") -Or
            ($_ -eq "Get-SMAppList/SortOrder") -Or
            ($_ -eq "Get-SMCompilationJobList/SortOrder") -Or
            ($_ -eq "Get-SMExperimentList/SortOrder") -Or
            ($_ -eq "Get-SMFlowDefinitionList/SortOrder") -Or
            ($_ -eq "Get-SMHumanTaskUiList/SortOrder") -Or
            ($_ -eq "Get-SMHyperParameterTuningJobList/SortOrder") -Or
            ($_ -eq "Get-SMLabelingJobList/SortOrder") -Or
            ($_ -eq "Get-SMLabelingJobListForWorkteam/SortOrder") -Or
            ($_ -eq "Get-SMModelPackageList/SortOrder") -Or
            ($_ -eq "Get-SMMonitoringExecutionList/SortOrder") -Or
            ($_ -eq "Get-SMMonitoringScheduleList/SortOrder") -Or
            ($_ -eq "Get-SMProcessingJobList/SortOrder") -Or
            ($_ -eq "Get-SMTrainingJobList/SortOrder") -Or
            ($_ -eq "Get-SMTrainingJobsForHyperParameterTuningJobList/SortOrder") -Or
            ($_ -eq "Get-SMTransformJobList/SortOrder") -Or
            ($_ -eq "Get-SMTrialComponentList/SortOrder") -Or
            ($_ -eq "Get-SMTrialList/SortOrder") -Or
            ($_ -eq "Get-SMUserProfileList/SortOrder") -Or
            ($_ -eq "Get-SMWorkteamList/SortOrder")
        }
        {
            $v = "Ascending","Descending"
            break
        }

        # Amazon.SageMaker.SortTrialComponentsBy
        "Get-SMTrialComponentList/SortBy"
        {
            $v = "CreationTime","Name"
            break
        }

        # Amazon.SageMaker.SortTrialsBy
        "Get-SMTrialList/SortBy"
        {
            $v = "CreationTime","Name"
            break
        }

        # Amazon.SageMaker.SplitType
        "New-SMTransformJob/TransformInput_SplitType"
        {
            $v = "Line","None","RecordIO","TFRecord"
            break
        }

        # Amazon.SageMaker.TargetDevice
        "New-SMCompilationJob/OutputConfig_TargetDevice"
        {
            $v = "aisage","deeplens","jetson_nano","jetson_tx1","jetson_tx2","lambda","ml_c4","ml_c5","ml_inf1","ml_m4","ml_m5","ml_p2","ml_p3","qcs603","qcs605","rasp3b","rk3288","rk3399","sbe_c"
            break
        }

        # Amazon.SageMaker.TrainingInputMode
        "New-SMHyperParameterTuningJob/TrainingJobDefinition_AlgorithmSpecification_TrainingInputMode"
        {
            $v = "File","Pipe"
            break
        }

        # Amazon.SageMaker.TrainingJobEarlyStoppingType
        "New-SMHyperParameterTuningJob/HyperParameterTuningJobConfig_TrainingJobEarlyStoppingType"
        {
            $v = "Auto","Off"
            break
        }

        # Amazon.SageMaker.TrainingJobSortByOptions
        "Get-SMTrainingJobsForHyperParameterTuningJobList/SortBy"
        {
            $v = "CreationTime","FinalObjectiveMetricValue","Name","Status"
            break
        }

        # Amazon.SageMaker.TrainingJobStatus
        {
            ($_ -eq "Get-SMTrainingJobList/StatusEquals") -Or
            ($_ -eq "Get-SMTrainingJobsForHyperParameterTuningJobList/StatusEquals")
        }
        {
            $v = "Completed","Failed","InProgress","Stopped","Stopping"
            break
        }

        # Amazon.SageMaker.TransformInstanceType
        "New-SMTransformJob/TransformResources_InstanceType"
        {
            $v = "ml.c4.2xlarge","ml.c4.4xlarge","ml.c4.8xlarge","ml.c4.xlarge","ml.c5.18xlarge","ml.c5.2xlarge","ml.c5.4xlarge","ml.c5.9xlarge","ml.c5.xlarge","ml.m4.10xlarge","ml.m4.16xlarge","ml.m4.2xlarge","ml.m4.4xlarge","ml.m4.xlarge","ml.m5.12xlarge","ml.m5.24xlarge","ml.m5.2xlarge","ml.m5.4xlarge","ml.m5.large","ml.m5.xlarge","ml.p2.16xlarge","ml.p2.8xlarge","ml.p2.xlarge","ml.p3.16xlarge","ml.p3.2xlarge","ml.p3.8xlarge"
            break
        }

        # Amazon.SageMaker.TransformJobStatus
        "Get-SMTransformJobList/StatusEquals"
        {
            $v = "Completed","Failed","InProgress","Stopped","Stopping"
            break
        }

        # Amazon.SageMaker.TrialComponentPrimaryStatus
        {
            ($_ -eq "New-SMTrialComponent/Status_PrimaryStatus") -Or
            ($_ -eq "Update-SMTrialComponent/Status_PrimaryStatus")
        }
        {
            $v = "Completed","Failed","InProgress"
            break
        }

        # Amazon.SageMaker.UserProfileSortKey
        "Get-SMUserProfileList/SortBy"
        {
            $v = "CreationTime","LastModifiedTime"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SM_map = @{
    "AppType"=@("Get-SMApp","New-SMApp","Remove-SMApp")
    "AuthMode"=@("New-SMDomain")
    "AutoMLJobObjective_MetricName"=@("New-SMAutoMLJob")
    "BatchStrategy"=@("New-SMTransformJob")
    "DataProcessing_JoinSource"=@("New-SMTransformJob")
    "DirectInternetAccess"=@("New-SMNotebookInstance")
    "HumanLoopActivationConfig_HumanLoopRequestSource_AwsManagedHumanLoopRequestSource"=@("New-SMFlowDefinition")
    "HyperParameterTuningJobConfig_HyperParameterTuningJobObjective_Type"=@("New-SMHyperParameterTuningJob")
    "HyperParameterTuningJobConfig_Strategy"=@("New-SMHyperParameterTuningJob")
    "HyperParameterTuningJobConfig_TrainingJobEarlyStoppingType"=@("New-SMHyperParameterTuningJob")
    "InputConfig_Framework"=@("New-SMCompilationJob")
    "InstanceType"=@("New-SMNotebookInstance","Update-SMNotebookInstance")
    "OutputConfig_TargetDevice"=@("New-SMCompilationJob")
    "ProblemType"=@("New-SMAutoMLJob")
    "ProcessingResources_ClusterConfig_InstanceType"=@("New-SMProcessingJob")
    "Resource"=@("Get-SMSearchSuggestion","Search-SMResource")
    "ResourceSpec_InstanceType"=@("New-SMApp")
    "RetentionPolicy_HomeEfsFileSystem"=@("Remove-SMDomain")
    "RootAccess"=@("New-SMNotebookInstance","Update-SMNotebookInstance")
    "SearchExpression_Operator"=@("Search-SMResource")
    "SortBy"=@("Get-SMAlgorithmList","Get-SMAppList","Get-SMAutoMLJobList","Get-SMCandidatesForAutoMLJobList","Get-SMCodeRepositoryList","Get-SMCompilationJobList","Get-SMConfigList","Get-SMEndpointList","Get-SMExperimentList","Get-SMHyperParameterTuningJobList","Get-SMLabelingJobList","Get-SMLabelingJobListForWorkteam","Get-SMModelList","Get-SMModelPackageList","Get-SMMonitoringExecutionList","Get-SMMonitoringScheduleList","Get-SMNotebookInstanceLifecycleConfigList","Get-SMNotebookInstanceList","Get-SMProcessingJobList","Get-SMTrainingJobList","Get-SMTrainingJobsForHyperParameterTuningJobList","Get-SMTransformJobList","Get-SMTrialComponentList","Get-SMTrialList","Get-SMUserProfileList","Get-SMWorkteamList")
    "SortOrder"=@("Get-SMAlgorithmList","Get-SMAppList","Get-SMAutoMLJobList","Get-SMCandidatesForAutoMLJobList","Get-SMCodeRepositoryList","Get-SMCompilationJobList","Get-SMConfigList","Get-SMEndpointList","Get-SMExperimentList","Get-SMFlowDefinitionList","Get-SMHumanTaskUiList","Get-SMHyperParameterTuningJobList","Get-SMLabelingJobList","Get-SMLabelingJobListForWorkteam","Get-SMModelList","Get-SMModelPackageList","Get-SMMonitoringExecutionList","Get-SMMonitoringScheduleList","Get-SMNotebookInstanceLifecycleConfigList","Get-SMNotebookInstanceList","Get-SMProcessingJobList","Get-SMTrainingJobList","Get-SMTrainingJobsForHyperParameterTuningJobList","Get-SMTransformJobList","Get-SMTrialComponentList","Get-SMTrialList","Get-SMUserProfileList","Get-SMWorkteamList","Search-SMResource")
    "Status_PrimaryStatus"=@("New-SMTrialComponent","Update-SMTrialComponent")
    "StatusEquals"=@("Get-SMAutoMLJobList","Get-SMCandidatesForAutoMLJobList","Get-SMCompilationJobList","Get-SMEndpointList","Get-SMHyperParameterTuningJobList","Get-SMLabelingJobList","Get-SMMonitoringExecutionList","Get-SMMonitoringScheduleList","Get-SMNotebookInstanceList","Get-SMProcessingJobList","Get-SMTrainingJobList","Get-SMTrainingJobsForHyperParameterTuningJobList","Get-SMTransformJobList")
    "TrainingJobDefinition_AlgorithmSpecification_TrainingInputMode"=@("New-SMHyperParameterTuningJob")
    "TrainingJobDefinition_TuningObjective_Type"=@("New-SMHyperParameterTuningJob")
    "TransformInput_CompressionType"=@("New-SMTransformJob")
    "TransformInput_DataSource_S3DataSource_S3DataType"=@("New-SMTransformJob")
    "TransformInput_SplitType"=@("New-SMTransformJob")
    "TransformOutput_AssembleWith"=@("New-SMTransformJob")
    "TransformResources_InstanceType"=@("New-SMTransformJob")
    "WarmStartConfig_WarmStartType"=@("New-SMHyperParameterTuningJob")
}

_awsArgumentCompleterRegistration $SM_Completers $SM_map

$SM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SM_SelectMap = @{
    "Select"=@("Add-SMResourceTag",
               "Register-SMTrialComponent",
               "New-SMAlgorithm",
               "New-SMApp",
               "New-SMAutoMLJob",
               "New-SMCodeRepository",
               "New-SMCompilationJob",
               "New-SMDomain",
               "New-SMEndpoint",
               "New-SMEndpointConfig",
               "New-SMExperiment",
               "New-SMFlowDefinition",
               "New-SMHumanTaskUi",
               "New-SMHyperParameterTuningJob",
               "New-SMLabelingJob",
               "New-SMModel",
               "New-SMModelPackage",
               "New-SMMonitoringSchedule",
               "New-SMNotebookInstance",
               "New-SMNotebookInstanceLifecycleConfig",
               "New-SMPresignedDomainUrl",
               "New-SMPresignedNotebookInstanceUrl",
               "New-SMProcessingJob",
               "New-SMTrainingJob",
               "New-SMTransformJob",
               "New-SMTrial",
               "New-SMTrialComponent",
               "New-SMUserProfile",
               "New-SMWorkteam",
               "Remove-SMAlgorithm",
               "Remove-SMApp",
               "Remove-SMCodeRepository",
               "Remove-SMDomain",
               "Remove-SMEndpoint",
               "Remove-SMEndpointConfig",
               "Remove-SMExperiment",
               "Remove-SMFlowDefinition",
               "Remove-SMModel",
               "Remove-SMModelPackage",
               "Remove-SMMonitoringSchedule",
               "Remove-SMNotebookInstance",
               "Remove-SMNotebookInstanceLifecycleConfig",
               "Remove-SMResourceTag",
               "Remove-SMTrial",
               "Remove-SMTrialComponent",
               "Remove-SMUserProfile",
               "Remove-SMWorkteam",
               "Get-SMAlgorithm",
               "Get-SMApp",
               "Get-SMAutoMLJob",
               "Get-SMCodeRepository",
               "Get-SMCompilationJob",
               "Get-SMDomain",
               "Get-SMEndpoint",
               "Get-SMEndpointConfig",
               "Get-SMExperiment",
               "Get-SMFlowDefinition",
               "Get-SMHumanTaskUi",
               "Get-SMHyperParameterTuningJob",
               "Get-SMLabelingJob",
               "Get-SMModel",
               "Get-SMModelPackage",
               "Get-SMMonitoringSchedule",
               "Get-SMNotebookInstance",
               "Get-SMNotebookInstanceLifecycleConfig",
               "Get-SMProcessingJob",
               "Get-SMSubscribedWorkteam",
               "Get-SMTrainingJob",
               "Get-SMTransformJob",
               "Get-SMTrial",
               "Get-SMTrialComponent",
               "Get-SMUserProfile",
               "Get-SMWorkteam",
               "Unregister-SMTrialComponent",
               "Get-SMSearchSuggestion",
               "Get-SMAlgorithmList",
               "Get-SMAppList",
               "Get-SMAutoMLJobList",
               "Get-SMCandidatesForAutoMLJobList",
               "Get-SMCodeRepositoryList",
               "Get-SMCompilationJobList",
               "Get-SMDomainList",
               "Get-SMConfigList",
               "Get-SMEndpointList",
               "Get-SMExperimentList",
               "Get-SMFlowDefinitionList",
               "Get-SMHumanTaskUiList",
               "Get-SMHyperParameterTuningJobList",
               "Get-SMLabelingJobList",
               "Get-SMLabelingJobListForWorkteam",
               "Get-SMModelPackageList",
               "Get-SMModelList",
               "Get-SMMonitoringExecutionList",
               "Get-SMMonitoringScheduleList",
               "Get-SMNotebookInstanceLifecycleConfigList",
               "Get-SMNotebookInstanceList",
               "Get-SMProcessingJobList",
               "Get-SMSubscribedWorkteamList",
               "Get-SMResourceTagList",
               "Get-SMTrainingJobList",
               "Get-SMTrainingJobsForHyperParameterTuningJobList",
               "Get-SMTransformJobList",
               "Get-SMTrialComponentList",
               "Get-SMTrialList",
               "Get-SMUserProfileList",
               "Get-SMWorkteamList",
               "Invoke-SMUiTemplateRendering",
               "Search-SMResource",
               "Start-SMMonitoringSchedule",
               "Start-SMNotebookInstance",
               "Stop-SMAutoMLJob",
               "Stop-SMCompilationJob",
               "Stop-SMHyperParameterTuningJob",
               "Stop-SMLabelingJob",
               "Stop-SMMonitoringSchedule",
               "Stop-SMNotebookInstance",
               "Stop-SMProcessingJob",
               "Stop-SMTrainingJob",
               "Stop-SMTransformJob",
               "Update-SMCodeRepository",
               "Update-SMDomain",
               "Update-SMEndpoint",
               "Update-SMEndpointWeightAndCapacity",
               "Update-SMExperiment",
               "Update-SMMonitoringSchedule",
               "Update-SMNotebookInstance",
               "Update-SMNotebookInstanceLifecycleConfig",
               "Update-SMTrial",
               "Update-SMTrialComponent",
               "Update-SMUserProfile",
               "Update-SMWorkteam")
}

_awsArgumentCompleterRegistration $SM_SelectCompleters $SM_SelectMap
# Argument completions for service Amazon Augmented AI (A2I) Runtime


$A2IR_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.AugmentedAIRuntime.SortOrder
        "Get-A2IRHumanLoopList/SortOrder"
        {
            $v = "Ascending","Descending"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$A2IR_map = @{
    "SortOrder"=@("Get-A2IRHumanLoopList")
}

_awsArgumentCompleterRegistration $A2IR_Completers $A2IR_map

$A2IR_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.A2IR.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$A2IR_SelectMap = @{
    "Select"=@("Remove-A2IRHumanLoop",
               "Get-A2IRHumanLoop",
               "Get-A2IRHumanLoopList",
               "Start-A2IRHumanLoop",
               "Stop-A2IRHumanLoop")
}

_awsArgumentCompleterRegistration $A2IR_SelectCompleters $A2IR_SelectMap
# Argument completions for service AWS Savings Plans


$SP_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.SavingsPlans.SavingsPlanProductType
        "Get-SPSavingsPlansOffering/ProductType"
        {
            $v = "EC2","Fargate"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SP_map = @{
    "ProductType"=@("Get-SPSavingsPlansOffering")
}

_awsArgumentCompleterRegistration $SP_Completers $SP_map

$SP_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SP.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SP_SelectMap = @{
    "Select"=@("New-SPSavingsPlan",
               "Get-SPSavingsPlanRate",
               "Get-SPSavingsPlan",
               "Get-SPSavingsPlansOfferingRate",
               "Get-SPSavingsPlansOffering",
               "Get-SPResourceTag",
               "Add-SPResourceTag",
               "Remove-SPResourceTag")
}

_awsArgumentCompleterRegistration $SP_SelectCompleters $SP_SelectMap
# Argument completions for service AWS Secrets Manager


$SEC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SEC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SEC_SelectMap = @{
    "Select"=@("Stop-SECSecretRotation",
               "New-SECSecret",
               "Remove-SECResourcePolicy",
               "Remove-SECSecret",
               "Get-SECSecret",
               "Get-SECRandomPassword",
               "Get-SECResourcePolicy",
               "Get-SECSecretValue",
               "Get-SECSecretList",
               "Get-SECSecretVersionIdList",
               "Write-SECResourcePolicy",
               "Write-SECSecretValue",
               "Restore-SECSecret",
               "Invoke-SECSecretRotation",
               "Add-SECResourceTag",
               "Remove-SECResourceTag",
               "Update-SECSecret",
               "Update-SECSecretVersionStage")
}

_awsArgumentCompleterRegistration $SEC_SelectCompleters $SEC_SelectMap
# Argument completions for service AWS Security Hub


$SHUB_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.SecurityHub.RecordState
        "Update-SHUBFinding/RecordState"
        {
            $v = "ACTIVE","ARCHIVED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SHUB_map = @{
    "RecordState"=@("Update-SHUBFinding")
}

_awsArgumentCompleterRegistration $SHUB_Completers $SHUB_map

$SHUB_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SHUB.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SHUB_SelectMap = @{
    "Select"=@("Confirm-SHUBInvitation",
               "Disable-SHUBStandardsBatch",
               "Enable-SHUBStandardsBatch",
               "Import-SHUBFindingsBatch",
               "New-SHUBActionTarget",
               "New-SHUBInsight",
               "New-SHUBMember",
               "Deny-SHUBInvitation",
               "Remove-SHUBActionTarget",
               "Remove-SHUBInsight",
               "Remove-SHUBInvitation",
               "Remove-SHUBMember",
               "Get-SHUBActionTarget",
               "Get-SHUBHub",
               "Get-SHUBProduct",
               "Disable-SHUBImportFindingsForProduct",
               "Disable-SHUBSecurityHub",
               "Remove-SHUBMasterAccountAssociation",
               "Remove-SHUBMemberAssociation",
               "Enable-SHUBImportFindingsForProduct",
               "Enable-SHUBSecurityHub",
               "Get-SHUBEnabledStandard",
               "Get-SHUBFinding",
               "Get-SHUBInsightResult",
               "Get-SHUBInsight",
               "Get-SHUBInvitationsCount",
               "Get-SHUBMasterAccount",
               "Get-SHUBMember",
               "Send-SHUBMemberInvitation",
               "Get-SHUBEnabledProductsForImportList",
               "Get-SHUBInvitationList",
               "Get-SHUBMemberList",
               "Get-SHUBResourceTag",
               "Add-SHUBResourceTag",
               "Remove-SHUBResourceTag",
               "Update-SHUBActionTarget",
               "Update-SHUBFinding",
               "Update-SHUBInsight")
}

_awsArgumentCompleterRegistration $SHUB_SelectCompleters $SHUB_SelectMap
# Argument completions for service AWS Serverless Application Repository


$SAR_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SAR.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SAR_SelectMap = @{
    "Select"=@("New-SARApplication",
               "New-SARApplicationVersion",
               "New-SARCloudFormationChangeSet",
               "New-SARCloudFormationTemplate",
               "Remove-SARApplication",
               "Get-SARApplication",
               "Get-SARApplicationPolicy",
               "Get-SARCloudFormationTemplate",
               "Get-SARApplicationDependencyList",
               "Get-SARApplicationList",
               "Get-SARApplicationVersionList",
               "Set-SARApplicationPolicy",
               "Update-SARApplication")
}

_awsArgumentCompleterRegistration $SAR_SelectCompleters $SAR_SelectMap
# Argument completions for service AWS Service Catalog


$SC_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ServiceCatalog.AccessLevelFilterKey
        {
            ($_ -eq "Find-SCProvisionedProduct/AccessLevelFilter_Key") -Or
            ($_ -eq "Get-SCProvisionedProduct/AccessLevelFilter_Key") -Or
            ($_ -eq "Get-SCProvisionedProductPlanList/AccessLevelFilter_Key") -Or
            ($_ -eq "Get-SCRecordHistory/AccessLevelFilter_Key")
        }
        {
            $v = "Account","Role","User"
            break
        }

        # Amazon.ServiceCatalog.OrganizationNodeType
        {
            ($_ -eq "New-SCPortfolioShare/OrganizationNode_Type") -Or
            ($_ -eq "Remove-SCPortfolioShare/OrganizationNode_Type") -Or
            ($_ -eq "Get-SCOrganizationPortfolioAccessList/OrganizationNodeType")
        }
        {
            $v = "ACCOUNT","ORGANIZATION","ORGANIZATIONAL_UNIT"
            break
        }

        # Amazon.ServiceCatalog.PortfolioShareType
        {
            ($_ -eq "Deny-SCPortfolioShare/PortfolioShareType") -Or
            ($_ -eq "Get-SCAcceptedPortfolioShareList/PortfolioShareType") -Or
            ($_ -eq "Receive-SCPortfolioShare/PortfolioShareType")
        }
        {
            $v = "AWS_ORGANIZATIONS","AWS_SERVICECATALOG","IMPORTED"
            break
        }

        # Amazon.ServiceCatalog.PrincipalType
        "Register-SCPrincipalWithPortfolio/PrincipalType"
        {
            $v = "IAM"
            break
        }

        # Amazon.ServiceCatalog.ProductSource
        "Find-SCProductsAsAdmin/ProductSource"
        {
            $v = "ACCOUNT"
            break
        }

        # Amazon.ServiceCatalog.ProductType
        "New-SCProduct/ProductType"
        {
            $v = "CLOUD_FORMATION_TEMPLATE","MARKETPLACE"
            break
        }

        # Amazon.ServiceCatalog.ProductViewSortBy
        {
            ($_ -eq "Find-SCProduct/SortBy") -Or
            ($_ -eq "Find-SCProductsAsAdmin/SortBy")
        }
        {
            $v = "CreationDate","Title","VersionCount"
            break
        }

        # Amazon.ServiceCatalog.ProvisionedProductPlanType
        "New-SCProvisionedProductPlan/PlanType"
        {
            $v = "CLOUDFORMATION"
            break
        }

        # Amazon.ServiceCatalog.ProvisioningArtifactGuidance
        "Update-SCProvisioningArtifact/Guidance"
        {
            $v = "DEFAULT","DEPRECATED"
            break
        }

        # Amazon.ServiceCatalog.ProvisioningArtifactType
        {
            ($_ -eq "New-SCProvisioningArtifact/Parameters_Type") -Or
            ($_ -eq "New-SCProduct/ProvisioningArtifactParameters_Type")
        }
        {
            $v = "CLOUD_FORMATION_TEMPLATE","MARKETPLACE_AMI","MARKETPLACE_CAR"
            break
        }

        # Amazon.ServiceCatalog.ServiceActionDefinitionType
        "New-SCServiceAction/DefinitionType"
        {
            $v = "SSM_AUTOMATION"
            break
        }

        # Amazon.ServiceCatalog.SortOrder
        {
            ($_ -eq "Find-SCProduct/SortOrder") -Or
            ($_ -eq "Find-SCProductsAsAdmin/SortOrder") -Or
            ($_ -eq "Find-SCProvisionedProduct/SortOrder")
        }
        {
            $v = "ASCENDING","DESCENDING"
            break
        }

        # Amazon.ServiceCatalog.StackSetOperationType
        "Update-SCProvisionedProduct/ProvisioningPreferences_StackSetOperationType"
        {
            $v = "CREATE","DELETE","UPDATE"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SC_map = @{
    "AccessLevelFilter_Key"=@("Find-SCProvisionedProduct","Get-SCProvisionedProduct","Get-SCProvisionedProductPlanList","Get-SCRecordHistory")
    "DefinitionType"=@("New-SCServiceAction")
    "Guidance"=@("Update-SCProvisioningArtifact")
    "OrganizationNode_Type"=@("New-SCPortfolioShare","Remove-SCPortfolioShare")
    "OrganizationNodeType"=@("Get-SCOrganizationPortfolioAccessList")
    "Parameters_Type"=@("New-SCProvisioningArtifact")
    "PlanType"=@("New-SCProvisionedProductPlan")
    "PortfolioShareType"=@("Deny-SCPortfolioShare","Get-SCAcceptedPortfolioShareList","Receive-SCPortfolioShare")
    "PrincipalType"=@("Register-SCPrincipalWithPortfolio")
    "ProductSource"=@("Find-SCProductsAsAdmin")
    "ProductType"=@("New-SCProduct")
    "ProvisioningArtifactParameters_Type"=@("New-SCProduct")
    "ProvisioningPreferences_StackSetOperationType"=@("Update-SCProvisionedProduct")
    "SortBy"=@("Find-SCProduct","Find-SCProductsAsAdmin")
    "SortOrder"=@("Find-SCProduct","Find-SCProductsAsAdmin","Find-SCProvisionedProduct")
}

_awsArgumentCompleterRegistration $SC_Completers $SC_map

$SC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SC_SelectMap = @{
    "Select"=@("Receive-SCPortfolioShare",
               "Register-SCBudgetWithResource",
               "Register-SCPrincipalWithPortfolio",
               "Register-SCProductWithPortfolio",
               "Add-SCServiceActionAssociationWithProvisioningArtifact",
               "Add-SCTagOptionToResource",
               "Add-SCServiceActionAssociationWithProvisioningArtifactBatch",
               "Remove-SCServiceActionAssociationFromProvisioningArtifactBatch",
               "Copy-SCProduct",
               "New-SCConstraint",
               "New-SCPortfolio",
               "New-SCPortfolioShare",
               "New-SCProduct",
               "New-SCProvisionedProductPlan",
               "New-SCProvisioningArtifact",
               "New-SCServiceAction",
               "New-SCTagOption",
               "Remove-SCConstraint",
               "Remove-SCPortfolio",
               "Remove-SCPortfolioShare",
               "Remove-SCProduct",
               "Remove-SCProvisionedProductPlan",
               "Remove-SCProvisioningArtifact",
               "Remove-SCServiceAction",
               "Remove-SCTagOption",
               "Get-SCConstraint",
               "Get-SCCopyProductStatus",
               "Get-SCPortfolio",
               "Get-SCPortfolioShareStatus",
               "Get-SCProduct",
               "Get-SCProductAsAdmin",
               "Get-SCProductView",
               "Get-SCProvisionedProductDetail",
               "Get-SCProvisionedProductPlan",
               "Get-SCProvisioningArtifact",
               "Get-SCProvisioningParameter",
               "Get-SCRecord",
               "Get-SCServiceAction",
               "Get-SCServiceActionExecutionParameter",
               "Get-SCTagOption",
               "Disable-SCAWSOrganizationsAccess",
               "Unregister-SCBudgetFromResource",
               "Unregister-SCPrincipalFromPortfolio",
               "Unregister-SCProductFromPortfolio",
               "Remove-SCServiceActionAssociationFromProvisioningArtifact",
               "Remove-SCTagOptionFromResource",
               "Enable-SCAWSOrganizationsAccess",
               "Start-SCProvisionedProductPlanExecution",
               "Start-SCProvisionedProductServiceActionExecution",
               "Get-SCAWSOrganizationsAccessStatus",
               "Get-SCAcceptedPortfolioShareList",
               "Get-SCBudgetsForResource",
               "Get-SCConstrainsForPortfolioList",
               "Get-SCLaunchPath",
               "Get-SCOrganizationPortfolioAccessList",
               "Get-SCPortfolioAccessList",
               "Get-SCPortfolioList",
               "Get-SCProductPortfolioList",
               "Get-SCPrincipalsForPortfolio",
               "Get-SCProvisionedProductPlanList",
               "Get-SCProvisioningArtifactList",
               "Get-SCProvisioningArtifactsForServiceActionList",
               "Get-SCRecordHistory",
               "Get-SCResourcesForTagOption",
               "Get-SCServiceActionList",
               "Get-SCServiceActionsForProvisioningArtifactList",
               "Get-SCStackInstancesForProvisionedProduct",
               "Get-SCTagOptionList",
               "New-SCProvisionedProduct",
               "Deny-SCPortfolioShare",
               "Get-SCProvisionedProduct",
               "Find-SCProduct",
               "Find-SCProductsAsAdmin",
               "Find-SCProvisionedProduct",
               "Remove-SCProvisionedProduct",
               "Update-SCConstraint",
               "Update-SCPortfolio",
               "Update-SCProduct",
               "Update-SCProvisionedProduct",
               "Update-SCProvisionedProductProperty",
               "Update-SCProvisioningArtifact",
               "Update-SCServiceAction",
               "Update-SCTagOption")
}

_awsArgumentCompleterRegistration $SC_SelectCompleters $SC_SelectMap
# Argument completions for service AWS Cloud Map


$SD_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ServiceDiscovery.CustomHealthStatus
        "Update-SDInstanceCustomHealthStatus/Status"
        {
            $v = "HEALTHY","UNHEALTHY"
            break
        }

        # Amazon.ServiceDiscovery.HealthCheckType
        "New-SDService/HealthCheckConfig_Type"
        {
            $v = "HTTP","HTTPS","TCP"
            break
        }

        # Amazon.ServiceDiscovery.HealthStatusFilter
        "Find-SDInstance/HealthStatus"
        {
            $v = "ALL","HEALTHY","UNHEALTHY"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SD_map = @{
    "HealthCheckConfig_Type"=@("New-SDService")
    "HealthStatus"=@("Find-SDInstance")
    "Status"=@("Update-SDInstanceCustomHealthStatus")
}

_awsArgumentCompleterRegistration $SD_Completers $SD_map

$SD_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SD.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SD_SelectMap = @{
    "Select"=@("New-SDHttpNamespace",
               "New-SDPrivateDnsNamespace",
               "New-SDPublicDnsNamespace",
               "New-SDService",
               "Remove-SDNamespace",
               "Remove-SDService",
               "Remove-SDInstanceRegistration",
               "Find-SDInstance",
               "Get-SDInstance",
               "Get-SDInstancesHealthStatus",
               "Get-SDNamespace",
               "Get-SDOperation",
               "Get-SDService",
               "Get-SDInstanceList",
               "Get-SDNamespaceList",
               "Get-SDOperationList",
               "Get-SDServiceList",
               "New-SDInstanceRegistration",
               "Update-SDInstanceCustomHealthStatus",
               "Update-SDService")
}

_awsArgumentCompleterRegistration $SD_SelectCompleters $SD_SelectMap
# Argument completions for service AWS Service Quotas


$SQ_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ServiceQuotas.RequestStatus
        {
            ($_ -eq "Get-SQRequestedServiceQuotaChangeHistoryByQuotaList/Status") -Or
            ($_ -eq "Get-SQRequestedServiceQuotaChangeHistoryList/Status")
        }
        {
            $v = "APPROVED","CASE_CLOSED","CASE_OPENED","DENIED","PENDING"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SQ_map = @{
    "Status"=@("Get-SQRequestedServiceQuotaChangeHistoryByQuotaList","Get-SQRequestedServiceQuotaChangeHistoryList")
}

_awsArgumentCompleterRegistration $SQ_Completers $SQ_map

$SQ_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SQ.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SQ_SelectMap = @{
    "Select"=@("Register-SQServiceQuotaTemplate",
               "Remove-SQServiceQuotaIncreaseRequestFromTemplate",
               "Unregister-SQServiceQuotaTemplate",
               "Get-SQAssociationForServiceQuotaTemplate",
               "Get-SQAWSDefaultServiceQuota",
               "Get-SQRequestedServiceQuotaChange",
               "Get-SQServiceQuota",
               "Get-SQServiceQuotaIncreaseRequestFromTemplate",
               "Get-SQAWSDefaultServiceQuotaList",
               "Get-SQRequestedServiceQuotaChangeHistoryList",
               "Get-SQRequestedServiceQuotaChangeHistoryByQuotaList",
               "Get-SQServiceQuotaIncreaseRequestsInTemplateList",
               "Get-SQServiceQuotaList",
               "Get-SQServiceList",
               "Write-SQServiceQuotaIncreaseRequestIntoTemplate",
               "Request-SQServiceQuotaIncrease")
}

_awsArgumentCompleterRegistration $SQ_SelectCompleters $SQ_SelectMap
# Argument completions for service Amazon Simple Email Service V2 (SES V2)


$SES2_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.SimpleEmailV2.BehaviorOnMxFailure
        "Write-SES2EmailIdentityMailFromAttribute/BehaviorOnMxFailure"
        {
            $v = "REJECT_MESSAGE","USE_DEFAULT_VALUE"
            break
        }

        # Amazon.SimpleEmailV2.SuppressionListReason
        "Write-SES2SuppressedDestination/Reason"
        {
            $v = "BOUNCE","COMPLAINT"
            break
        }

        # Amazon.SimpleEmailV2.TlsPolicy
        {
            ($_ -eq "New-SES2ConfigurationSet/DeliveryOptions_TlsPolicy") -Or
            ($_ -eq "Write-SES2ConfigurationSetDeliveryOption/TlsPolicy")
        }
        {
            $v = "OPTIONAL","REQUIRE"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SES2_map = @{
    "BehaviorOnMxFailure"=@("Write-SES2EmailIdentityMailFromAttribute")
    "DeliveryOptions_TlsPolicy"=@("New-SES2ConfigurationSet")
    "Reason"=@("Write-SES2SuppressedDestination")
    "TlsPolicy"=@("Write-SES2ConfigurationSetDeliveryOption")
}

_awsArgumentCompleterRegistration $SES2_Completers $SES2_map

$SES2_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SES2.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SES2_SelectMap = @{
    "Select"=@("New-SES2ConfigurationSet",
               "New-SES2ConfigurationSetEventDestination",
               "New-SES2DedicatedIpPool",
               "New-SES2DeliverabilityTestReport",
               "New-SES2EmailIdentity",
               "Remove-SES2ConfigurationSet",
               "Remove-SES2ConfigurationSetEventDestination",
               "Remove-SES2DedicatedIpPool",
               "Remove-SES2EmailIdentity",
               "Remove-SES2SuppressedDestination",
               "Get-SES2Account",
               "Get-SES2BlacklistReport",
               "Get-SES2ConfigurationSet",
               "Get-SES2ConfigurationSetEventDestination",
               "Get-SES2DedicatedIp",
               "Get-SES2DedicatedIpList",
               "Get-SES2DeliverabilityDashboardOption",
               "Get-SES2DeliverabilityTestReport",
               "Get-SES2DomainDeliverabilityCampaign",
               "Get-SES2DomainStatisticsReport",
               "Get-SES2EmailIdentity",
               "Get-SES2SuppressedDestination",
               "Get-SES2ConfigurationSetList",
               "Get-SES2DedicatedIpPoolList",
               "Get-SES2DeliverabilityTestReportList",
               "Get-SES2DomainDeliverabilityCampaignList",
               "Get-SES2EmailIdentityList",
               "Get-SES2SuppressedDestinationList",
               "Get-SES2ResourceTag",
               "Write-SES2AccountDedicatedIpWarmupAttribute",
               "Write-SES2AccountSendingAttribute",
               "Write-SES2AccountSuppressionAttribute",
               "Write-SES2ConfigurationSetDeliveryOption",
               "Write-SES2ConfigurationSetReputationOption",
               "Write-SES2ConfigurationSetSendingOption",
               "Write-SES2ConfigurationSetSuppressionOption",
               "Write-SES2ConfigurationSetTrackingOption",
               "Write-SES2DedicatedIpInPool",
               "Write-SES2DedicatedIpWarmupAttribute",
               "Write-SES2DeliverabilityDashboardOption",
               "Write-SES2EmailIdentityDkimAttribute",
               "Write-SES2EmailIdentityFeedbackAttribute",
               "Write-SES2EmailIdentityMailFromAttribute",
               "Write-SES2SuppressedDestination",
               "Send-SES2Email",
               "Add-SES2ResourceTag",
               "Remove-SES2ResourceTag",
               "Update-SES2ConfigurationSetEventDestination")
}

_awsArgumentCompleterRegistration $SES2_SelectCompleters $SES2_SelectMap
# Argument completions for service AWS Shield


$SHLD_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Shield.AutoRenew
        "Update-SHLDSubscription/AutoRenew"
        {
            $v = "DISABLED","ENABLED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SHLD_map = @{
    "AutoRenew"=@("Update-SHLDSubscription")
}

_awsArgumentCompleterRegistration $SHLD_Completers $SHLD_map

$SHLD_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SHLD.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SHLD_SelectMap = @{
    "Select"=@("Grant-SHLDDRTLogBucketAssociation",
               "Grant-SHLDDRTRoleAssociation",
               "New-SHLDProtection",
               "New-SHLDSubscription",
               "Remove-SHLDProtection",
               "Remove-SHLDSubscription",
               "Get-SHLDAttack",
               "Get-SHLDDRTAccess",
               "Get-SHLDEmergencyContactSetting",
               "Get-SHLDProtection",
               "Get-SHLDSubscription",
               "Revoke-SHLDDRTLogBucketAssociation",
               "Revoke-SHLDDRTRoleAssociation",
               "Get-SHLDSubscriptionState",
               "Get-SHLDAttackList",
               "Get-SHLDProtectionList",
               "Update-SHLDEmergencyContactSetting",
               "Update-SHLDSubscription")
}

_awsArgumentCompleterRegistration $SHLD_SelectCompleters $SHLD_SelectMap
# Argument completions for service AWS Server Migration Service


$SMS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.ServerMigrationService.LicenseType
        {
            ($_ -eq "New-SMSReplicationJob/LicenseType") -Or
            ($_ -eq "Update-SMSReplicationJob/LicenseType")
        }
        {
            $v = "AWS","BYOL"
            break
        }

        # Amazon.ServerMigrationService.OutputFormat
        {
            ($_ -eq "New-SMSChangeSet/ChangesetFormat") -Or
            ($_ -eq "New-SMSTemplate/TemplateFormat")
        }
        {
            $v = "JSON","YAML"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SMS_map = @{
    "ChangesetFormat"=@("New-SMSChangeSet")
    "LicenseType"=@("New-SMSReplicationJob","Update-SMSReplicationJob")
    "TemplateFormat"=@("New-SMSTemplate")
}

_awsArgumentCompleterRegistration $SMS_Completers $SMS_map

$SMS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SMS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SMS_SelectMap = @{
    "Select"=@("New-SMSApp",
               "New-SMSReplicationJob",
               "Remove-SMSApp",
               "Remove-SMSAppLaunchConfiguration",
               "Remove-SMSAppReplicationConfiguration",
               "Remove-SMSReplicationJob",
               "Remove-SMSServerCatalog",
               "Unregister-SMSConnector",
               "New-SMSChangeSet",
               "New-SMSTemplate",
               "Get-SMSApp",
               "Get-SMSAppLaunchConfiguration",
               "Get-SMSAppReplicationConfiguration",
               "Get-SMSConnector",
               "Get-SMSReplicationJob",
               "Get-SMSReplicationRun",
               "Get-SMSServer",
               "Import-SMSServerCatalog",
               "Start-SMSApp",
               "Get-SMSAppList",
               "Write-SMSAppLaunchConfiguration",
               "Write-SMSAppReplicationConfiguration",
               "Start-SMSAppReplication",
               "Start-SMSOnDemandReplicationRun",
               "Stop-SMSAppReplication",
               "Stop-SMSApp",
               "Update-SMSApp",
               "Update-SMSReplicationJob")
}

_awsArgumentCompleterRegistration $SMS_SelectCompleters $SMS_SelectMap
# Argument completions for service AWS Import/Export Snowball


$SNOW_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Snowball.JobType
        {
            ($_ -eq "New-SNOWCluster/JobType") -Or
            ($_ -eq "New-SNOWJob/JobType")
        }
        {
            $v = "EXPORT","IMPORT","LOCAL_USE"
            break
        }

        # Amazon.Snowball.ShippingOption
        {
            ($_ -eq "New-SNOWCluster/ShippingOption") -Or
            ($_ -eq "New-SNOWJob/ShippingOption") -Or
            ($_ -eq "Update-SNOWCluster/ShippingOption") -Or
            ($_ -eq "Update-SNOWJob/ShippingOption")
        }
        {
            $v = "EXPRESS","NEXT_DAY","SECOND_DAY","STANDARD"
            break
        }

        # Amazon.Snowball.SnowballCapacity
        {
            ($_ -eq "New-SNOWJob/SnowballCapacityPreference") -Or
            ($_ -eq "Update-SNOWJob/SnowballCapacityPreference")
        }
        {
            $v = "NoPreference","T100","T42","T50","T80"
            break
        }

        # Amazon.Snowball.SnowballType
        {
            ($_ -eq "New-SNOWCluster/SnowballType") -Or
            ($_ -eq "New-SNOWJob/SnowballType")
        }
        {
            $v = "EDGE","EDGE_C","EDGE_CG","STANDARD"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SNOW_map = @{
    "JobType"=@("New-SNOWCluster","New-SNOWJob")
    "ShippingOption"=@("New-SNOWCluster","New-SNOWJob","Update-SNOWCluster","Update-SNOWJob")
    "SnowballCapacityPreference"=@("New-SNOWJob","Update-SNOWJob")
    "SnowballType"=@("New-SNOWCluster","New-SNOWJob")
}

_awsArgumentCompleterRegistration $SNOW_Completers $SNOW_map

$SNOW_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SNOW.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SNOW_SelectMap = @{
    "Select"=@("Stop-SNOWCluster",
               "Stop-SNOWJob",
               "New-SNOWAddress",
               "New-SNOWCluster",
               "New-SNOWJob",
               "Get-SNOWAddress",
               "Get-SNOWAddressList",
               "Get-SNOWCluster",
               "Get-SNOWJob",
               "Get-SNOWJobManifest",
               "Get-SNOWJobUnlockCode",
               "Get-SNOWSnowballUsage",
               "Get-SNOWSoftwareUpdate",
               "Get-SNOWClusterJobList",
               "Get-SNOWClusterList",
               "Get-SNOWCompatibleImageList",
               "Get-SNOWJobList",
               "Update-SNOWCluster",
               "Update-SNOWJob")
}

_awsArgumentCompleterRegistration $SNOW_SelectCompleters $SNOW_SelectMap
# Argument completions for service Amazon Simple Notification Service (SNS)


$SNS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SNS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SNS_SelectMap = @{
    "Select"=@("Add-SNSPermission",
               "Test-SNSIfPhoneNumberIsOptedOut",
               "Confirm-SNSSubscription",
               "New-SNSPlatformApplication",
               "New-SNSPlatformEndpoint",
               "New-SNSTopic",
               "Remove-SNSEndpoint",
               "Remove-SNSPlatformApplication",
               "Remove-SNSTopic",
               "Get-SNSEndpointAttribute",
               "Get-SNSPlatformApplicationAttribute",
               "Get-SNSSMSAttribute",
               "Get-SNSSubscriptionAttribute",
               "Get-SNSTopicAttribute",
               "Get-SNSEndpointsByPlatformApplication",
               "Get-SNSPhoneNumbersOptedOut",
               "Get-SNSPlatformApplicationList",
               "Get-SNSSubscription",
               "Get-SNSSubscriptionByTopic",
               "Get-SNSResourceTag",
               "Get-SNSTopic",
               "Enable-SNSPhoneNumber",
               "Publish-SNSMessage",
               "Remove-SNSPermission",
               "Set-SNSEndpointAttribute",
               "Set-SNSPlatformApplicationAttribute",
               "Set-SNSSMSAttribute",
               "Set-SNSSubscriptionAttribute",
               "Set-SNSTopicAttribute",
               "Connect-SNSNotification",
               "Add-SNSResourceTag",
               "Disconnect-SNSNotification",
               "Remove-SNSResourceTag")
}

_awsArgumentCompleterRegistration $SNS_SelectCompleters $SNS_SelectMap
# Argument completions for service Amazon Simple Queue Service (SQS)


$SQS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SQS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SQS_SelectMap = @{
    "Select"=@("Add-SQSPermission",
               "Edit-SQSMessageVisibility",
               "Edit-SQSMessageVisibilityBatch",
               "New-SQSQueue",
               "Remove-SQSMessage",
               "Remove-SQSMessageBatch",
               "Remove-SQSQueue",
               "Get-SQSQueueAttribute",
               "Get-SQSQueueUrl",
               "Get-SQSDeadLetterSourceQueue",
               "Get-SQSQueue",
               "Get-SQSResourceTag",
               "Clear-SQSQueue",
               "Receive-SQSMessage",
               "Remove-SQSPermission",
               "Send-SQSMessage",
               "Send-SQSMessageBatch",
               "Set-SQSQueueAttribute",
               "Add-SQSResourceTag",
               "Remove-SQSResourceTag")
}

_awsArgumentCompleterRegistration $SQS_SelectCompleters $SQS_SelectMap
# Argument completions for service AWS Systems Manager


$SSM_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.SimpleSystemsManagement.AssociationComplianceSeverity
        {
            ($_ -eq "New-SSMAssociation/ComplianceSeverity") -Or
            ($_ -eq "Update-SSMAssociation/ComplianceSeverity")
        }
        {
            $v = "CRITICAL","HIGH","LOW","MEDIUM","UNSPECIFIED"
            break
        }

        # Amazon.SimpleSystemsManagement.AssociationStatusName
        "Update-SSMAssociationStatus/AssociationStatus_Name"
        {
            $v = "Failed","Pending","Success"
            break
        }

        # Amazon.SimpleSystemsManagement.DocumentFormat
        {
            ($_ -eq "Get-SSMDocument/DocumentFormat") -Or
            ($_ -eq "New-SSMDocument/DocumentFormat") -Or
            ($_ -eq "Update-SSMDocument/DocumentFormat")
        }
        {
            $v = "JSON","TEXT","YAML"
            break
        }

        # Amazon.SimpleSystemsManagement.DocumentHashType
        {
            ($_ -eq "Send-SSMCommand/DocumentHashType") -Or
            ($_ -eq "Register-SSMTaskWithMaintenanceWindow/TaskInvocationParameters_RunCommand_DocumentHashType") -Or
            ($_ -eq "Update-SSMMaintenanceWindowTask/TaskInvocationParameters_RunCommand_DocumentHashType")
        }
        {
            $v = "Sha1","Sha256"
            break
        }

        # Amazon.SimpleSystemsManagement.DocumentPermissionType
        {
            ($_ -eq "Edit-SSMDocumentPermission/PermissionType") -Or
            ($_ -eq "Get-SSMDocumentPermission/PermissionType")
        }
        {
            $v = "Share"
            break
        }

        # Amazon.SimpleSystemsManagement.DocumentType
        "New-SSMDocument/DocumentType"
        {
            $v = "ApplicationConfiguration","ApplicationConfigurationSchema","Automation","ChangeCalendar","Command","DeploymentStrategy","Package","Policy","Session"
            break
        }

        # Amazon.SimpleSystemsManagement.ExecutionMode
        "Start-SSMAutomationExecution/Mode"
        {
            $v = "Auto","Interactive"
            break
        }

        # Amazon.SimpleSystemsManagement.InventorySchemaDeleteOption
        "Remove-SSMInventory/SchemaDeleteOption"
        {
            $v = "DeleteSchema","DisableSchema"
            break
        }

        # Amazon.SimpleSystemsManagement.MaintenanceWindowResourceType
        {
            ($_ -eq "Get-SSMMaintenanceWindowSchedule/ResourceType") -Or
            ($_ -eq "Get-SSMMaintenanceWindowsForTarget/ResourceType") -Or
            ($_ -eq "Register-SSMTargetWithMaintenanceWindow/ResourceType")
        }
        {
            $v = "INSTANCE","RESOURCE_GROUP"
            break
        }

        # Amazon.SimpleSystemsManagement.MaintenanceWindowTaskType
        "Register-SSMTaskWithMaintenanceWindow/TaskType"
        {
            $v = "AUTOMATION","LAMBDA","RUN_COMMAND","STEP_FUNCTIONS"
            break
        }

        # Amazon.SimpleSystemsManagement.NotificationType
        {
            ($_ -eq "Send-SSMCommand/NotificationConfig_NotificationType") -Or
            ($_ -eq "Register-SSMTaskWithMaintenanceWindow/TaskInvocationParameters_RunCommand_NotificationConfig_NotificationType") -Or
            ($_ -eq "Update-SSMMaintenanceWindowTask/TaskInvocationParameters_RunCommand_NotificationConfig_NotificationType")
        }
        {
            $v = "Command","Invocation"
            break
        }

        # Amazon.SimpleSystemsManagement.OperatingSystem
        {
            ($_ -eq "Get-SSMDefaultPatchBaseline/OperatingSystem") -Or
            ($_ -eq "Get-SSMPatchBaselineForPatchGroup/OperatingSystem") -Or
            ($_ -eq "Get-SSMPatchProperty/OperatingSystem") -Or
            ($_ -eq "New-SSMPatchBaseline/OperatingSystem")
        }
        {
            $v = "AMAZON_LINUX","AMAZON_LINUX_2","CENTOS","REDHAT_ENTERPRISE_LINUX","SUSE","UBUNTU","WINDOWS"
            break
        }

        # Amazon.SimpleSystemsManagement.OpsItemStatus
        "Update-SSMOpsItem/Status"
        {
            $v = "InProgress","Open","Resolved"
            break
        }

        # Amazon.SimpleSystemsManagement.ParameterTier
        "Write-SSMParameter/Tier"
        {
            $v = "Advanced","Intelligent-Tiering","Standard"
            break
        }

        # Amazon.SimpleSystemsManagement.ParameterType
        "Write-SSMParameter/Type"
        {
            $v = "SecureString","String","StringList"
            break
        }

        # Amazon.SimpleSystemsManagement.PatchAction
        {
            ($_ -eq "New-SSMPatchBaseline/RejectedPatchesAction") -Or
            ($_ -eq "Update-SSMPatchBaseline/RejectedPatchesAction")
        }
        {
            $v = "ALLOW_AS_DEPENDENCY","BLOCK"
            break
        }

        # Amazon.SimpleSystemsManagement.PatchComplianceLevel
        {
            ($_ -eq "New-SSMPatchBaseline/ApprovedPatchesComplianceLevel") -Or
            ($_ -eq "Update-SSMPatchBaseline/ApprovedPatchesComplianceLevel")
        }
        {
            $v = "CRITICAL","HIGH","INFORMATIONAL","LOW","MEDIUM","UNSPECIFIED"
            break
        }

        # Amazon.SimpleSystemsManagement.PatchProperty
        "Get-SSMPatchProperty/Property"
        {
            $v = "CLASSIFICATION","MSRC_SEVERITY","PRIORITY","PRODUCT","PRODUCT_FAMILY","SEVERITY"
            break
        }

        # Amazon.SimpleSystemsManagement.PatchSet
        "Get-SSMPatchProperty/PatchSet"
        {
            $v = "APPLICATION","OS"
            break
        }

        # Amazon.SimpleSystemsManagement.ResourceDataSyncS3Format
        "New-SSMResourceDataSync/S3Destination_SyncFormat"
        {
            $v = "JsonSerDe"
            break
        }

        # Amazon.SimpleSystemsManagement.ResourceTypeForTagging
        {
            ($_ -eq "Add-SSMResourceTag/ResourceType") -Or
            ($_ -eq "Get-SSMResourceTag/ResourceType") -Or
            ($_ -eq "Remove-SSMResourceTag/ResourceType")
        }
        {
            $v = "Document","MaintenanceWindow","ManagedInstance","OpsItem","Parameter","PatchBaseline"
            break
        }

        # Amazon.SimpleSystemsManagement.SessionState
        "Get-SSMSession/State"
        {
            $v = "Active","History"
            break
        }

        # Amazon.SimpleSystemsManagement.SignalType
        "Send-SSMAutomationSignal/SignalType"
        {
            $v = "Approve","Reject","Resume","StartStep","StopStep"
            break
        }

        # Amazon.SimpleSystemsManagement.StopType
        "Stop-SSMAutomationExecution/Type"
        {
            $v = "Cancel","Complete"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SSM_map = @{
    "ApprovedPatchesComplianceLevel"=@("New-SSMPatchBaseline","Update-SSMPatchBaseline")
    "AssociationStatus_Name"=@("Update-SSMAssociationStatus")
    "ComplianceSeverity"=@("New-SSMAssociation","Update-SSMAssociation")
    "DocumentFormat"=@("Get-SSMDocument","New-SSMDocument","Update-SSMDocument")
    "DocumentHashType"=@("Send-SSMCommand")
    "DocumentType"=@("New-SSMDocument")
    "Mode"=@("Start-SSMAutomationExecution")
    "NotificationConfig_NotificationType"=@("Send-SSMCommand")
    "OperatingSystem"=@("Get-SSMDefaultPatchBaseline","Get-SSMPatchBaselineForPatchGroup","Get-SSMPatchProperty","New-SSMPatchBaseline")
    "PatchSet"=@("Get-SSMPatchProperty")
    "PermissionType"=@("Edit-SSMDocumentPermission","Get-SSMDocumentPermission")
    "Property"=@("Get-SSMPatchProperty")
    "RejectedPatchesAction"=@("New-SSMPatchBaseline","Update-SSMPatchBaseline")
    "ResourceType"=@("Add-SSMResourceTag","Get-SSMMaintenanceWindowSchedule","Get-SSMMaintenanceWindowsForTarget","Get-SSMResourceTag","Register-SSMTargetWithMaintenanceWindow","Remove-SSMResourceTag")
    "S3Destination_SyncFormat"=@("New-SSMResourceDataSync")
    "SchemaDeleteOption"=@("Remove-SSMInventory")
    "SignalType"=@("Send-SSMAutomationSignal")
    "State"=@("Get-SSMSession")
    "Status"=@("Update-SSMOpsItem")
    "TaskInvocationParameters_RunCommand_DocumentHashType"=@("Register-SSMTaskWithMaintenanceWindow","Update-SSMMaintenanceWindowTask")
    "TaskInvocationParameters_RunCommand_NotificationConfig_NotificationType"=@("Register-SSMTaskWithMaintenanceWindow","Update-SSMMaintenanceWindowTask")
    "TaskType"=@("Register-SSMTaskWithMaintenanceWindow")
    "Tier"=@("Write-SSMParameter")
    "Type"=@("Stop-SSMAutomationExecution","Write-SSMParameter")
}

_awsArgumentCompleterRegistration $SSM_Completers $SSM_map

$SSM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SSM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SSM_SelectMap = @{
    "Select"=@("Add-SSMResourceTag",
               "Stop-SSMCommand",
               "Stop-SSMMaintenanceWindowExecution",
               "New-SSMActivation",
               "New-SSMAssociation",
               "New-SSMAssociationFromBatch",
               "New-SSMDocument",
               "New-SSMMaintenanceWindow",
               "New-SSMOpsItem",
               "New-SSMPatchBaseline",
               "New-SSMResourceDataSync",
               "Remove-SSMActivation",
               "Remove-SSMAssociation",
               "Remove-SSMDocument",
               "Remove-SSMInventory",
               "Remove-SSMMaintenanceWindow",
               "Remove-SSMParameter",
               "Remove-SSMParameterCollection",
               "Remove-SSMPatchBaseline",
               "Remove-SSMResourceDataSync",
               "Unregister-SSMManagedInstance",
               "Unregister-SSMPatchBaselineForPatchGroup",
               "Unregister-SSMTargetFromMaintenanceWindow",
               "Unregister-SSMTaskFromMaintenanceWindow",
               "Get-SSMActivation",
               "Get-SSMAssociation",
               "Get-SSMAssociationExecution",
               "Get-SSMAssociationExecutionTarget",
               "Get-SSMAutomationExecutionList",
               "Get-SSMAutomationStepExecution",
               "Get-SSMAvailablePatch",
               "Get-SSMDocumentDescription",
               "Get-SSMDocumentPermission",
               "Get-SSMEffectiveInstanceAssociationList",
               "Get-SSMEffectivePatchesForPatchBaseline",
               "Get-SSMInstanceAssociationsStatus",
               "Get-SSMInstanceInformation",
               "Get-SSMInstancePatch",
               "Get-SSMInstancePatchState",
               "Get-SSMInstancePatchStatesForPatchGroup",
               "Get-SSMInventoryDeletionList",
               "Get-SSMMaintenanceWindowExecutionList",
               "Get-SSMMaintenanceWindowExecutionTaskInvocationList",
               "Get-SSMMaintenanceWindowExecutionTaskList",
               "Get-SSMMaintenanceWindowList",
               "Get-SSMMaintenanceWindowSchedule",
               "Get-SSMMaintenanceWindowsForTarget",
               "Get-SSMMaintenanceWindowTarget",
               "Get-SSMMaintenanceWindowTaskList",
               "Get-SSMOpsItemSummary",
               "Get-SSMParameterList",
               "Get-SSMPatchBaseline",
               "Get-SSMPatchGroup",
               "Get-SSMPatchGroupState",
               "Get-SSMPatchProperty",
               "Get-SSMSession",
               "Get-SSMAutomationExecution",
               "Get-SSMCalendarState",
               "Get-SSMCommandInvocationDetail",
               "Get-SSMConnectionStatus",
               "Get-SSMDefaultPatchBaseline",
               "Get-SSMDeployablePatchSnapshotForInstance",
               "Get-SSMDocument",
               "Get-SSMInventory",
               "Get-SSMInventorySchema",
               "Get-SSMMaintenanceWindow",
               "Get-SSMMaintenanceWindowExecution",
               "Get-SSMMaintenanceWindowExecutionTask",
               "Get-SSMMaintenanceWindowExecutionTaskInvocation",
               "Get-SSMMaintenanceWindowTask",
               "Get-SSMOpsItem",
               "Get-SSMOpsSummary",
               "Get-SSMParameter",
               "Get-SSMParameterHistory",
               "Get-SSMParameterValue",
               "Get-SSMParametersByPath",
               "Get-SSMPatchBaselineDetail",
               "Get-SSMPatchBaselineForPatchGroup",
               "Get-SSMServiceSetting",
               "Set-SSMParameterVersionLabel",
               "Get-SSMAssociationList",
               "Get-SSMAssociationVersionList",
               "Get-SSMCommandInvocation",
               "Get-SSMCommand",
               "Get-SSMComplianceItemList",
               "Get-SSMComplianceSummaryList",
               "Get-SSMDocumentList",
               "Get-SSMDocumentVersionList",
               "Get-SSMInventoryEntryList",
               "Get-SSMResourceComplianceSummaryList",
               "Get-SSMResourceDataSync",
               "Get-SSMResourceTag",
               "Edit-SSMDocumentPermission",
               "Write-SSMComplianceItem",
               "Write-SSMInventory",
               "Write-SSMParameter",
               "Register-SSMDefaultPatchBaseline",
               "Register-SSMPatchBaselineForPatchGroup",
               "Register-SSMTargetWithMaintenanceWindow",
               "Register-SSMTaskWithMaintenanceWindow",
               "Remove-SSMResourceTag",
               "Reset-SSMServiceSetting",
               "Resume-SSMSession",
               "Send-SSMAutomationSignal",
               "Send-SSMCommand",
               "Start-SSMAssociationsOnce",
               "Start-SSMAutomationExecution",
               "Start-SSMSession",
               "Stop-SSMAutomationExecution",
               "Stop-SSMSession",
               "Update-SSMAssociation",
               "Update-SSMAssociationStatus",
               "Update-SSMDocument",
               "Update-SSMDocumentDefaultVersion",
               "Update-SSMMaintenanceWindow",
               "Update-SSMMaintenanceWindowTarget",
               "Update-SSMMaintenanceWindowTask",
               "Update-SSMManagedInstanceRole",
               "Update-SSMOpsItem",
               "Update-SSMPatchBaseline",
               "Update-SSMResourceDataSync",
               "Update-SSMServiceSetting",
               "Get-SSMLatestEC2Image")
}

_awsArgumentCompleterRegistration $SSM_SelectCompleters $SSM_SelectMap
# Argument completions for service AWS Single Sign-On


$SSO_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SSO.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SSO_SelectMap = @{
    "Select"=@("Get-SSORoleCredential",
               "Get-SSOAccountRoleList",
               "Get-SSOAccountList",
               "Close-SSOSession")
}

_awsArgumentCompleterRegistration $SSO_SelectCompleters $SSO_SelectMap
# Argument completions for service AWS Single Sign-On OIDC


$SSOOIDC_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SSOOIDC.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SSOOIDC_SelectMap = @{
    "Select"=@("New-SSOOIDCToken",
               "Register-SSOOIDCClient",
               "Start-SSOOIDCDeviceAuthorization")
}

_awsArgumentCompleterRegistration $SSOOIDC_SelectCompleters $SSOOIDC_SelectMap
# Argument completions for service AWS Step Functions


$SFN_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.StepFunctions.ExecutionStatus
        "Get-SFNExecutionList/StatusFilter"
        {
            $v = "ABORTED","FAILED","RUNNING","SUCCEEDED","TIMED_OUT"
            break
        }

        # Amazon.StepFunctions.LogLevel
        {
            ($_ -eq "New-SFNStateMachine/LoggingConfiguration_Level") -Or
            ($_ -eq "Update-SFNStateMachine/LoggingConfiguration_Level")
        }
        {
            $v = "ALL","ERROR","FATAL","OFF"
            break
        }

        # Amazon.StepFunctions.StateMachineType
        "New-SFNStateMachine/Type"
        {
            $v = "EXPRESS","STANDARD"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SFN_map = @{
    "LoggingConfiguration_Level"=@("New-SFNStateMachine","Update-SFNStateMachine")
    "StatusFilter"=@("Get-SFNExecutionList")
    "Type"=@("New-SFNStateMachine")
}

_awsArgumentCompleterRegistration $SFN_Completers $SFN_map

$SFN_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SFN.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SFN_SelectMap = @{
    "Select"=@("New-SFNActivity",
               "New-SFNStateMachine",
               "Remove-SFNActivity",
               "Remove-SFNStateMachine",
               "Get-SFNActivity",
               "Get-SFNExecution",
               "Get-SFNStateMachine",
               "Get-SFNStateMachineForExecution",
               "Get-SFNActivityTask",
               "Get-SFNExecutionHistory",
               "Get-SFNActivityList",
               "Get-SFNExecutionList",
               "Get-SFNStateMachineList",
               "Get-SFNResourceTag",
               "Send-SFNTaskFailure",
               "Send-SFNTaskHeartbeat",
               "Send-SFNTaskSuccess",
               "Start-SFNExecution",
               "Stop-SFNExecution",
               "Add-SFNResourceTag",
               "Remove-SFNResourceTag",
               "Update-SFNStateMachine")
}

_awsArgumentCompleterRegistration $SFN_SelectCompleters $SFN_SelectMap
# Argument completions for service AWS Storage Gateway


$SG_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.StorageGateway.ObjectACL
        {
            ($_ -eq "New-SGNFSFileShare/ObjectACL") -Or
            ($_ -eq "New-SGSMBFileShare/ObjectACL") -Or
            ($_ -eq "Update-SGNFSFileShare/ObjectACL") -Or
            ($_ -eq "Update-SGSMBFileShare/ObjectACL")
        }
        {
            $v = "authenticated-read","aws-exec-read","bucket-owner-full-control","bucket-owner-read","private","public-read","public-read-write"
            break
        }

        # Amazon.StorageGateway.SMBSecurityStrategy
        "Update-SGSMBSecurityStrategy/SMBSecurityStrategy"
        {
            $v = "ClientSpecified","MandatoryEncryption","MandatorySigning"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SG_map = @{
    "ObjectACL"=@("New-SGNFSFileShare","New-SGSMBFileShare","Update-SGNFSFileShare","Update-SGSMBFileShare")
    "SMBSecurityStrategy"=@("Update-SGSMBSecurityStrategy")
}

_awsArgumentCompleterRegistration $SG_Completers $SG_map

$SG_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SG.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SG_SelectMap = @{
    "Select"=@("Enable-SGGateway",
               "Add-SGCache",
               "Add-SGResourceTag",
               "Add-SGUploadBuffer",
               "Add-SGWorkingStorage",
               "Add-SGTapeToTapePool",
               "Mount-SGVolume",
               "Stop-SGArchival",
               "Stop-SGRetrieval",
               "New-SGCachediSCSIVolume",
               "New-SGNFSFileShare",
               "New-SGSMBFileShare",
               "New-SGSnapshot",
               "New-SGSnapshotFromVolumeRecoveryPoint",
               "New-SGStorediSCSIVolume",
               "New-SGTape",
               "New-SGTapeWithBarcode",
               "Remove-SGBandwidthRateLimit",
               "Remove-SGChapCredential",
               "Remove-SGFileShare",
               "Remove-SGGateway",
               "Remove-SGSnapshotSchedule",
               "Remove-SGTape",
               "Remove-SGTapeArchive",
               "Remove-SGVolume",
               "Get-SGAvailabilityMonitorTest",
               "Get-SGBandwidthRateLimit",
               "Get-SGCache",
               "Get-SGCachediSCSIVolume",
               "Get-SGChapCredential",
               "Get-SGGatewayInformation",
               "Get-SGMaintenanceStartTime",
               "Get-SGNFSFileShareList",
               "Get-SGSMBFileShare",
               "Get-SGSMBSetting",
               "Get-SGSnapshotSchedule",
               "Get-SGStorediSCSIVolume",
               "Get-SGTapeArchiveList",
               "Get-SGTapeRecoveryPointList",
               "Get-SGTapeList",
               "Get-SGUploadBuffer",
               "Get-SGVTLDevice",
               "Get-SGWorkingStorage",
               "Dismount-SGVolume",
               "Disable-SGGateway",
               "Join-SGDomain",
               "Get-SGFileShareList",
               "Get-SGGateway",
               "Get-SGLocalDisk",
               "Get-SGResourceTag",
               "Get-SGTape",
               "Get-SGVolumeInitiatorList",
               "Get-SGVolumeRecoveryPoint",
               "Get-SGVolume",
               "Send-SGUploadedNotification",
               "Invoke-SGCacheRefresh",
               "Remove-SGResourceTag",
               "Reset-SGCache",
               "Get-SGTapeArchive",
               "Get-SGTapeRecoveryPoint",
               "Set-SGLocalConsolePassword",
               "Set-SGSMBGuestPassword",
               "Stop-SGGateway",
               "Start-SGAvailabilityMonitorTest",
               "Start-SGGateway",
               "Update-SGBandwidthRateLimit",
               "Update-SGChapCredential",
               "Update-SGGatewayInformation",
               "Update-SGGatewaySoftwareNow",
               "Update-SGMaintenanceStartTime",
               "Update-SGNFSFileShare",
               "Update-SGSMBFileShare",
               "Update-SGSMBSecurityStrategy",
               "Update-SGSnapshotSchedule",
               "Update-SGVTLDeviceType")
}

_awsArgumentCompleterRegistration $SG_SelectCompleters $SG_SelectMap
# Argument completions for service AWS Security Token Service (STS)


$STS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.STS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$STS_SelectMap = @{
    "Select"=@("Use-STSRole",
               "Convert-STSAuthorizationMessage",
               "Get-STSAccessKeyInfo",
               "Get-STSCallerIdentity",
               "Get-STSFederationToken",
               "Get-STSSessionToken",
               "Use-STSRoleWithSAML",
               "Use-STSWebIdentityRole")
}

_awsArgumentCompleterRegistration $STS_SelectCompleters $STS_SelectMap
# Argument completions for service AWS Support


$ASA_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.ASA.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$ASA_SelectMap = @{
    "Select"=@("Add-ASAAttachmentsToSet",
               "Add-ASACommunicationToCase",
               "New-ASACase",
               "Get-ASAAttachment",
               "Get-ASACase",
               "Get-ASACommunication",
               "Get-ASAService",
               "Get-ASASeverityLevel",
               "Get-ASATrustedAdvisorCheckRefreshStatus",
               "Get-ASATrustedAdvisorCheckResult",
               "Get-ASATrustedAdvisorCheck",
               "Get-ASATrustedAdvisorCheckSummary",
               "Request-ASATrustedAdvisorCheckRefresh",
               "Resolve-ASACase")
}

_awsArgumentCompleterRegistration $ASA_SelectCompleters $ASA_SelectMap
# Argument completions for service AWS Simple Workflow Service (SWF)


$SWF_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.SimpleWorkflow.ChildPolicy
        {
            ($_ -eq "Start-SWFWorkflowExecution/ChildPolicy") -Or
            ($_ -eq "Stop-SWFWorkflowExecution/ChildPolicy") -Or
            ($_ -eq "New-SWFWorkflowType/DefaultChildPolicy")
        }
        {
            $v = "ABANDON","REQUEST_CANCEL","TERMINATE"
            break
        }

        # Amazon.SimpleWorkflow.CloseStatus
        {
            ($_ -eq "Get-SWFClosedWorkflowExecutionCount/CloseStatusFilter_Status") -Or
            ($_ -eq "Get-SWFClosedWorkflowExecutionList/CloseStatusFilter_Status")
        }
        {
            $v = "CANCELED","COMPLETED","CONTINUED_AS_NEW","FAILED","TERMINATED","TIMED_OUT"
            break
        }

        # Amazon.SimpleWorkflow.RegistrationStatus
        {
            ($_ -eq "Get-SWFActivityTypeList/RegistrationStatus") -Or
            ($_ -eq "Get-SWFDomainList/RegistrationStatus") -Or
            ($_ -eq "Get-SWFWorkflowTypeList/RegistrationStatus")
        }
        {
            $v = "DEPRECATED","REGISTERED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SWF_map = @{
    "ChildPolicy"=@("Start-SWFWorkflowExecution","Stop-SWFWorkflowExecution")
    "CloseStatusFilter_Status"=@("Get-SWFClosedWorkflowExecutionCount","Get-SWFClosedWorkflowExecutionList")
    "DefaultChildPolicy"=@("New-SWFWorkflowType")
    "RegistrationStatus"=@("Get-SWFActivityTypeList","Get-SWFDomainList","Get-SWFWorkflowTypeList")
}

_awsArgumentCompleterRegistration $SWF_Completers $SWF_map

$SWF_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.SWF.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$SWF_SelectMap = @{
    "Select"=@("Get-SWFClosedWorkflowExecutionCount",
               "Get-SWFOpenWorkflowExecutionCount",
               "Get-SWFPendingActivityTaskCount",
               "Get-SWFPendingDecisionTaskCount",
               "Remove-SWFActivityType",
               "Remove-SWFDomain",
               "Remove-SWFWorkflowType",
               "Get-SWFActivityType",
               "Get-SWFDomain",
               "Get-SWFWorkflowExecution",
               "Get-SWFWorkflowType",
               "Get-SWFWorkflowExecutionHistory",
               "Get-SWFActivityTypeList",
               "Get-SWFClosedWorkflowExecutionList",
               "Get-SWFDomainList",
               "Get-SWFResourceTag",
               "Get-SWFWorkflowTypeList",
               "New-SWFActivityType",
               "New-SWFDomain",
               "New-SWFWorkflowType",
               "Request-SWFCancelWorkflowExecution",
               "Send-SWFSignalToWorkflowExecution",
               "Start-SWFWorkflowExecution",
               "Add-SWFResourceTag",
               "Stop-SWFWorkflowExecution",
               "Restore-SWFActivityType",
               "Restore-SWFDomain",
               "Restore-SWFWorkflowType",
               "Remove-SWFResourceTag")
}

_awsArgumentCompleterRegistration $SWF_SelectCompleters $SWF_SelectMap
# Argument completions for service Amazon Textract


$TXT_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.TXT.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$TXT_SelectMap = @{
    "Select"=@("Invoke-TXTDocumentAnalysis",
               "Find-TXTDocumentText",
               "Get-TXTDocumentAnalysis",
               "Get-TXTDocumentTextDetection",
               "Start-TXTDocumentAnalysis",
               "Start-TXTDocumentTextDetection")
}

_awsArgumentCompleterRegistration $TXT_SelectCompleters $TXT_SelectMap
# Argument completions for service Amazon Transcribe Service


$TRS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.TranscribeService.LanguageCode
        {
            ($_ -eq "New-TRSVocabulary/LanguageCode") -Or
            ($_ -eq "Start-TRSTranscriptionJob/LanguageCode") -Or
            ($_ -eq "Update-TRSVocabulary/LanguageCode")
        }
        {
            $v = "ar-AE","ar-SA","de-CH","de-DE","en-AB","en-AU","en-GB","en-IE","en-IN","en-US","en-WL","es-ES","es-US","fa-IR","fr-CA","fr-FR","he-IL","hi-IN","id-ID","it-IT","ja-JP","ko-KR","ms-MY","nl-NL","pt-BR","pt-PT","ru-RU","ta-IN","te-IN","tr-TR","zh-CN"
            break
        }

        # Amazon.TranscribeService.MediaFormat
        "Start-TRSTranscriptionJob/MediaFormat"
        {
            $v = "flac","mp3","mp4","wav"
            break
        }

        # Amazon.TranscribeService.TranscriptionJobStatus
        "Get-TRSTranscriptionJobList/Status"
        {
            $v = "COMPLETED","FAILED","IN_PROGRESS"
            break
        }

        # Amazon.TranscribeService.VocabularyState
        "Get-TRSVocabularyList/StateEquals"
        {
            $v = "FAILED","PENDING","READY"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$TRS_map = @{
    "LanguageCode"=@("New-TRSVocabulary","Start-TRSTranscriptionJob","Update-TRSVocabulary")
    "MediaFormat"=@("Start-TRSTranscriptionJob")
    "StateEquals"=@("Get-TRSVocabularyList")
    "Status"=@("Get-TRSTranscriptionJobList")
}

_awsArgumentCompleterRegistration $TRS_Completers $TRS_map

$TRS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.TRS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$TRS_SelectMap = @{
    "Select"=@("New-TRSVocabulary",
               "Remove-TRSTranscriptionJob",
               "Remove-TRSVocabulary",
               "Get-TRSTranscriptionJob",
               "Get-TRSVocabulary",
               "Get-TRSTranscriptionJobList",
               "Get-TRSVocabularyList",
               "Start-TRSTranscriptionJob",
               "Update-TRSVocabulary")
}

_awsArgumentCompleterRegistration $TRS_SelectCompleters $TRS_SelectMap
# Argument completions for service AWS Transfer for SFTP


$TFR_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Transfer.EndpointType
        {
            ($_ -eq "New-TFRServer/EndpointType") -Or
            ($_ -eq "Update-TFRServer/EndpointType")
        }
        {
            $v = "PUBLIC","VPC_ENDPOINT"
            break
        }

        # Amazon.Transfer.HomeDirectoryType
        {
            ($_ -eq "New-TFRUser/HomeDirectoryType") -Or
            ($_ -eq "Update-TFRUser/HomeDirectoryType")
        }
        {
            $v = "LOGICAL","PATH"
            break
        }

        # Amazon.Transfer.IdentityProviderType
        "New-TFRServer/IdentityProviderType"
        {
            $v = "API_GATEWAY","SERVICE_MANAGED"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$TFR_map = @{
    "EndpointType"=@("New-TFRServer","Update-TFRServer")
    "HomeDirectoryType"=@("New-TFRUser","Update-TFRUser")
    "IdentityProviderType"=@("New-TFRServer")
}

_awsArgumentCompleterRegistration $TFR_Completers $TFR_map

$TFR_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.TFR.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$TFR_SelectMap = @{
    "Select"=@("New-TFRServer",
               "New-TFRUser",
               "Remove-TFRServer",
               "Remove-TFRSshPublicKey",
               "Remove-TFRUser",
               "Get-TFRServer",
               "Get-TFRUser",
               "Import-TFRSshPublicKey",
               "Get-TFRServerList",
               "Get-TFRResourceTagList",
               "Get-TFRUserList",
               "Start-TFRServer",
               "Stop-TFRServer",
               "Add-TFRResourceTag",
               "Test-TFRIdentityProvider",
               "Remove-TFRResourceTag",
               "Update-TFRServer",
               "Update-TFRUser")
}

_awsArgumentCompleterRegistration $TFR_SelectCompleters $TFR_SelectMap
# Argument completions for service Amazon Translate


$TRN_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.Translate.EncryptionKeyType
        "Import-TRNTerminology/EncryptionKey_Type"
        {
            $v = "KMS"
            break
        }

        # Amazon.Translate.MergeStrategy
        "Import-TRNTerminology/MergeStrategy"
        {
            $v = "OVERWRITE"
            break
        }

        # Amazon.Translate.TerminologyDataFormat
        {
            ($_ -eq "Import-TRNTerminology/TerminologyData_Format") -Or
            ($_ -eq "Get-TRNTerminology/TerminologyDataFormat")
        }
        {
            $v = "CSV","TMX"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$TRN_map = @{
    "EncryptionKey_Type"=@("Import-TRNTerminology")
    "MergeStrategy"=@("Import-TRNTerminology")
    "TerminologyData_Format"=@("Import-TRNTerminology")
    "TerminologyDataFormat"=@("Get-TRNTerminology")
}

_awsArgumentCompleterRegistration $TRN_Completers $TRN_map

$TRN_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.TRN.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$TRN_SelectMap = @{
    "Select"=@("Remove-TRNTerminology",
               "Get-TRNTerminology",
               "Import-TRNTerminology",
               "Get-TRNTerminologyList",
               "ConvertTo-TRNTargetLanguage")
}

_awsArgumentCompleterRegistration $TRN_SelectCompleters $TRN_SelectMap
# Argument completions for service AWS WAF


$WAF_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.WAF.RateKey
        "New-WAFRateBasedRule/RateKey"
        {
            $v = "IP"
            break
        }

        # Amazon.WAF.WafActionType
        {
            ($_ -eq "New-WAFWebACL/DefaultAction_Type") -Or
            ($_ -eq "Update-WAFWebACL/DefaultAction_Type")
        }
        {
            $v = "ALLOW","BLOCK","COUNT"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$WAF_map = @{
    "DefaultAction_Type"=@("New-WAFWebACL","Update-WAFWebACL")
    "RateKey"=@("New-WAFRateBasedRule")
}

_awsArgumentCompleterRegistration $WAF_Completers $WAF_map

$WAF_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.WAF.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$WAF_SelectMap = @{
    "Select"=@("New-WAFByteMatchSet",
               "New-WAFGeoMatchSet",
               "New-WAFIPSet",
               "New-WAFRateBasedRule",
               "New-WAFRegexMatchSet",
               "New-WAFRegexPatternSet",
               "New-WAFRule",
               "New-WAFRuleGroup",
               "New-WAFSizeConstraintSet",
               "New-WAFSqlInjectionMatchSet",
               "New-WAFWebACL",
               "New-WAFXssMatchSet",
               "Remove-WAFByteMatchSet",
               "Remove-WAFGeoMatchSet",
               "Remove-WAFIPSet",
               "Remove-WAFLoggingConfiguration",
               "Remove-WAFPermissionPolicy",
               "Remove-WAFRateBasedRule",
               "Remove-WAFRegexMatchSet",
               "Remove-WAFRegexPatternSet",
               "Remove-WAFRule",
               "Remove-WAFRuleGroup",
               "Remove-WAFSizeConstraintSet",
               "Remove-WAFSqlInjectionMatchSet",
               "Remove-WAFWebACL",
               "Remove-WAFXssMatchSet",
               "Get-WAFByteMatchSet",
               "Get-WAFChangeToken",
               "Get-WAFChangeTokenStatus",
               "Get-WAFGeoMatchSet",
               "Get-WAFIPSet",
               "Get-WAFLoggingConfiguration",
               "Get-WAFPermissionPolicy",
               "Get-WAFRateBasedRule",
               "Get-WAFRateBasedRuleManagedKey",
               "Get-WAFRegexMatchSet",
               "Get-WAFRegexPatternSet",
               "Get-WAFRule",
               "Get-WAFRuleGroup",
               "Get-WAFSampledRequestList",
               "Get-WAFSizeConstraintSet",
               "Get-WAFSqlInjectionMatchSet",
               "Get-WAFWebACL",
               "Get-WAFXssMatchSet",
               "Get-WAFActivatedRulesInRuleGroupList",
               "Get-WAFByteMatchSetList",
               "Get-WAFGeoMatchSetList",
               "Get-WAFIPSetList",
               "Get-WAFLoggingConfigurationList",
               "Get-WAFRateBasedRuleList",
               "Get-WAFRegexMatchSetList",
               "Get-WAFRegexPatternSetList",
               "Get-WAFRuleGroupList",
               "Get-WAFRuleList",
               "Get-WAFSizeConstraintSetList",
               "Get-WAFSqlInjectionMatchSetList",
               "Get-WAFSubscribedRuleGroupList",
               "Get-WAFResourceTag",
               "Get-WAFWebACLList",
               "Get-WAFXssMatchSetList",
               "Write-WAFLoggingConfiguration",
               "Write-WAFPermissionPolicy",
               "Add-WAFResourceTag",
               "Remove-WAFResourceTag",
               "Update-WAFByteMatchSet",
               "Update-WAFGeoMatchSet",
               "Update-WAFIPSet",
               "Update-WAFRateBasedRule",
               "Update-WAFRegexMatchSet",
               "Update-WAFRegexPatternSet",
               "Update-WAFRule",
               "Update-WAFRuleGroup",
               "Update-WAFSizeConstraintSet",
               "Update-WAFSqlInjectionMatchSet",
               "Update-WAFWebACL",
               "Update-WAFXssMatchSet")
}

_awsArgumentCompleterRegistration $WAF_SelectCompleters $WAF_SelectMap
# Argument completions for service AWS WAF Regional


$WAFR_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.WAFRegional.RateKey
        "New-WAFRRateBasedRule/RateKey"
        {
            $v = "IP"
            break
        }

        # Amazon.WAFRegional.ResourceType
        "Get-WAFRResourceForWebACLList/ResourceType"
        {
            $v = "API_GATEWAY","APPLICATION_LOAD_BALANCER"
            break
        }

        # Amazon.WAFRegional.WafActionType
        {
            ($_ -eq "New-WAFRWebACL/DefaultAction_Type") -Or
            ($_ -eq "Update-WAFRWebACL/DefaultAction_Type")
        }
        {
            $v = "ALLOW","BLOCK","COUNT"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$WAFR_map = @{
    "DefaultAction_Type"=@("New-WAFRWebACL","Update-WAFRWebACL")
    "RateKey"=@("New-WAFRRateBasedRule")
    "ResourceType"=@("Get-WAFRResourceForWebACLList")
}

_awsArgumentCompleterRegistration $WAFR_Completers $WAFR_map

$WAFR_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.WAFR.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$WAFR_SelectMap = @{
    "Select"=@("Register-WAFRWebACL",
               "New-WAFRByteMatchSet",
               "New-WAFRGeoMatchSet",
               "New-WAFRIPSet",
               "New-WAFRRateBasedRule",
               "New-WAFRRegexMatchSet",
               "New-WAFRRegexPatternSet",
               "New-WAFRRule",
               "New-WAFRRuleGroup",
               "New-WAFRSizeConstraintSet",
               "New-WAFRSqlInjectionMatchSet",
               "New-WAFRWebACL",
               "New-WAFRXssMatchSet",
               "Remove-WAFRByteMatchSet",
               "Remove-WAFRGeoMatchSet",
               "Remove-WAFRIPSet",
               "Remove-WAFRLoggingConfiguration",
               "Remove-WAFRPermissionPolicy",
               "Remove-WAFRRateBasedRule",
               "Remove-WAFRRegexMatchSet",
               "Remove-WAFRRegexPatternSet",
               "Remove-WAFRRule",
               "Remove-WAFRRuleGroup",
               "Remove-WAFRSizeConstraintSet",
               "Remove-WAFRSqlInjectionMatchSet",
               "Remove-WAFRWebACL",
               "Remove-WAFRXssMatchSet",
               "Unregister-WAFRWebACL",
               "Get-WAFRByteMatchSet",
               "Get-WAFRChangeToken",
               "Get-WAFRChangeTokenStatus",
               "Get-WAFRGeoMatchSet",
               "Get-WAFRIPSet",
               "Get-WAFRLoggingConfiguration",
               "Get-WAFRPermissionPolicy",
               "Get-WAFRRateBasedRule",
               "Get-WAFRRateBasedRuleManagedKey",
               "Get-WAFRRegexMatchSet",
               "Get-WAFRRegexPatternSet",
               "Get-WAFRRule",
               "Get-WAFRRuleGroup",
               "Get-WAFRSampledRequestList",
               "Get-WAFRSizeConstraintSet",
               "Get-WAFRSqlInjectionMatchSet",
               "Get-WAFRWebACL",
               "Get-WAFRWebACLForResource",
               "Get-WAFRXssMatchSet",
               "Get-WAFRActivatedRulesInRuleGroupList",
               "Get-WAFRByteMatchSetList",
               "Get-WAFRGeoMatchSetList",
               "Get-WAFRIPSetList",
               "Get-WAFRLoggingConfigurationList",
               "Get-WAFRRateBasedRuleList",
               "Get-WAFRRegexMatchSetList",
               "Get-WAFRRegexPatternSetList",
               "Get-WAFRResourceForWebACLList",
               "Get-WAFRRuleGroupList",
               "Get-WAFRRuleList",
               "Get-WAFRSizeConstraintSetList",
               "Get-WAFRSqlInjectionMatchSetList",
               "Get-WAFRSubscribedRuleGroup",
               "Get-WAFRResourceTag",
               "Get-WAFRWebACLList",
               "Get-WAFRXssMatchSetList",
               "Write-WAFRLoggingConfiguration",
               "Write-WAFRPermissionPolicy",
               "Add-WAFRResourceTag",
               "Remove-WAFRResourceTag",
               "Update-WAFRByteMatchSet",
               "Update-WAFRGeoMatchSet",
               "Update-WAFRIPSet",
               "Update-WAFRRateBasedRule",
               "Update-WAFRRegexMatchSet",
               "Update-WAFRRegexPatternSet",
               "Update-WAFRRule",
               "Update-WAFRRuleGroup",
               "Update-WAFRSizeConstraintSet",
               "Update-WAFRSqlInjectionMatchSet",
               "Update-WAFRWebACL",
               "Update-WAFRXssMatchSet")
}

_awsArgumentCompleterRegistration $WAFR_SelectCompleters $WAFR_SelectMap
# Argument completions for service AWS WAF V2


$WAF2_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.WAFV2.IPAddressVersion
        "New-WAF2IPSet/IPAddressVersion"
        {
            $v = "IPV4","IPV6"
            break
        }

        # Amazon.WAFV2.ResourceType
        "Get-WAF2ResourcesForWebACLList/ResourceType"
        {
            $v = "API_GATEWAY","APPLICATION_LOAD_BALANCER"
            break
        }

        # Amazon.WAFV2.Scope
        {
            ($_ -eq "Get-WAF2AvailableManagedRuleGroupList/Scope") -Or
            ($_ -eq "Get-WAF2IPSet/Scope") -Or
            ($_ -eq "Get-WAF2IPSetList/Scope") -Or
            ($_ -eq "Get-WAF2LoggingConfigurationList/Scope") -Or
            ($_ -eq "Get-WAF2ManagedRuleGroup/Scope") -Or
            ($_ -eq "Get-WAF2RateBasedStatementManagedKey/Scope") -Or
            ($_ -eq "Get-WAF2RegexPatternSet/Scope") -Or
            ($_ -eq "Get-WAF2RegexPatternSetList/Scope") -Or
            ($_ -eq "Get-WAF2RuleGroup/Scope") -Or
            ($_ -eq "Get-WAF2RuleGroupList/Scope") -Or
            ($_ -eq "Get-WAF2SampledRequest/Scope") -Or
            ($_ -eq "Get-WAF2WebACL/Scope") -Or
            ($_ -eq "Get-WAF2WebACLsList/Scope") -Or
            ($_ -eq "New-WAF2IPSet/Scope") -Or
            ($_ -eq "New-WAF2RegexPatternSet/Scope") -Or
            ($_ -eq "New-WAF2RuleGroup/Scope") -Or
            ($_ -eq "New-WAF2WebACL/Scope") -Or
            ($_ -eq "Remove-WAF2IPSet/Scope") -Or
            ($_ -eq "Remove-WAF2RegexPatternSet/Scope") -Or
            ($_ -eq "Remove-WAF2RuleGroup/Scope") -Or
            ($_ -eq "Remove-WAF2WebACL/Scope") -Or
            ($_ -eq "Test-WAF2Capacity/Scope") -Or
            ($_ -eq "Update-WAF2IPSet/Scope") -Or
            ($_ -eq "Update-WAF2RegexPatternSet/Scope") -Or
            ($_ -eq "Update-WAF2RuleGroup/Scope") -Or
            ($_ -eq "Update-WAF2WebACL/Scope")
        }
        {
            $v = "CLOUDFRONT","REGIONAL"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$WAF2_map = @{
    "IPAddressVersion"=@("New-WAF2IPSet")
    "ResourceType"=@("Get-WAF2ResourcesForWebACLList")
    "Scope"=@("Get-WAF2AvailableManagedRuleGroupList","Get-WAF2IPSet","Get-WAF2IPSetList","Get-WAF2LoggingConfigurationList","Get-WAF2ManagedRuleGroup","Get-WAF2RateBasedStatementManagedKey","Get-WAF2RegexPatternSet","Get-WAF2RegexPatternSetList","Get-WAF2RuleGroup","Get-WAF2RuleGroupList","Get-WAF2SampledRequest","Get-WAF2WebACL","Get-WAF2WebACLsList","New-WAF2IPSet","New-WAF2RegexPatternSet","New-WAF2RuleGroup","New-WAF2WebACL","Remove-WAF2IPSet","Remove-WAF2RegexPatternSet","Remove-WAF2RuleGroup","Remove-WAF2WebACL","Test-WAF2Capacity","Update-WAF2IPSet","Update-WAF2RegexPatternSet","Update-WAF2RuleGroup","Update-WAF2WebACL")
}

_awsArgumentCompleterRegistration $WAF2_Completers $WAF2_map

$WAF2_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.WAF2.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$WAF2_SelectMap = @{
    "Select"=@("Add-WAF2WebACLToResource",
               "Test-WAF2Capacity",
               "New-WAF2IPSet",
               "New-WAF2RegexPatternSet",
               "New-WAF2RuleGroup",
               "New-WAF2WebACL",
               "Remove-WAF2IPSet",
               "Remove-WAF2LoggingConfiguration",
               "Remove-WAF2RegexPatternSet",
               "Remove-WAF2RuleGroup",
               "Remove-WAF2WebACL",
               "Get-WAF2ManagedRuleGroup",
               "Remove-WAF2WebACLFromResource",
               "Get-WAF2IPSet",
               "Get-WAF2LoggingConfiguration",
               "Get-WAF2RateBasedStatementManagedKey",
               "Get-WAF2RegexPatternSet",
               "Get-WAF2RuleGroup",
               "Get-WAF2SampledRequest",
               "Get-WAF2WebACL",
               "Get-WAF2WebACLForResource",
               "Get-WAF2AvailableManagedRuleGroupList",
               "Get-WAF2IPSetList",
               "Get-WAF2LoggingConfigurationList",
               "Get-WAF2RegexPatternSetList",
               "Get-WAF2ResourcesForWebACLList",
               "Get-WAF2RuleGroupList",
               "Get-WAF2ResourceTag",
               "Get-WAF2WebACLsList",
               "Write-WAF2LoggingConfiguration",
               "Add-WAF2ResourceTag",
               "Remove-WAF2ResourceTag",
               "Update-WAF2IPSet",
               "Update-WAF2RegexPatternSet",
               "Update-WAF2RuleGroup",
               "Update-WAF2WebACL")
}

_awsArgumentCompleterRegistration $WAF2_SelectCompleters $WAF2_SelectMap
# Argument completions for service Amazon WorkDocs


$WD_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.WorkDocs.BooleanEnumType
        "Update-WDUser/GrantPoweruserPrivileges"
        {
            $v = "FALSE","TRUE"
            break
        }

        # Amazon.WorkDocs.CommentVisibilityType
        "New-WDComment/Visibility"
        {
            $v = "PRIVATE","PUBLIC"
            break
        }

        # Amazon.WorkDocs.DocumentVersionStatus
        "Update-WDDocumentVersion/VersionStatus"
        {
            $v = "ACTIVE"
            break
        }

        # Amazon.WorkDocs.FolderContentType
        "Get-WDFolderContent/Type"
        {
            $v = "ALL","DOCUMENT","FOLDER"
            break
        }

        # Amazon.WorkDocs.LocaleType
        "Update-WDUser/Locale"
        {
            $v = "de","default","en","es","fr","ja","ko","pt_BR","ru","zh_CN","zh_TW"
            break
        }

        # Amazon.WorkDocs.OrderType
        {
            ($_ -eq "Get-WDFolderContent/Order") -Or
            ($_ -eq "Get-WDUserList/Order")
        }
        {
            $v = "ASCENDING","DESCENDING"
            break
        }

        # Amazon.WorkDocs.PrincipalType
        "Remove-WDResourcePermission/PrincipalType"
        {
            $v = "ANONYMOUS","GROUP","INVITE","ORGANIZATION","USER"
            break
        }

        # Amazon.WorkDocs.ResourceCollectionType
        "Get-WDResource/CollectionType"
        {
            $v = "SHARED_WITH_ME"
            break
        }

        # Amazon.WorkDocs.ResourceSortType
        "Get-WDFolderContent/Sort"
        {
            $v = "DATE","NAME"
            break
        }

        # Amazon.WorkDocs.ResourceStateType
        {
            ($_ -eq "Update-WDDocument/ResourceState") -Or
            ($_ -eq "Update-WDFolder/ResourceState")
        }
        {
            $v = "ACTIVE","RECYCLED","RECYCLING","RESTORING"
            break
        }

        # Amazon.WorkDocs.StorageType
        {
            ($_ -eq "New-WDUser/StorageRule_StorageType") -Or
            ($_ -eq "Update-WDUser/StorageRule_StorageType")
        }
        {
            $v = "QUOTA","UNLIMITED"
            break
        }

        # Amazon.WorkDocs.SubscriptionProtocolType
        "New-WDNotificationSubscription/Protocol"
        {
            $v = "HTTPS"
            break
        }

        # Amazon.WorkDocs.SubscriptionType
        "New-WDNotificationSubscription/SubscriptionType"
        {
            $v = "ALL"
            break
        }

        # Amazon.WorkDocs.UserFilterType
        "Get-WDUserList/Include"
        {
            $v = "ACTIVE_PENDING","ALL"
            break
        }

        # Amazon.WorkDocs.UserSortType
        "Get-WDUserList/Sort"
        {
            $v = "FULL_NAME","STORAGE_LIMIT","STORAGE_USED","USER_NAME","USER_STATUS"
            break
        }

        # Amazon.WorkDocs.UserType
        "Update-WDUser/Type"
        {
            $v = "ADMIN","MINIMALUSER","POWERUSER","USER","WORKSPACESUSER"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$WD_map = @{
    "CollectionType"=@("Get-WDResource")
    "GrantPoweruserPrivileges"=@("Update-WDUser")
    "Include"=@("Get-WDUserList")
    "Locale"=@("Update-WDUser")
    "Order"=@("Get-WDFolderContent","Get-WDUserList")
    "PrincipalType"=@("Remove-WDResourcePermission")
    "Protocol"=@("New-WDNotificationSubscription")
    "ResourceState"=@("Update-WDDocument","Update-WDFolder")
    "Sort"=@("Get-WDFolderContent","Get-WDUserList")
    "StorageRule_StorageType"=@("New-WDUser","Update-WDUser")
    "SubscriptionType"=@("New-WDNotificationSubscription")
    "Type"=@("Get-WDFolderContent","Update-WDUser")
    "VersionStatus"=@("Update-WDDocumentVersion")
    "Visibility"=@("New-WDComment")
}

_awsArgumentCompleterRegistration $WD_Completers $WD_map

$WD_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.WD.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$WD_SelectMap = @{
    "Select"=@("Stop-WDDocumentVersionUpload",
               "Enable-WDUser",
               "Add-WDResourcePermission",
               "New-WDComment",
               "New-WDCustomMetadata",
               "New-WDFolder",
               "New-WDLabel",
               "New-WDNotificationSubscription",
               "New-WDUser",
               "Disable-WDUser",
               "Remove-WDComment",
               "Remove-WDCustomMetadata",
               "Remove-WDDocument",
               "Remove-WDFolder",
               "Remove-WDFolderContent",
               "Remove-WDLabel",
               "Remove-WDNotificationSubscription",
               "Remove-WDUser",
               "Get-WDActivity",
               "Get-WDComment",
               "Get-WDDocumentVersionList",
               "Get-WDFolderContent",
               "Get-WDGroup",
               "Get-WDNotificationSubscriptionList",
               "Get-WDResourcePermissionList",
               "Get-WDRootFolder",
               "Get-WDUserList",
               "Get-WDCurrentUser",
               "Get-WDDocument",
               "Get-WDDocumentPath",
               "Get-WDDocumentVersion",
               "Get-WDFolder",
               "Get-WDFolderPath",
               "Get-WDResource",
               "Start-WDDocumentVersionUpload",
               "Remove-WDResourcePermission",
               "Update-WDDocument",
               "Update-WDDocumentVersion",
               "Update-WDFolder",
               "Update-WDUser")
}

_awsArgumentCompleterRegistration $WD_SelectCompleters $WD_SelectMap
# Argument completions for service Amazon WorkLink


$WL_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.WorkLink.AuthorizationProviderType
        "Add-WLWebsiteAuthorizationProviderToFleet/AuthorizationProviderType"
        {
            $v = "SAML"
            break
        }

        # Amazon.WorkLink.IdentityProviderType
        "Update-WLIdentityProviderConfiguration/IdentityProviderType"
        {
            $v = "SAML"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$WL_map = @{
    "AuthorizationProviderType"=@("Add-WLWebsiteAuthorizationProviderToFleet")
    "IdentityProviderType"=@("Update-WLIdentityProviderConfiguration")
}

_awsArgumentCompleterRegistration $WL_Completers $WL_map

$WL_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.WL.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$WL_SelectMap = @{
    "Select"=@("Register-WLDomain",
               "Add-WLWebsiteAuthorizationProviderToFleet",
               "Register-WLWebsiteCertificateAuthority",
               "New-WLFleet",
               "Remove-WLFleet",
               "Get-WLAuditStreamConfiguration",
               "Get-WLCompanyNetworkConfiguration",
               "Get-WLDevice",
               "Get-WLDevicePolicyConfiguration",
               "Get-WLDomain",
               "Get-WLFleetMetadata",
               "Get-WLIdentityProviderConfiguration",
               "Get-WLWebsiteCertificateAuthority",
               "Unregister-WLDomain",
               "Remove-WLWebsiteAuthorizationProviderFromFleet",
               "Unregister-WLWebsiteCertificateAuthority",
               "Get-WLDeviceList",
               "Get-WLDomainList",
               "Get-WLFleetList",
               "Get-WLWebsiteAuthorizationProviderList",
               "Get-WLWebsiteCertificateAuthorityList",
               "Restore-WLDomainAccess",
               "Revoke-WLDomainAccess",
               "Disconnect-WLUser",
               "Update-WLAuditStreamConfiguration",
               "Update-WLCompanyNetworkConfiguration",
               "Update-WLDevicePolicyConfiguration",
               "Update-WLDomainMetadata",
               "Update-WLFleetMetadata",
               "Update-WLIdentityProviderConfiguration")
}

_awsArgumentCompleterRegistration $WL_SelectCompleters $WL_SelectMap
# Argument completions for service Amazon WorkMail


$WM_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.WorkMail.ResourceType
        "New-WMResource/Type"
        {
            $v = "EQUIPMENT","ROOM"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$WM_map = @{
    "Type"=@("New-WMResource")
}

_awsArgumentCompleterRegistration $WM_Completers $WM_map

$WM_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.WM.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$WM_SelectMap = @{
    "Select"=@("Add-WMDelegateToResource",
               "Add-WMMemberToGroup",
               "New-WMAlias",
               "New-WMGroup",
               "New-WMResource",
               "New-WMUser",
               "Remove-WMAlias",
               "Remove-WMGroup",
               "Remove-WMMailboxPermission",
               "Remove-WMResource",
               "Remove-WMUser",
               "Remove-WMFromWorkMail",
               "Get-WMGroup",
               "Get-WMOrganization",
               "Get-WMResource",
               "Get-WMUser",
               "Remove-WMDelegateFromResource",
               "Remove-WMMemberFromGroup",
               "Get-WMMailboxDetail",
               "Get-WMAliasList",
               "Get-WMMemberList",
               "Get-WMGroupList",
               "Get-WMMailboxPermissionList",
               "Get-WMOrganizationList",
               "Get-WMDelegateList",
               "Get-WMResourceList",
               "Get-WMUserList",
               "Write-WMMailboxPermission",
               "Register-WMToWorkMail",
               "Reset-WMPassword",
               "Update-WMMailboxQuota",
               "Update-WMPrimaryEmailAddress",
               "Update-WMResource")
}

_awsArgumentCompleterRegistration $WM_SelectCompleters $WM_SelectMap
# Argument completions for service Amazon WorkMail Message Flow


$WMMF_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.WMMF.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$WMMF_SelectMap = @{
    "Select"=@("Get-WMMFRawMessageContent")
}

_awsArgumentCompleterRegistration $WMMF_SelectCompleters $WMMF_SelectMap
# Argument completions for service Amazon WorkSpaces


$WKS_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.WorkSpaces.AccessPropertyValue
        {
            ($_ -eq "Edit-WKSWorkspaceAccessProperty/WorkspaceAccessProperties_DeviceTypeAndroid") -Or
            ($_ -eq "Edit-WKSWorkspaceAccessProperty/WorkspaceAccessProperties_DeviceTypeChromeOs") -Or
            ($_ -eq "Edit-WKSWorkspaceAccessProperty/WorkspaceAccessProperties_DeviceTypeIos") -Or
            ($_ -eq "Edit-WKSWorkspaceAccessProperty/WorkspaceAccessProperties_DeviceTypeOsx") -Or
            ($_ -eq "Edit-WKSWorkspaceAccessProperty/WorkspaceAccessProperties_DeviceTypeWeb") -Or
            ($_ -eq "Edit-WKSWorkspaceAccessProperty/WorkspaceAccessProperties_DeviceTypeWindows") -Or
            ($_ -eq "Edit-WKSWorkspaceAccessProperty/WorkspaceAccessProperties_DeviceTypeZeroClient")
        }
        {
            $v = "ALLOW","DENY"
            break
        }

        # Amazon.WorkSpaces.Compute
        "Edit-WKSWorkspaceProperty/WorkspaceProperties_ComputeTypeName"
        {
            $v = "GRAPHICS","GRAPHICSPRO","PERFORMANCE","POWER","POWERPRO","STANDARD","VALUE"
            break
        }

        # Amazon.WorkSpaces.DedicatedTenancySupportEnum
        "Edit-WKSAccount/DedicatedTenancySupport"
        {
            $v = "ENABLED"
            break
        }

        # Amazon.WorkSpaces.ReconnectEnum
        {
            ($_ -eq "Edit-WKSClientProperty/ClientProperties_ReconnectEnabled") -Or
            ($_ -eq "Edit-WKSSelfservicePermission/SelfservicePermissions_ChangeComputeType") -Or
            ($_ -eq "Edit-WKSSelfservicePermission/SelfservicePermissions_IncreaseVolumeSize") -Or
            ($_ -eq "Edit-WKSSelfservicePermission/SelfservicePermissions_RebuildWorkspace") -Or
            ($_ -eq "Edit-WKSSelfservicePermission/SelfservicePermissions_RestartWorkspace") -Or
            ($_ -eq "Edit-WKSSelfservicePermission/SelfservicePermissions_SwitchRunningMode")
        }
        {
            $v = "DISABLED","ENABLED"
            break
        }

        # Amazon.WorkSpaces.RunningMode
        "Edit-WKSWorkspaceProperty/WorkspaceProperties_RunningMode"
        {
            $v = "ALWAYS_ON","AUTO_STOP"
            break
        }

        # Amazon.WorkSpaces.TargetWorkspaceState
        "Edit-WKSWorkspaceState/WorkspaceState"
        {
            $v = "ADMIN_MAINTENANCE","AVAILABLE"
            break
        }

        # Amazon.WorkSpaces.Tenancy
        "Register-WKSWorkspaceDirectory/Tenancy"
        {
            $v = "DEDICATED","SHARED"
            break
        }

        # Amazon.WorkSpaces.WorkspaceImageIngestionProcess
        "Import-WKSWorkspaceImage/IngestionProcess"
        {
            $v = "BYOL_GRAPHICS","BYOL_GRAPHICSPRO","BYOL_REGULAR"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$WKS_map = @{
    "ClientProperties_ReconnectEnabled"=@("Edit-WKSClientProperty")
    "DedicatedTenancySupport"=@("Edit-WKSAccount")
    "IngestionProcess"=@("Import-WKSWorkspaceImage")
    "SelfservicePermissions_ChangeComputeType"=@("Edit-WKSSelfservicePermission")
    "SelfservicePermissions_IncreaseVolumeSize"=@("Edit-WKSSelfservicePermission")
    "SelfservicePermissions_RebuildWorkspace"=@("Edit-WKSSelfservicePermission")
    "SelfservicePermissions_RestartWorkspace"=@("Edit-WKSSelfservicePermission")
    "SelfservicePermissions_SwitchRunningMode"=@("Edit-WKSSelfservicePermission")
    "Tenancy"=@("Register-WKSWorkspaceDirectory")
    "WorkspaceAccessProperties_DeviceTypeAndroid"=@("Edit-WKSWorkspaceAccessProperty")
    "WorkspaceAccessProperties_DeviceTypeChromeOs"=@("Edit-WKSWorkspaceAccessProperty")
    "WorkspaceAccessProperties_DeviceTypeIos"=@("Edit-WKSWorkspaceAccessProperty")
    "WorkspaceAccessProperties_DeviceTypeOsx"=@("Edit-WKSWorkspaceAccessProperty")
    "WorkspaceAccessProperties_DeviceTypeWeb"=@("Edit-WKSWorkspaceAccessProperty")
    "WorkspaceAccessProperties_DeviceTypeWindows"=@("Edit-WKSWorkspaceAccessProperty")
    "WorkspaceAccessProperties_DeviceTypeZeroClient"=@("Edit-WKSWorkspaceAccessProperty")
    "WorkspaceProperties_ComputeTypeName"=@("Edit-WKSWorkspaceProperty")
    "WorkspaceProperties_RunningMode"=@("Edit-WKSWorkspaceProperty")
    "WorkspaceState"=@("Edit-WKSWorkspaceState")
}

_awsArgumentCompleterRegistration $WKS_Completers $WKS_map

$WKS_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.WKS.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$WKS_SelectMap = @{
    "Select"=@("Register-WKSIpGroup",
               "Approve-WKSIpRule",
               "Copy-WKSWorkspaceImage",
               "New-WKSIpGroup",
               "New-WKSTag",
               "New-WKSWorkspace",
               "Remove-WKSIpGroup",
               "Remove-WKSTag",
               "Remove-WKSWorkspaceImage",
               "Unregister-WKSWorkspaceDirectory",
               "Get-WKSAccount",
               "Get-WKSAccountModification",
               "Get-WKSClientProperty",
               "Get-WKSIpGroup",
               "Get-WKSTag",
               "Get-WKSWorkspaceBundle",
               "Get-WKSWorkspaceDirectory",
               "Get-WKSWorkspaceImage",
               "Get-WKSWorkspace",
               "Get-WKSWorkspacesConnectionStatus",
               "Get-WKSWorkspaceSnapshot",
               "Unregister-WKSIpGroup",
               "Import-WKSWorkspaceImage",
               "Get-WKSAvailableManagementCidrRangeList",
               "Edit-WKSAccount",
               "Edit-WKSClientProperty",
               "Edit-WKSSelfservicePermission",
               "Edit-WKSWorkspaceAccessProperty",
               "Edit-WKSWorkspaceCreationProperty",
               "Edit-WKSWorkspaceProperty",
               "Edit-WKSWorkspaceState",
               "Restart-WKSWorkspace",
               "Reset-WKSWorkspace",
               "Register-WKSWorkspaceDirectory",
               "Restore-WKSWorkspace",
               "Revoke-WKSIpRule",
               "Start-WKSWorkspace",
               "Stop-WKSWorkspace",
               "Remove-WKSWorkspace",
               "Update-WKSRulesOfIpGroup")
}

_awsArgumentCompleterRegistration $WKS_SelectCompleters $WKS_SelectMap
# Argument completions for service AWS X-Ray


$XR_Completers = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Amazon.XRay.EncryptionType
        "Write-XREncryptionConfig/Type"
        {
            $v = "KMS","NONE"
            break
        }

        # Amazon.XRay.SamplingStrategyName
        "Get-XRTraceSummary/SamplingStrategy_Name"
        {
            $v = "FixedRate","PartialScan"
            break
        }

        # Amazon.XRay.TimeRangeType
        "Get-XRTraceSummary/TimeRangeType"
        {
            $v = "Event","TraceId"
            break
        }


    }

    $v |
        Where-Object { $_ -like "$wordToComplete*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$XR_map = @{
    "SamplingStrategy_Name"=@("Get-XRTraceSummary")
    "TimeRangeType"=@("Get-XRTraceSummary")
    "Type"=@("Write-XREncryptionConfig")
}

_awsArgumentCompleterRegistration $XR_Completers $XR_map

$XR_SelectCompleters = {
    param($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    $cmdletType = Invoke-Expression "[Amazon.PowerShell.Cmdlets.XR.$($commandName.Replace('-', ''))Cmdlet]"
    if (-not $cmdletType) {
        return
    }
    $awsCmdletAttribute = $cmdletType.GetCustomAttributes([Amazon.PowerShell.Common.AWSCmdletAttribute], $false)
    if (-not $awsCmdletAttribute) {
        return
    }
    $type = $awsCmdletAttribute.SelectReturnType
    if (-not $type) {
        return
    }

    $splitSelect = $wordToComplete -Split '\.'
    $splitSelect | Select-Object -First ($splitSelect.Length - 1) | ForEach-Object {
        $propertyName = $_
        $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')) | Where-Object { $_.Name -ieq $propertyName }
        if ($properties.Length -ne 1) {
            break
        }
        $type = $properties.PropertyType
        $prefix += "$($properties.Name)."

        $asEnumerableType = $type.GetInterface('System.Collections.Generic.IEnumerable`1')
        if ($asEnumerableType -and $type -ne [System.String]) {
            $type =  $asEnumerableType.GetGenericArguments()[0]
        }
    }

    $v = @( '*' )
    $properties = $type.GetProperties(('Instance', 'Public', 'DeclaredOnly')).Name | Sort-Object
    if ($properties) {
        $v += ($properties | ForEach-Object { $prefix + $_ })
    }
    $parameters = $cmdletType.GetProperties(('Instance', 'Public')) | Where-Object { $_.GetCustomAttributes([System.Management.Automation.ParameterAttribute], $true) } | Select-Object -ExpandProperty Name | Sort-Object
    if ($parameters) {
        $v += ($parameters | ForEach-Object { "^$_" })
    }

    $v |
        Where-Object { $_ -match "^$([System.Text.RegularExpressions.Regex]::Escape($wordToComplete)).*" } |
        ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

$XR_SelectMap = @{
    "Select"=@("Get-XRTraceBatch",
               "New-XRGroup",
               "New-XRSamplingRule",
               "Remove-XRGroup",
               "Remove-XRSamplingRule",
               "Get-XREncryptionConfig",
               "Get-XRGroup",
               "Get-XRGroupSummary",
               "Get-XRSamplingRule",
               "Get-XRSamplingStatisticSummary",
               "Get-XRSamplingTarget",
               "Get-XRServiceGraph",
               "Get-XRTimeSeriesServiceStatistic",
               "Get-XRTraceGraph",
               "Get-XRTraceSummary",
               "Write-XREncryptionConfig",
               "Write-XRTelemetryRecord",
               "Write-XRTraceSegment",
               "Update-XRGroup",
               "Update-XRSamplingRule")
}

_awsArgumentCompleterRegistration $XR_SelectCompleters $XR_SelectMap


$AWS_RegionCompleter = {
	param ($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

	$regionHash = @{ }

    # Similar to Get-AWSRegion
	$regions = [Amazon.RegionEndpoint]::EnumerableAllRegions
	foreach ($r in $regions)
	{
		$regionHash.Add($r.SystemName, $r.DisplayName)
	}

	$regionHash.Keys |
	Sort-Object |
	Where-Object { $_ -like "$wordToComplete*" } |
	ForEach-Object {
		New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $regionHash[$_]
	}
}

_awsArgumentCompleterRegistration $AWS_RegionCompleter @{ "Region"=@() }

$AWS_ProfileNameCompleter = {
	param ($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

	# allow for new user with no profiles set up yet
	$profiles = Get-AWSCredentials -ListProfileDetail | select -expandproperty ProfileName
	if ($profiles)
	{
		$profiles |
		Sort-Object |
		Where-Object { $_ -like "$wordToComplete*" } |
		ForEach-Object {
			New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_
		}
	}
}

_awsArgumentCompleterRegistration $AWS_ProfileNameCompleter @{ "ProfileName"=@() }
$AWS_EC2ImageByNameCompleter = {
	param ($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

	$keys = [Amazon.EC2.Util.ImageUtilities]::ImageKeys

	$keys |
	Sort-Object -Descending |
	Where-Object { $_ -like "$wordToComplete*" } |
	ForEach-Object {
		New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_
	}
}

_awsArgumentCompleterRegistration $AWS_EC2ImageByNameCompleter @{ "Name"=@("Get-EC2ImageByName") }

# The attribute name parameter for EC2 apis such as ModifyImageAttribute is modeled as a string
# in the service model rather than an enum type, which means by default we cannot auto-generate
# an argument completer. Api's use as DescribeImageAttribute do use an enum type (ImageAttributeName)
# and so don't have this problem.
$AWS_EC2ImageAttributeCompleter = {
	param ($commandName, $parameterName, $wordToComplete, $commandAst, $fakeBoundParameter)

    switch ($("$commandName/$parameterName"))
    {
        # Taken from Amazon.EC2.ImageAttributeName
        "Edit-EC2ImageAttribute/Attribute"
        {
            $v = "description","kernel","ramdisk","launchPermission","productCodes","blockDeviceMapping","sriovNetSupport"
            break
        }
    }

    $v |
    Where-Object { $_ -like "$wordToComplete*" } |
    ForEach-Object { New-Object System.Management.Automation.CompletionResult $_, $_, 'ParameterValue', $_ }
}

_awsArgumentCompleterRegistration $AWS_EC2ImageAttributeCompleter @{ "Attribute"=@("Edit-EC2ImageAttribute") }